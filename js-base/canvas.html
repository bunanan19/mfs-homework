<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- <meta http-equiv="refresh" content="1"> -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas</title>
</head>
<body>
    <canvas id="myCanvas" width="200px" height="200px" style="border:1px solid #c3c3c3;">
        Your browser does not support the canvas element.
    </canvas>

    <script>
            document.domain = "a.com"//降域
            var c = document.getElementById("myCanvas");
            var cxt = c.getContext("2d");
            //画矩形
            //cxt.strokeStyle = 'blue';   // 设置轮廓颜色为蓝色
            //cxt.fillStyle="#FF0000";//填充颜色设置
            //cxt.fillRect(0,0,75,75)//左上角0,0和右下角150，75的坐标，长宽75

            //画线
            //cxt.moveTo(10,10);//将画笔移到10，10位置
            //cxt.lineTo(150,50);//从10，10画线到150，50
            //cxt.lineTo(10,50);//从150，50画线到10，50
            //cxt.stroke();// 画出图画轮廓。stroke：冲程。计算机缓存机制，画先在内存中画好在，不会直接展示在页面。
            
            //画圆
            //cxt.beginPath();
            //cxt.arc(70,18,15,0,Math.PI*2,true);
            //arc方法画弧线，前三个参数（70,18,15）定义了圆形的位置（x，y，半径）。
            //接下来的两个参数（0和Math.PI*2）定义了圆形的起始角度（0度）和结束角度（360度，或者说2π弧度）。
            //最后一个参数（true）表示绘制顺时针的圆形
            //cxt.closePath();//begin和close成对出现，目的是使图形封闭，才能填充图形
            //cxt.fill();
            //填充当前路径。例子中，这个路径是一个圆形。当你调用cxt.fill();时，圆形会被填充，从而在画布上显示出圆形。
            //如果你没有提供任何参数给cxt.fill();，它会使用默认的颜色、模式和样式进行填充。
            //使用cxt.fillStyle来设置填充的颜色，使用cxt.fillRect来设置填充的矩形，或者使用cxt.fillText来设置文本的填充。

            //渐变
            //var grd=cxt.createLinearGradient(0,0,175,50);//创建一个从点(0,0)到点(175,50)的线性渐变
            //grd.addColorStop(0,"#FF0000");//在渐变的开始位置（即0%）添加颜色停点，该停点的颜色是红色
            //grd.addColorStop(1,"#00FF00");//渐变的结束位置（即100%）添加颜色停点。颜色停点的位置是相对于0和1的，0表示渐变的开始，1表示渐变的结束
            //cxt.fillStyle=grd;//设置填充颜色为之前创建的渐变对象grd
            //cxt.fillRect(0,0,175,50);

            //将一幅图片放在画布上
            // var img = document.getElementById("scream");
            // ctx.drawImage(img, 10, 10);

            
        //钟表

            cxt.translate(100,100);//移动画布坐标轴，原点为画布中心
            //cxt.scale(1,-1)//缩放使x轴不变，y轴朝上。方便绘制钟表刻点
            cxt.rotate(-Math.PI / 2);//使x轴朝上

        function clock(){      
            cxt.clearRect(-100,-100,200,200)//用于清除 canvas 上的某个矩形区域。     
            cxt.lineCap = "round";
            cxt.lineWidth = 4.5;      
            cxt.strokeStyle = "black";

            //时刻点
            cxt.save();
            cxt.lineWidth = 4;
            for(var i = 0; i < 12; i++){
                var t = Math.PI / 6 * i
                var x = 65 * Math.cos(t)
                var y = 65 * Math.sin(t)
                //var X = 55 * Math.cos(t)
                //var Y = 55 * Math.sin(t)
                cxt.moveTo(x,y)
                cxt.lineTo(0.85*x,0.85*y)
                //cxt.lineTo(X,Y)
                cxt.lineCap = "round"
                // cxt.stroke()
            }
            cxt.restore()

            //分刻点
            cxt.save()
            cxt.lineWidth = 2;
            for(var i = 0; i < 60; i++){
                var t = Math.PI / 30 * i
                var x = 65 * Math.cos(t)
                var y = 65 * Math.sin(t)
                cxt.moveTo(x,y)
                cxt.lineTo(0.99*x,0.99*y)
                cxt.stroke()
            }
            cxt.restore()

            var now = new Date();
            var h = now.getHours();
            var m = now.getMinutes();
            var s = now.getSeconds();
            h = h>= 12? h-12 : h;

            // if (h < 10) {
            //     h = "0" + h;
            // }
            // if (m < 10) {
            //     m = "0" + m;
            // }
            // if (s < 10) {
            //     s = "0" + s;
            // }

            //时针          
            cxt.save()
            cxt.lineCap = "round"
            var c = Math.PI / 6 * (h)+ (Math.PI / 360) * (m) + (Math.PI / 21600) * (s);//
            cxt.beginPath();
            cxt.moveTo(-8*Math.cos(c),-8*Math.sin(c));
            cxt.lineTo(40*Math.cos(c),40*Math.sin(c));
            cxt.closePath(); 
            cxt.strokeStyle = "black"      
            cxt.stroke()
            cxt.restore()

            //分针
            cxt.save()
            var a = Math.PI / 30 * (m)+ (Math.PI / 3600) * (s);//
            cxt.lineWidth = 3;
            cxt.moveTo(-10*Math.cos(a),-10*Math.sin(a));
            cxt.lineTo(62*Math.cos(a),62*Math.sin(a));
            cxt.lineCap = "round"
            cxt.stroke()
            cxt.restore()

            //秒针
            cxt.save()
            cxt.lineWidth = 1.5;
            var b = Math.PI / 30 * (s);//
            cxt.beginPath();
            cxt.moveTo(-15*Math.cos(b),-15*Math.sin(b));
            cxt.lineTo(-4*Math.cos(b),-4*Math.sin(b));
            cxt.moveTo(2*Math.cos(b),2*Math.sin(b));
            cxt.lineTo(55*Math.cos(b),55*Math.sin(b));
            cxt.closePath();
            cxt.lineCap = "round"
            cxt.strokeStyle = "red"
            cxt.stroke()
            cxt.restore()

            //圆心
            cxt.save()
            cxt.lineWidth = 1.5;
            cxt.moveTo(0,0)
            cxt.beginPath();
            cxt.arc(0,0,2.5,0,Math.PI*2,true)
            cxt.closePath();
            cxt.strokeStyle = "red"
            cxt.stroke()
            cxt.restore()

            //秒针上的圆圈
            cxt.beginPath();
            cxt.lineWidth = 1.5;
            cxt.arc(58*Math.cos(b),58*Math.sin(b),4,0,Math.PI*2,true)
            cxt.closePath();
            cxt.strokeStyle = "red"
            cxt.stroke()

            //绘制时钟外圈
            cxt.save();//保存画布 (canvas) 的所有状态。每当save()方法被调用后，当前的状态就被推送到栈中保存。
            cxt.strokeStyle = "#0055AB";//描边颜色设置
            cxt.lineWidth = 8;//线段样式设置
            cxt.beginPath();
            cxt.arc(0,0,80,0,Math.PI*2,true);
            cxt.closePath();
            cxt.stroke()
            cxt.restore()//每一次调用 restore 方法，上一个保存的状态就从栈中弹出，所有设定都恢复。
            // requestAnimationFrame(clock);
            //允许你请求浏览器在下一次重绘之前调用指定的函数来更新动画。
            //这通常被用于创建动画，因为它可以让你在每一帧画面前后执行一些代码，以此来实现平滑动画的效果。
        }
        // requestAnimationFrame(clock);
        setInterval(clock,1000)
        //与 setTimeout 和 setInterval 不同，requestAnimationFrame 不需要设置时间间隔。requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率
        //setTimeout 和 setInterval 的问题是，它们都不精确。它们的内在运行机制决定了时间间隔参数实际上只是指定了把动画代码添加到浏览器 UI 线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行
    </script>
</body>
</html>