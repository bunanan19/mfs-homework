# 单线程模型和事件循环

## 定时器

首先要先讲解下定时器，js中的定时器有两种： setTimeout() 和 setInterval()

### setTimeout()

> setTimeout(code,millisec)

|   参数   | 解释                                             |
| :------: | :----------------------------------------------- |
|   code   | 必需。要调用的函数后要执行的 JavaScript 代码串。 |
| millisec | 必需。在执行代码前需等待的毫秒数。               |

return 定时器 id，可以通过 clearTimeout(id) 取消定时器任务

> 注意：code可以为function或者string

setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。

```js
var id = setTimeout(function(){
    console.log('console.log("10秒后打印")')
},10*1000)
// clearTimeout(id)
```

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012105655468.png" alt="image-20231012105655468" style="zoom:80%;" />

### setInterval()  [ˈɪntərvl]

> setInterval(code,millisec)

|   参数   | 解释                                             |
| :------: | :----------------------------------------------- |
|   code   | 必需。要调用的函数后要执行的 JavaScript 代码串。 |
| millisec | 必需。在执行代码前需等待的毫秒数。               |

return 定时器 id，可以通过 clearInterval(id) 取消定时器任务

> 注意：code可以为function或者string

setInterval() 方法用于在指定的毫秒数后调用函数或计算表达式。

```js
var id = setInterval(function(){
    console.log('console.log("10秒后打印")')
},10*1000)
// clearInterval(id)
```

### 使用setTimeout()实现setInterval()

```js
function mySetInterval(fun,millisec){
    setTimeout(function(){
        fun();
        mySetInterval(fun,millisec)
    },millisec);
}

这段代码是一个JavaScript函数，名为mySetInterval。这个函数接受两个参数，一个是要重复执行的函数fun，另一个是时间间隔millisec。

这个mySetInterval函数的工作原理如下：
1. 调用 mySetInterval 函数，并传入要执行的函数 fun 和间隔时间 millisec。 
2. 在 millisec 毫秒后，setTimeout 中的回调函数被触发。 
3. 回调函数内部首先执行 fun 函数，然后再次调用 mySetInterval 函数，并传入相同的 fun 和 millisec。 
4. 这样就会形成一个循环，每次间隔 millisec 毫秒后，fun 函数会被执行一次，然后再次设置定时器以实现下一次的调用。 
需要注意的是，这个实现与标准的setInterval函数有所不同。标准的setInterval函数在给定的时间间隔后就会立即调用函数，而这个mySetInterval函数是在给定的时间间隔结束时才第一次调用函数。也就是说，这个函数有一个初始的延迟。
```

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012121443173.png" alt="image-20231012121443173" style="zoom:80%;" />

## 单线程模型

JavaScript是单线程的，同一时刻只能执行特定的任务。

> 进程和线程都是操作系统的概念。进程是应用程序的执行实例，每一个进程都是由私有的虚拟地址空间、代码、数据和其它系统资源所组成；进程在运行过程中能够申请创建和使用系统资源（如独立的内存区域等），这些资源也会随着进程的终止而被销毁。而线程则是进程内的一个独立执行单元，在不同的线程之间是可以共享进程资源的，所以在多线程的情况下，需要特别注意对临界资源的访问控制。在系统创建进程之后就开始启动执行进程的主线程，而进程的生命周期和这个主线程的生命周期一致，主线程的退出也就意味着进程的终止和销毁。主线程是由系统进程所创建的，同时用户也可以自主创建其它线程，这一系列的线程都会并发地运行于同一个进程中。
>
> <img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012122420792.png" alt="image-20231012122420792" style="zoom:80%;" />
>
> <img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012123722386.png" alt="image-20231012123722386" style="zoom:80%;" />
>
> <img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012123911142.png" alt="image-20231012123911142" style="zoom:80%;" />

但是我们经常看到如下代码

```js
foo.onclick = function(e) {
    //...
};
bar.onclick = function(e) {
    //...
};
//事件处理也是异步的
```

思考：当foo和bar被点击的时候，为什么会执行 function 里的代码？

> 在JavaScript中，当你点击一个元素（如`foo`和`bar`）时，消息队列里面就push了该事件，单线程处理机调度线程任务，触发该元素的"click"事件。在上面的代码中，`foo`和`bar`分别被分配了一个事件处理函数，这两个函数会在对应的元素被点击时被触发。
>
> 当一个事件（如点击、按键、鼠标移动等）被触发时，浏览器会执行与该事件关联的事件处理函数。
>
> 这种事件处理是JavaScript中常见的模式，用于响应用户的交互。事件处理是单线程的，也就是说，当一个事件处理函数正在执行时，其他所有的JavaScript代码（包括其他事件处理函数）都会等待它完成。如果一个事件处理函数需要很长时间来执行，它可能会阻止用户交互，因此，通常需要确保事件处理函数快速且高效。

### 从一道面试题说起

```js
var t = true;

setTimeout(function (){
    t = false;
},1000);

while (t){}

alert('end');

这段代码会产生死循环的原因是因为 while 循环的条件 while (t){} 中的 t 始终为 true 。在JavaScript中， setTimeout 函数是异步的，它会在指定的时间后将回调函数添加到事件队列中。而 while 循环会一直执行，不会给事件队列处理的机会，因此 setTimeout 的回调函数无法执行，导致 t 的值无法被修改为 false ，从而造成了死循环。
```

输出是什么那？不少同学会不假思索的说1s后alert('end')。其实不然，执行这行代码会一直死循环。原因是js是单线程模型，setTimeout()是通过事件循环实现的。

### 事件循环

js中使用事件循环机制，实现并发（注意不是并行）**并发是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。并行是指一组程序按独立异步的速度执行，不等于时间上的重叠（同一个时刻发生）**。



js的事件循环是通过队列（先进先出）实现的，让我先了解下什么是队列

#### 队列

栈是FIFO（先进先出）的数据结构



##### js实现

```js
names = [];
names.push("Cynthia");
names.push("Jennifer");

names.shift();

names.push("foo");
names.push("bar");

names.shift();
```

把所有的push和shift放在一起并*不影响结果*

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011215704679.png" alt="image-20231011215704679" style="zoom:80%;" />

##### js中的应用

事件循环机制

![img](http://fe-base.books.mafengshe.com/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/Javascript/images/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png)

#### 栈

栈是FILO（先进后出）的数据结构 ![img](http://fe-base.books.mafengshe.com/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/Javascript/images/stack.jpg)

##### js实现

```js
names = [];
names.push("Cynthia");
names.push("Jennifer");

names.pop();

names.push("foo");
names.push("bar");

names.pop();
```

push和pop调换顺序会*影响结果*

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011215839311.png" alt="image-20231011215839311" style="zoom:80%;" />

##### js中的应用

函数调用栈

错误处理

```js
function a(){
    b();
}
function b(){
    c();
}
function c(){
    //抛出异常
    throw new Error("throw this")
}
c();
```

### 定时器是准确的吗？

执行下面代码

```js
var start = new Date;
setInterval(function(){
    var end = new Date;
    console.log('Time elapsed:', end - start, 'ms');
    start = end;
}, 500);
```

打印出来的 Time elapsed 会发现不是精确的500ms，可能是499ms，也可能是501ms。

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011220105744.png" alt="image-20231011220105744" style="zoom: 67%;" />

这好像看不出来js的定时器的不准确的规律。我们可以将代码改进一下，发现其规律

```js
var start = new Date;
setInterval(function(){
    var end = new Date;
    console.log('Time elapsed:', end - start, 'ms');
	// start = end;
}, 500);
```

这次我们打印的是从开始执行到当前时间的总时间差，我们可以发现定时器其实**总是延后触发的**。和事件循环这一机制匹配

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011220439124.png" alt="image-20231011220439124" style="zoom:67%;" />

让我们再执行下一段代码

```js
var start = new Date;
var count = 0;
setInterval(function(){
    var end = new Date;
    console.log('Time elapsed:', end - start, 'ms');
    start = end;
    count++;
    if(count === 2){
        for(var i = 0; i < 1990000000; i++);
    }
}, 500);
```

这次第三次打印的 Time elapsed 有了显著变化

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011220742074.png" alt="image-20231011220742074" style="zoom:67%;" />

再换种写法试试

```js
var start = new Date;
setInterval(function(){
    var end = new Date;
    console.log('Time elapsed:', end - start, 'ms');
    start = end;
}, 500);
for(var i = 0; i < 1990000000; i++);
```

这次是第一次打印的 Time elapsed 有了显著变化

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011220941318.png" alt="image-20231011220941318" style="zoom:80%;" />



```javascript
var start = Date.now();
setInterval(function(){
    console.log(start, Date.now());
}, 1000);
for(;Date.now()<start+2500;){}
这段代码是一个简单的循环，它会持续执行直到当前时间超过了 start 加上 2500 的时间。 
具体来说，代码中的  Date.now()  返回当前的时间戳，而  start  是一个表示起始时间的变量。循环的条件是当前时间戳小于  start  加上 2500，即循环会一直执行直到达到指定的时间。 
这段代码用于实现一个延时操作或者等待一段时间的目的。循环  for(;Date.now()<start+2500;){}  会导致主线程被占用，因此  setInterval  的回调函数无法及时执行。这可能会导致一些间隔被跳过。 
 
在这种情况下， setInterval  的间隔时间是1000毫秒，但由于循环的执行时间超过1000毫秒，因此会导致回调函数的执行被延迟。 
循环的执行时间为2500毫秒。那么，在第一次循环执行结束后，已经过去了2500毫秒，此时回调函数才有机会执行。因此，第一个间隔和第二个间隔被跳过了。第三个直接执行，第四个前面隔了2000毫秒和一个500毫秒，所以第四个500毫秒后执行。 
```



<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231015220448885.png" alt="image-20231015220448885" style="zoom:80%;" /><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231016222257543.png" alt="image-20231016222257543" style="zoom:80%;" />

setTimeOut和setInterVal中时间参数并不是到点就立即执行，而是到点将其回调事件加入事件队列中。按照队列先进先出的性质，该回调事件到点之后是否能执行取决于是否属于队列首位，如果前头还有其他事件在等待，则不能按点执行。这并是导致事件等待执行时间出现误差的原因。

在《JavaScript高级程序设计（第三版）》22.3中，有描述：

定时器对队列的工作方式是，当特定时间过去后将代码插入。注意，给队列添加代码并不意味着对它立刻执行，而只能表示它会尽快执行。设定一个 150ms 后执行的定时器不代表到了 150ms 代码就立刻执行，它表示代码会在 150ms 后被加入到队列中。如果在这个时间点上，队列中没有其他东西，那么这段代码就会被执行。

setinterval无视代码错误

setInterval并不定时，**某些间隔会被跳过，如果设置的时间间隔小于函数执行的事件的时间，那么某个函数的执行可能会被忽略（每个setTimeout产生的任务会直接push到任务队列中；而setInterval在每次把任务push到任务队列前，都要进行一下判断(看上次的任务是否仍在队列中)）**

可能多个定时器会连续执行

setTimeout模拟setInterval
setTimeout(function () { // 任务 setTimeout(arguments.callee, interval); }, interval)

在前一个定时器执行完前，不会向队列插入新的定时器（解决缺点一）
保证定时器间隔（解决缺点二，好于setinterval）

setInterval问题：当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束后，这些事件会依次执行而之间没有任何停顿，不能达到间隔一段时间执行的效果

- 幸好，JavaScript 引擎够聪明，能避免这个问题。当使用 setInterval()时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中
- 这种重复定时器的问题在于:某些间隔会被跳过
  多个定时器的代码执行之间的间隔可能会比预期的小。
  假设，某个 onclick 事件处理程序使用 setInterval()设置了一个 200ms 间隔的重复定时器。如果事件处理程序花了 300ms 多一点的时间完成，同时定时器代码也花了差不多的时间，就会同时出现跳过间隔且连续运行定时器代码的情况。

# javascript :setInterval() 跳过调用

对于即将使用 node.js 的项目，我需要定期执行各种管家任务。特别是一些任务每毫秒，其他每 20 毫秒(每秒 50 次)，还有一些每秒。所以我考虑使用 setInterval()，结果很有趣:很多函数调用都被跳过了。

我使用的基准如下:

```javascript
var counter = 0;
var seconds = 0;
var short = 1;
setInterval(function() {
        counter ++;
    }, short);
setInterval(function() {
        seconds ++;
        log('Seconds: ' + seconds + ', counter: ' +
             counter + ', missed ' +
             (seconds * 1000 / short - counter));
    }, 1000);
```

有一个一秒的长计时器和一个短计时器，可以使用变量`short`进行调整，在本例中为1 ms。每一秒，我们都会打印短周期中预期滴答数与短计数器更新的实际次数之间的差值。

当短定时器为 1 毫秒时，它的行为如下:

```
2012-09-14T23:03:32.780Z Seconds: 1, counter: 869, missed 131
2012-09-14T23:03:33.780Z Seconds: 2, counter: 1803, missed 197
2012-09-14T23:03:34.781Z Seconds: 3, counter: 2736, missed 264
...
2012-09-14T23:03:41.783Z Seconds: 10, counter: 9267, missed 733
```

许多函数调用被跳过。这是 10 毫秒:

```
2012-09-14T23:01:56.363Z Seconds: 1, counter: 93, missed 7
2012-09-14T23:01:57.363Z Seconds: 2, counter: 192, missed 8
2012-09-14T23:01:58.364Z Seconds: 3, counter: 291, missed 9
...
2012-09-14T23:02:05.364Z Seconds: 10, counter: 986, missed 14
```

更好，但大约每秒跳过一个函数调用。并持续 20 毫秒:

```
2012-09-14T23:07:18.713Z Seconds: 1, counter: 46, missed 4
2012-09-14T23:07:19.713Z Seconds: 2, counter: 96, missed 4
2012-09-14T23:07:20.712Z Seconds: 3, counter: 146, missed 4
...
2012-09-14T23:07:27.714Z Seconds: 10, counter: 495, missed 5
```

最后100毫秒:

```
2012-09-14T23:04:25.804Z Seconds: 1, counter: 9, missed 1
2012-09-14T23:04:26.803Z Seconds: 2, counter: 19, missed 1
2012-09-14T23:04:27.804Z Seconds: 3, counter: 29, missed 1
...
2012-09-14T23:04:34.805Z Seconds: 10, counter: 99, missed 1
```

在这种情况下，它会跳过很少的调用(间隔在 33 秒后增加到 2，在 108 秒后增加到 3。

数字各不相同，但在运行之间却惊人地一致:在前 1 毫秒的基准测试中运行 3 次会在 9267、9259 和 9253 的 10 秒后产生延迟。

我没有找到这个特定问题的引用资料。有这个[much cited Ressig post](http://ejohn.org/blog/accuracy-of-javascript-time/)和许多相关的 JavaScript 问题，但大多数假设代码在浏览器中运行，而不是在 node.js 中。

现在是可怕的问题:这里发生了什么？开个玩笑；显然函数调用被跳过了。但我看不到这种模式。我认为长周期可能会阻止短周期，但在 1 ms 的情况下它没有任何意义。短周期函数调用不会重叠，因为它们只是更新一个变量，并且 node.js 进程即使在 1 毫秒的短周期内也接近 5% 的 CPU。但平均负载很高，约为 0.50。不过，我不知道为什么一千次调用对我的系统造成如此大的压力，因为 node.js 处理 [many more clients perfectly](http://blog.caustik.com/2012/04/08/scaling-node-js-to-100k-concurrent-connections/) ; [setInterval() is CPU intensive](https://stackoverflow.com/questions/6650134/is-setinterval-cpu-intensive) 一定是真的(或者我做错了什么)。

一个明显的解决方案是使用较长的计时器对函数调用进行分组，然后多次运行短周期函数调用以模拟较短的计时器。然后将长周期用作“扫帚车”，在较低的时间间隔内错过任何调用。一个例子:设置 20 毫秒和 1000 毫秒的 setInterval() 调用。对于 1 ms 调用:在 20 ms 回调中调用它们 20 次。对于 1000 毫秒的调用:检查 20 毫秒函数被调用了多少次(例如 47 次)，执行任何剩余的调用(例如 3 次)。但是这个方案会有点复杂，因为调用可能会以有趣的方式重叠；虽然看起来很像，但它也不会是常规的。

真正的问题是:使用 setInterval() 或 node.js 中的其他计时器可以做得更好吗？提前致谢。

**最佳答案**

javascript 中的 SetInterval 函数不准确。您应该尝试使用高分辨率计时器。 [Building accurate Timers in javascript](http://www.sitepoint.com/creating-accurate-timers-in-javascript/)



### 我们自己实现的 mySetInterval() 和系统提供的 setInterval()行为一致吗？

- id会不断改变，不利于取消
- 事件处理函数内用时过长会影响下一次定时器触发时间，时间间隔总是大于设置的间隔
- 误差越来越大，不会修正
- 但是自实现的mysetinterval不会出现跳过时间间隔的情况

大家可以自行运行下面两段代码对比其中差异

```js
var start = new Date;
setInterval(function(){
    var end = new Date;
    console.log('Time elapsed:', end - start, 'ms');
    start = end;
    for(var i = 0; i < 10000*10000; i++);
},1000)
//时间出现误差，会尽可能修正

var start = new Date;
mySetInterval(function(){
    var end = new Date;
    console.log('Time elapsed:', end - start, 'ms');
    start = end;
    for(var i = 0; i < 10000*10000; i++);
},1000)
//差距时间出现的误差较大，而且一直累积，不会修正
```

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011221100427.png" alt="image-20231011221100427" style="zoom:67%;" /><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011221301544.png" alt="image-20231011221301544" style="zoom:67%;" />



补充：

```js
for(var i = 0;i < 5; i++){
    setTimeout(function(){
        console.log(i);
    },1000)
}
console.log(i)
//输出： 5    555555
```

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231022145855156.png" alt="image-20231022145855156" style="zoom:80%;" />

因为定时器异步处理，当1秒以后执行setTimeout时，for循环已经结束，i已经等于5，再执行console.log时打印结果为5。修改：

```js
for(var i = 0;i < 5; i++){
    (function(i){
        setTimeout(function(){
        console.log(i);
    	},1000)
    })(i)//立即执行函数
}
console.log(i)

//es6：
for(let i = 0;i < 5; i++){
    setTimeout(function(){
        console.log(i);
    },1000)
}
console.log(i)
```

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231022150544093.png" alt="image-20231022150544093" style="zoom:80%;" /><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231022150652428.png" alt="image-20231022150652428" style="zoom:80%;" />





## 问答题

1. setTimeout 或者 setInterval 设置定时器是准时触发的吗？为什么？如果不是，他可能延时触发还是延后触发？

   > 不是准时触发，因为一般会延迟触发，因为执行`var time=new Date()`需要时间，获取date也需要时间。它们的内在运行机制决定了时间间隔参数实际上只是指定了把代码添加到浏览器 UI 线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那定时器中的代码代码就要等前面的任务完成后再执行

2. 如下代码 setInterval 设置的定时器激活间隔为多少？为什么？

   ```js
   setInterval(function(){
     for(var i=0;i<1000*1000*1000;i++);//假设这行代码运行需要100ms
   },1000)
   ```

   > 1000ms,setInterval会修正误差。

3. 如下代码的输出是什么？为什么？

   ```js
   setTimeout(function(){
     console.log(1);
   },0)
   console.log(2);
   ```

   > 先是2，后打印1。
   >
   > 这是因为 JavaScript 使用事件循环来处理异步任务。当代码执行时， `console.log(2)`  语句会同步执行，并立即将  `2`  打印到控制台。   然后， `setTimeout`  函数以 0 毫秒的延迟被调用。即使延迟设置为 0，回调函数 ( `console.log(1)` ) 仍然被视为异步任务，并被添加到事件队列中。   一旦同步任务完成，JavaScript 事件循环将检查事件队列中是否有待处理的任务。在这种情况下，它会找到  `console.log(1)`  任务并执行它，将  `1`  打印到控制台。   因此，输出将是  `2` ，然后是  `1` 。

4. 如下代码执行结果是什么？请解释原因

   ```js
   var t = true;
   
   window.setTimeout(function (){
      t = false;
   },1000);
   while (t){}
   alert('end');
   ```

   > 陷入死循环，因为 while 循环的条件 while (t){} 中的 t 始终为 true 。在JavaScript中， setTimeout 函数是异步的，它会在指定的时间后将回调函数添加到事件队列中。而 while 循环会一直执行，不会给事件队列处理的机会，因此 setTimeout 的回调函数无法执行，导致 t 的值无法被修改为 false ，从而造成了死循环。

5. 我们会在很多代码里看到如下语句，请说明在什么场景下需要使用如下形式代码

   ```js
   setTimeout(function(){
     // balala
     // 这里有很多代码
     // balala
   },0)
   ```

   > 在很多代码中使用  `setTimeout`  函数并将延迟设置为 0 的场景是为了将一段代码放入事件队列中，并在当前任务完成后立即执行。尽管延迟设置为 0，但这个回调函数仍然被视为异步任务。   这种用法通常在以下情况下使用：   1. 异步执行：当需要将一段代码推迟到当前任务完成后执行，而不是立即执行时，可以使用  `setTimeout`  函数将代码放入事件队列中。   2. 避免阻塞：当有大量计算密集型或耗时的操作时，将这些操作放在  `setTimeout`  的回调函数中可以避免阻塞主线程，使页面保持响应。   3. 事件顺序控制：在某些情况下，需要确保某个任务在当前任务完成后执行，但在其他事件处理程序之前执行。通过将代码放入  `setTimeout`  的回调函数中，并将延迟设置为 0，可以确保在事件队列中的适当位置执行。   需要注意的是，尽管延迟设置为 0，但回调函数仍然是异步执行的，它会在当前任务完成后尽快执行，但不会立即执行。这样可以确保其他异步任务和事件处理程序优先执行，避免阻塞主线程。



## 代码题

1. 请用 setTimeout 模拟实现 setInterval，并说明你实现的函数和系统自带的 setInterval 有什么不同

   ```javascript
    var start = new Date();
   function mySetInterval(fun, millisec) {
       setTimeout(function() {
           fun();
           mySetInterval(fun, millisec);
       }, millisec);
   }
   
   function time() {
       var end = new Date();
       console.log(end - start);
   }
   
   mySetInterval(time, 1000);
   
   ```
   
   ```javascript
   var start = new Date;
   setInterval(function(){
       var end = new Date;
       console.log(end - start);
   
   }, 1000);
   ```
   
   
   
   <img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012143605204.png" alt="image-20231012143605204" style="zoom:80%;" /><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012143717361.png" alt="image-20231012143717361" style="zoom:80%;" />

自己定义的函数误差总是延迟，而且误差很大，还会一直累积，而且自定义的函数返回的id一直会改变。系统的定时器函数误差小，出现误差后会一直修正误差，不会累积，id值是定值，方便清除定时器。