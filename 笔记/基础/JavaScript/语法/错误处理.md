# 错误处理

当 JavaScript 引擎执行 JavaScript 代码时，会发生各种错误：

可能是语法错误，通常是程序员造成的编码错误或错别字。

可能是拼写错误或语言中缺少的功能（可能由于浏览器差异）。

可能是由于来自服务器或用户的错误输出而导致的错误。

当然，也可能是由于许多其他不可预知的因素。

## JavaScript 抛出错误

当错误发生时，当事情出问题时，JavaScript 引擎通常会停止，并生成一个错误消息。

描述这种情况的技术术语是：JavaScript 将**抛出**一个错误。

## 测试和捕捉

`try` 语句允许我们定义在执行时进行错误测试的代码块。

`catch` 语句允许我们定义当 `try` 代码块发生错误时，所执行的代码块。

JavaScript 语句 `try` 和 `catch` 是成对出现的。

```javascript
try{
  // 可能出错需要捕获异常的代码
}catch(err){
  // 异常处理代码
}
```

比如，我们故意引用未定义的变量，使得 JavaScript 抛出异常：

```javascript
try{
  console.log(x) // x 未定义
}catch(err){
  console.log(err)
}
```

## throw 语句

错误除了可以使系统抛出的以外，还可以是我们自己定义的。（比如打分，只能在100内，超过了就出错）

throw 语句允许我们创建自定义错误。正确的技术术语是：抛出异常（exception）。

如果把 throw 与 try 和 catch 一起使用，那么您能够控制程序流，并生成自定义的错误消息。

```javascript
try{
  throw "a test err"
}catch(err){
  console.log(err)
}
```

可以看出，我们可以抛出任意类型的对象；`catch` 中接受的参数即为我们抛出的对象。

很多时候我们需要获得更多出错信息，比如系统给我们抛出的异常就有堆栈信息。

```javascript
try{
  console.log(x) // x 未定义
}catch(err){
  console.log(err)
}
```

自定义错误如何或者更多的出错信息那？这时候我们可以采用 `Error` 来构造对象。

```javascript
try{
  throw new Error("a error with more info")
}catch(err){
  console.log(err)
}
```

## Error 类型

执行代码期间可能会发生的错误有多种类型。每种错误都有对应的错误类型，而当错误发生时，就会抛出相应类型的错误对象。ECMA-262定义了下列7种错误类型：

- Error
- EvalError(eval错误)
- RangeError(范围错误)
- ReferenceError(引用错误)
- SyntaxError(语法错误)
- TypeError(类型错误)
- URIError(URI错误)

其中，Error是基类型，其他错误类型都继承自该类型。因此，所有错误类型共享了一组相同的属性。Error类型的错误很少见，如果有也是浏览器抛出的；这个基类型的主要目的是供开发人员抛出自定义错误

## finally 子句

　　ECMA-262第3版引入了try-catch语句，作为javascript中处理异常的一种标准方式，用于捕获和处理错误

　　其中，try从句定义了需要处理的异常所在的代码块。catch从句跟随在try从句之后，当try块内某处发生了异常时，调用catch内的代码逻辑。catch从句后跟随finally块，后者中放置清理代码，不管try块中是否产生异常，finally块内的逻辑总是会执行。尽管catch和finally都是可选的，但try从句需要至少二者之一与之组成完整的语句

　　try/catch/finally语句块都需要使用花括号括起来，这里的花括号是必需的，即使从句中只有一条语句也不能省略花括号

```javascript
try{
    //通常来讲，这里的代码会从头到尾而不会产生任何问题
    //但有时会抛出一个异常，要么是由throw语句直接抛出，要么通过调用一个方法间接抛出
}catch(e){
    //当且仅当try语句块抛出了异常，才会执行这里的代码
    //这里可以通过局部变量e来获得对Error对象或者抛出的其他值的引用
    //这里的代码块可以基于某种原因处理这个异常，也可以忽略这个异常，还可以通过throw语句重新抛出异常
}finally{
    //不管try语句是否抛出了异常，finally里的逻辑总是会执行，终止try语句块的方式有：
    //1、正常终止，执行完语句块的最后一条语句
    //2、通过break、continue或return语句终止
    //3、抛出一个异常，异常被catch从句捕获
    //4、抛出一个异常，异常未被捕获，继续向上传播
}
```



## 问答题

1. 什么是错误处理？为什么要错误处理？

   > 当JavaScript引擎执行JavaScript代码时，会发生各种错误。当发生错误时，js引擎通常会停止，无法正常运行，处理这些错误以使程序正确运行就成为错误处理。
   >
   > 为了代码正常运行，需要错误处理。

2. 常见的错误有哪些？

   > 可能是语法错误、可能是拼写错误、也可能是服务器或用户输出而导致的错误。

3. 能用 `if` 语句替代错误处理吗？如果能，请给出实例代码，如果不能，请说明原因（开放题）

   > 不能,因为if得条件语句是来判断条件语句的布尔值是否为真，有些逻辑错误，语法错误代码放入条件语句中其布尔值可能为true，不能识别到代码的错误，如下，对于未声明的b，a=b为错误，但是if语句并没有判断出来。
   >
   > ```javascript
   > if(a=b){
   >  console.log(true)
   > }
   > ```
   >
   > 除此之外，if语句不能和throw语句一样出错后能使前面的语句不执行：
   >
   > ```javascript
   > function test1(){
   >         test2()
   >         console.log(1)
   >     }
   >     function test2(){
   >         test3()
   >         console.log(2)
   >     }
   >     function test3(){
   >         throw new Error("sdafdsa")
   >     }
   > 
   >     test1()
   > ```
   >
   > 
   
4. 如何抛出一个错误?

   > ```javascript
   > try{
   >   throw new Error("a error with more info")
   > }catch(err){
   >   console.log(err)
   > }
   > ```

5. 以下代码可以捕获异常吗？为什么？

   ```javascript
   function a(){
    throw new Error("An error")
   }
   function b(){
    a();
   }
   try{
    b()
   }catch(err){
    console.log(err)
   }
   ```

   > 是的，这段代码可以捕获异常。原因如下：
   >
   > 在JavaScript中，`try...catch`语句被用来处理程序中可能发生的错误。在`try`块中的代码将被执行，如果发生任何错误或异常，那么这个错误或异常将被`catch`块捕获并处理。
   >
   > 代码中，`try`块调用了`b()`函数，而`b()`函数中又调用了`a()`函数。`a()`函数中抛出了一个错误，即`throw new Error("An error")`。当`a()`函数抛出错误时，这个错误将被`try...catch`语句捕获，然后`catch`块将这个错误对象赋值给变量`err`，并打印出来，即`console.log(err)`。
   >
   > 因此，这段代码可以成功地捕获并处理异常。

6. `finally` 子句有什么用？

   > catch从句后跟随finally块，不管try块中是否产生异常，finally块内的逻辑总是会执行。终止try语句块。无论是否有return语句在try和catch中，**如果从finally块中返回一个值，那么这个值将会成为整个try-catch-finally的返回值**。

7. JavaScript 中 `throw` 可以抛出非 `Error` 类型的异常吗？请动手试试

   > 可以
   >
   > ```javascript
   > try {
   >   throw 42; // 抛出一个数字
   > } catch (e) {
   >   console.log(e); // 输出: 42
   > }
   > 
   > ```

8. `try catch` 语句可以嵌套吗？ 如何嵌套？

   > `try-catch`语句可以嵌套。
   >
   > ```javascript
   > try {
   >     try {
   >         throw new Error("An error")
   >     } catch(e){
   >         console.log(e)
   >     }
   >     throw new Error("An error")
   > } catch(e){
   >     console.log(e)
   > }
   > ```
   >
   > 

## 代码题

1. 请构造一段会产生异常的代码（注意：不是一定会产生，是有一定概率产生异常），然后使用异常处理机制处理它

   ```javascript
   try {
       var a=[1,2,3]
       console.log(a[5])
   } catch(err){
       console.log(err)
   }
   ```

   

2. 以下代码能不能正常捕获异常，如果不能请**分析原因**并**修改**代码使其可以正常捕获异常

   ```javascript
   function asyncTask(){
    setTimeout(function(){
      throw new Error("An error")
    },1000)
   }
   try{
    asyncTask()
   } catch(err){
    console.log(err)
   }
   ```

​	不能，报出的为 Uncaught Error: An error。

setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。

设置延迟setTimeout() 实际上是使得**函数异步处理脱离了当前事件**。（try/catch语句不能捕获异步的异常。）因为js为单线程，所以**会将当前同步的任务执行完毕后，再执行setTimeout队列异步处理之后的任务**

因此函数执行时，**会优先执行catch(err)，**将 throw new Error(“An error”)这个过程放到之后再处理。因此异常无法被catch块捕获。

**第一遍执行时没有抛出错误，之后执行才抛出错误，而错误捕获是在第一步就执行完毕了，因此不会捕获第一步之后执行时抛出的错误。**

解决方法：由于只要有setTimeout()，都会产生异步执行情况。（即使setTimeout()延时0毫秒也一样会跳出） 因此取消异步执行就可以。要么就将异常抛出改为同步的，如：

```javascript
      function asyncTask(){
            throw new Error("An error"）
    }
    try{
        asyncTask()
     } catch(err){
        console.log(err)
      }
```

这样就可以捕获该同步异常

要么就使用async/await，promise来解决异步异常，如：

```javascript
      function asyncTask() {
        return new Promise((resole, reject) => {
            setTimeout(() => {
                reject(new Error("An error"))
            }, 1000)
        })
    }
    async function main() {
        try {
            await asyncTask()
        } catch (e) {
            console.log(e);
        }
    }
    main()
```

这样使用异步处理，来捕获该异常

也可以这样：

```javascript
function asyncTask(){
 setTimeout(function(){
    try{
   throw new Error("An error")}catch(err){
   console.log(err)
}
 },1000)
}
```

```javascript
function asyncTask(){
    function myFunction(){
        throw new Error("An error")
    }
    setTimeout(myFunction(),1000)
}
try{
    asyncTask()
} catch(err){
    console.log(err)
}
```

