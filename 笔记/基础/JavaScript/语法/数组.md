# 数组

数组对象的作用是：使用单独的变量名来存储一系列的值。

如果你有一组数据（例如：车名字），存在单独变量如下所示：

```javascript
var car1="Saab";
var car2="Volvo";
var car3="BMW";
```

如果你想从中找出某一辆车？并且不是3辆，而是300辆呢？这将不是一件容易的事！

最好的方法就是用数组。 数组可以用一个变量名存储所有的值，并且可以用变量名访问任何一个值。 数组中的每个元素都有自己的的ID，以便它可以很容易地被访问到。

在程序语言中数组的重要性不言而喻，由于弱类型的原因，JavaScript中数组十分灵活、强大。

不像是Java等强类型高级语言数组只能存放同一类型或其子类型元素，JavaScript在同一个数组中可以存放多种类型的元素，而且长度也是可以动态调整的，可以随着数据增加或减少自动对数组长度做更改。

## 创建数组

创建一个数组，有三种方法。

下面的代码定义了一个名为 myCars 的数组对象：

### 构造函数

#### 常规方式

```javascript
var myCars=new Array(); 
myCars[0]="Saab";       
myCars[1]="Volvo";
myCars[2]="BMW";
```

#### 简介模式

```javascript
var myCars=new Array("Saab","Volvo","BMW");
```

### 字面量

```javascript
var myCars=["Saab","Volvo","BMW"];
```

### 注意点

1.在使用构造函数创建数组时如果*传入一个**数字**参数，则会创建一个长度为参数的数组*，如果*传入多个，则创建一个数组，参数作为初始化数据加到数组中*

```javascript
var a1 = new Array(2);
   console.log(a1.length);// 2
   console.log(a1); // [empty × 2]

   var a2 = new Array(5,6);
   console.log(a2.length);// 2
   console.log(a2); // [5,6]
```

但是使用字面量方式，无论传入几个参数，都会把参数当作初始化内容

```javascript
var a1 = [2];
console.log(a1.length);// 1
console.log(a1); // [2]

var a2 = [5,6];
console.log(a2.length);// 2
console.log(a2); // [5,6]
```

## 访问数组

数组的值可以通过自然数索引访问进行读写操作，下标也可以是一个得出非负整数的变量或表达式

```javascript
var a1 = ["a","b","c","d"];
console.log(a1[0]); // "a"
var i = 1;
console.log(a1[i]); // "b"
console.log(a1[++i]); // "c" a1[i++]="b" a1[++i]="c"
```

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20230926175205121.png" alt="image-20230926175205121" style="zoom:80%;" />

数组也是对象，数组会把索引值转换为对应字符串（1=>”1”）作为对象属性名，所以我们可以通过取对象的值的方法取出数组中的元素

```javascript
console.log(a1["1"]);// "b"
```

索引特殊性在于数组会自动更新length属性，当然因为JavaScript语法规定数字不能作为变量名，所以我们不能显式使用`array.1`这样的格式。由此可见其实负数，甚至非数字”索引“都是允许的，只不过这些会变成数组的属性，而不是索引

```javascript
var a = new Array(1,2,3);
a[-10]="a[-10]";
a["sss"]="sss";//数组中的实际元素个数超过了length
```

数组的索引可以不是连续的，访问index不存在的元素的时候返回`undefined`

```javascript
var a = new Array(1,2,3);
a[100] = 100;
console.log(a.length); //101
console.log(a[3]); //undefined
console.log(a[99]); //undefined
console.log(a[100]); 100
```

上面的例子中，虽然直接对`a[100]`赋值不会影响`a[4]`或`a[99]`,但数组的长度却受到影响，数组`length`属性等于数组中最大的`index+1`，我们知道数组的length属性同样是个可写的属性，当强制把数组的length属性值设置为小于等于最大index值时，数组会自动删除indexd大于等于length的数据，在刚才代码中追加几句

```javascript
a.length = 2
console.log(a);//[1,2]
```

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20230926181106443.png" alt="image-20230926181106443" style="zoom:80%;" />

## 查找数组

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231025194303014.png" alt="image-20231025194303014" style="zoom:80%;" />

### **1、Array.prototype.includes()**

includes() 方法用来判断一个数组是否包含一个指定的值，如果包含则返回 true，否则返回 false。

该方法支持两个参数valueToFind，fromIndex（可选），第一个参数是‘需要查找的元素值’,第二个参数是‘从哪个索引处开始查找’，第二个参数如果为负数，则会按升序从 array.length + fromIndex 的索引开始查找（即使从末尾开始往前跳 fromIndex 的绝对值个索引，然后往后搜寻）。

```
var a = [1,2,3,4,5,6]
a.includes(2)  // true
a.includes(2,3)  // false
a.includes(5,-2)  // true
a.includes(5,-1)  // false
```

### **2、 Array.prototype.indexOf()**

indexOf() 方法返回指定元素在数组中的第一个索引，如果不存在，则返回-1。

该方法支持两个参数searchElement，fromIndex （可选），第一个参数是‘要查找的元素’，第二个参数是‘开始查找的索引位置’，如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。

如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找 ，以此类推。

注意：如果参数中提供的索引值是一个负值，并不改变其查找顺序，查找顺序仍然是从前向后查询数组。如果抵消后的索引值仍小于0，则整个数组都将会被查询。其默认值为0。

```
var array = [2, 5, 9];
array.indexOf(2);     // 0
array.indexOf(7);     // -1
array.indexOf(9, 2);  // 2
array.indexOf(2, -1); // 1
array.indexOf(2, -3); // 0
```

### **3、Array.prototype.lastIndexOf()**

lastIndexOf() 方法返回指定元素在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。

该方法支持两个参数 searchElement，fromIndex（可选），第一个参数是‘被查找的元素’。第二个参数是‘从此位置开始逆向查找’，默认为数组的长度减 1(arr.length - 1)，即整个数组都被查找。

如果该值大于或等于数组的长度，则整个数组会被查找。

如果为负值，将其视为从数组末尾向前的偏移。即使该值为负，数组仍然会被从后向前查找。

如果该值为负时，其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。

```
var array = [2, 5, 9, 2];
array.lastIndexOf(2);      // 3
array.lastIndexOf(7);      // -1
array.lastIndexOf(2, 3);   // 3
array.lastIndexOf(2, 2);   // 0
array.lastIndexOf(2, -2);  // 0
array.lastIndexOf(2, -1);  // 3
```

### **4、Array.prototype.some()**

some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个 Boolean 类型的值。

> 语法 ：arr.some(callback(element[, index[, array]])[, thisArg])

「参数」：

callback：用来测试每个元素的函数，接受三个参数：

- element 数组中正在处理的元素。
- index 可选，数组中正在处理的元素的索引值。
- array 可选，被遍历的数组本身。

thisArg：可选，执行 callback 时使用的 this 值。

下面的例子检测在数组中是否有元素大于 10。

```

function isBiggerThan10(element, index, array) {
  return element > 10
}
[2, 5, 8, 1, 4].some(isBiggerThan10);  // false
[12, 5, 8, 1, 4].some(isBiggerThan10); // true
```

还可以使用[箭头函数](https://so.csdn.net/so/search?q=箭头函数&spm=1001.2101.3001.7020)实现相同的效果。

```
[2, 5, 8, 1, 4].some(x => x > 10);  // false
[12, 5, 8, 1, 4].some(x => x > 10); // true
```

### **5、 Array.prototype.every()**

every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。

> 该方法的参数与 Array.prototype.some() 方法一样，这里就不再介绍了。它们两不同的是，some()只要数组中有一个元素满足条件就为真，every()要全部满足条件才为真。

检测数组中的所有元素是否都大于 10。

```
function isBigEnough(element, index, array) {
  return element >= 10;
}
[12, 5, 8, 130, 44].every(isBigEnough);   // false
[12, 54, 18, 130, 44].every(isBigEnough); // true
```

### **6、Array.prototype.filter()**

filter() 方法创建一个新数组, 包含通过所提供函数实现的测试的所有元素。

该方法的参数与 some(),every()相同，callback 用来测试数组的每个元素的函数。返回 true 表示该元素通过测试，保留该元素，false 则不保留。

下例使用 filter 创建了一个新数组，该数组的元素由原数组中值大于 10 的元素组成。

```

function isBigEnough(element) {
  return element >= 10;
}
var filtered = [12, 5, 8, 130, 35].filter(isBigEnough);
// filtered is [12, 130, 35]
```

### **7、Array.prototype.find()**

find() 方法返回数组中满足提供的[测试函数](https://so.csdn.net/so/search?q=测试函数&spm=1001.2101.3001.7020)的第一个元素的值。否则返回 undefined。

> 该方法的参数与 some(),every(),filter()相同。

用对象的属性查找数组里的对象。

```

var inventory = [
    {name: 'apples', quantity: 2},
    {name: 'bananas', quantity: 0},
    {name: 'orange', quantity: 5}
];
function findOranges(fruit) { 
    return fruit.name === 'orange';
}
console.log(inventory.find(findOrange);

// { name: 'orange', quantity: 5 }
```

### **8、Array.prototype.findIndex()**

[findIndex](https://so.csdn.net/so/search?q=findIndex&spm=1001.2101.3001.7020)() 方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。

> 该方法参数与 find() 相同，只是一个返回该元素，一个返回该元素在数组中的索引值。

查找 name 为 orange 的对象在数组中的的索引。

```

var inventory = [
    {name: 'apple', quantity: 2},
    {name: 'banana', quantity: 0},
    {name: 'orange', quantity: 5}
];
function findOrange(fruit) { 
    return fruit.name === 'orange';

}

console.log(inventory.findIndex(findOrange));

// { name: 'orange', quantity: 5 }
```



## Array 对象方法

### concat()

连接两个或更多的数组，并返回结果

concat() 方法用于连接两个或多个数组。

该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。

```javascript
var arr = new Array(3)
arr[0] = "George"
arr[1] = "John"
arr[2] = "Thomas"

var arr2 = new Array(3)
arr2[0] = "James"
arr2[1] = "Adrew"
arr2[2] = "Martin"

console.log(arr.concat(arr2)) // George,John,Thomas,James,Adrew,Martin
```

### join()

join() 方法用于把数组中的所有元素放入一个字符串。

元素是通过指定的分隔符进行分隔的。

```javascript
var arr = new Array(3)
arr[0] = "George"
arr[1] = "John"
arr[2] = "Thomas"
console.log(arr.join(".")) // George.John.Thomas
```

## 元素添加/删除

### 栈方法

`pop`和`push`能够让我们使用堆栈那样先入后出使用数组

pop() 方法用于删除并返回数组的最后一个元素。

pop() 方法将删除 arrayObject 的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。

push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。

push() 方法可把它的参数顺序添加到 arrayObject 的尾部。它直接修改 arrayObject，而不是创建一个新的数组。push() 方法和 pop() 方法使用数组提供的先进后出栈的功能。

```javascript
var a = new Array(1,2,3);
a.push(4);
console.log(a);// [1, 2, 3, 4]
console.log(a.length);// 4
console.log(a.pop());// 4
console.log(a); // [1, 2, 3]
console.log(a.length);// 3
```

### 队列方法

既然栈方法都实现了，先入先出的队列怎么能少，`shift`方法可以删除数组index最小元素，并使后面元素index都减一，length也减一，这样使用shift/push就可以模拟队列了，当然与shift方法对应的有一个`unshift`方法，用于向数组头部添加一个元素

如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。请注意，该方法不创建新数组，而是直接修改原有的 arrayObject。

unshift() 方法将把它的参数插入 arrayObject 的头部，并将已经存在的元素顺次地移到较高的下标处，以便留出空间。该方法的第一个参数将成为数组的新元素 0，如果还有第二个参数，它将成为新的元素 1，以此类推。请注意，unshift() 方法不创建新的数组，而是直接修改原有的数组。

```javascript
var a=new Array(1,2,3);
a.unshift(4);
console.log(a);//[4, 1, 2, 3]
console.log(a.length);//4
console.log(a.shift());//4
console.log(a); //[1, 2, 3]
console.log(a.length);//3
```

### splice()[splaɪs]

修改数组的终极神器。

splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。

用法：

```javascript
arrayObject.splice(index,howmany,item1,.....,itemX)
```

| 参数              | 描述                                                         |
| :---------------- | :----------------------------------------------------------- |
| index             | 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 |
| howmany           | 必需。要删除的项目数量。如果设置为 0，则不会删除项目。       |
| item1, ..., itemX | 可选。向数组添加的新项目。                                   |

```javascript
var arr = [1,2,3,4,5];

arr.splice(2,1,"a","b") // arr = [1, 2, "a", "b", 4, 5]
```

### slice(start,end)

不要和splice方法混淆，slice方法用于返回数组中一个片段或子数组，如果只写一个参数返回参数到数组结束部分，如果参数出现负数，则从数组尾部计数（-3意思是数组倒第三个，一般人不会这么干，但是在不知道数组长度，想舍弃后n个的时候有些用，不过数组长度很好知道。。。。，好纠结的用法），**如果start大于end返回空数组**，值得注意的一点是slice不会改变原数组，而是**返回一个新的数组**

```
var a = new Array(1,2,3,4,5);
console.log(a); //[1, 2, 3, 4, 5]
console.log(a.slice(1,2));//2
console.log(a.slice(1,-1));//[2, 3, 4]
console.log(a.slice(3,2));//[]
console.log(a); //[1, 2, 3, 4, 5]
```

### reverse()

reverse() 方法用于颠倒数组中元素的顺序。该方法会改变原来的数组，而不会创建新的数组。

```javascript
var arr = new Array(3)
arr[0] = "George"
arr[1] = "John"
arr[2] = "Thomas"
console.log(arr.reverse()) // [Thomas,John,George]
```

### sort()

sort() 方法用于对数组的元素进行排序。

```javascript
arrayObject.sort(sortby)
```

如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。

如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：

- 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。
- 若 a 等于 b，则返回 0。
- 若 a 大于 b，则返回一个大于 0 的值。

注意，默认情况下会调用对象的`toString()`方法，将对象转换为 string 后做比较：

```javascript
var a=new Array(5,4,3,2,1);
a.sort();
console.log(a);//[1, 2, 3, 4, 5]
```

但是

```javascript
var a=new Array(7,8,9,10,11);
a.sort();
console.log(a);//[10, 11, 7, 8, 9]
```

我们该如何解决这个问题那？



## 问答题

1. 如何声明/创建数组？

   > ```script
   > var myArray=new Array();
   > myArray[0]="first";
   > myArray[1]="second";
   > myArray[2]="third";
   > ```
   >
   > ```script
   > var myArray=new Array("first","second","third")
   > ```
   >
   > ```script
   > var myArray =("first","second","third")
   > ```
   >
   > 

2. 数组可以像对象一样插入属性吗？插入的属性会影响数组的 `length` 吗？如 `a["sss"]="sss"`

   > 可以
   >
   > 不影响，这些负数或者字符串等非数字”索引“，用来”索引“数组元素，但是这些只会变成数组元素的属性，而不是索引，不会影响数组的length。如下图：
   >
   > ![image-20230926180013450](C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20230926180013450.png)

3. 如果访问数组中不存在的元素，会怎么样?

   > 返回undefined

4. `join()`函数返回值是什么？它可以完成什么到什么的转换？

   > `join()`函数返回值是字符串，join() 方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。它可以完成数组到字符串的转换。
   >
   > string.split(),将字符串转化成数组，Array.join()将数组转化成字符串

5. 什么是栈？如何使用数组模拟栈？

   > 栈是一个先入后出的有序列表。栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。
   >
   > `pop`和`push`能够让我们使用堆栈那样先入后出使用数组

6. 什么是队列？如何使用数组模拟队列？

   > **队列是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，和栈一样，队列是一种操作受限制的线性表。**进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。**队列的数据元素又称为队列元素。**在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出线性表。 
   >
   > `shift`方法可以删除数组index最小元素，并使后面元素index都减一，length也减一，这样使用shift/push就可以模拟队列了，当然与shift方法对应的有一个`unshift`方法，用于向数组头部添加一个元素

7. 为什么说 `splice()` 函数是数组修改的神器？它有哪些参数？各是什么含义？

   > splice() 方法向从数组中添加/删除项目，然后返回被删除的项目。
   >
   > ```script
   > arrayObject.splice(index,howmany,item1,.....,itemX)
   > ```
   >
   > | 参数              | 描述                                                         |
   > | :---------------- | :----------------------------------------------------------- |
   > | index             | 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 |
   > | howmany           | 必需。要删除的项目数量。如果设置为 0，则不会删除项目。       |
   > | item1, ..., itemX | 可选。向数组添加的新项目。                                   |
   >
   > 

## 代码题

1. 请解释如下代码输出为什么结果不对，并请修改代码实现返回正确的结果。

   ```javascript
   var a=new Array(7,8,9,10,11);
   a.sort();
   console.log(a);// 输出 [10, 11, 7, 8, 9] 
   ```

因为是先把内容转化为string，按照字母表排序，10，11，前面的1比7小，所以排在了前面，这时候我们需要传入自定义排序函数

```
var a=new Array(7,8,9,10,11);
           a.sort(function(a,b){
            return a-b;
           });
       console.log(a);//[7, 8, 9, 10, 11]
```