# 原型链

JavaScript 不是传统的类继承模型，而是使用 prototype 原型模型。

其实基于原型的继承模型比传统的类继承还要强大。实现传统的类继承模型是很简单，但是实现 JavaScript 中的原型继承则要困难的多。

由于 JavaScript 是唯一一个被广泛使用的基于原型继承的语言，所以理解两种继承模式的差异是需要一定时间的，今天我们就来了解一下原型和原型链。

## `__proto__`属性

理解原型链前，我们首先需要理解`__proto__`属性。

```javascript
var obj={};
console.log(obj);
obj.__proto__.a=10;
console.log(obj.a);   // 10
```

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012150150438.png" alt="image-20231012150150438" style="zoom:80%;" />



<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012150854023.png" alt="image-20231012150854023" style="zoom:80%;" />



<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012150347418.png" alt="image-20231012150347418" style="zoom:80%;" />



<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012150629716.png" alt="image-20231012150629716" style="zoom:80%;" />

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012160545279.png" alt="image-20231012160545279" style="zoom:80%;" />

如上代码中，我们并没有给obj.a，但是`console.log(obj.a)`却能打印出`10`。

为了解释这个现象，需要引入js查找对象属性查找的机制，我们把上面的代码稍作修改

```javascript
var obj={b:2};
console.log(obj);
obj.__proto__.a=1;
console.log(obj.a);                      // 1
console.log(obj.b);                      // 2
console.log(obj.hasOwnProperty("a"))     // false
console.log(obj.hasOwnProperty("b"))     // true
for(var i in obj) {
    console.log(i);                      // a,b
}
obj.a=3;
console.log(obj.a)                       // 3
console.log(obj.__proto__.a)             // 1
console.log(obj.__proto__.null)             // 1
```

**js属性查找首先查找自身属性，如果没有，是顺着`__proto__`不断向上查找，直到查找到`null`为止**

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012160912935.png" alt="image-20231012160912935" style="zoom:80%;" />

下面是实现的仿真代码

```javascript
findProperty(obj,property){
    if(obj.hasOwnProperty(property)){
        return obj[property];
    }
    var __proto__ = obj.__proto__;
    while(__proto__){
        if(__proto__.hasOwnProperty(property)){
            return __proto__[property]
        }
        __proto__ = __proto__.__proto__;
    }
    return undefined
}
```

### `prototype`属性

我们可以通过`prototype`实现，定义对象的成员函数。

```javascript
function Book(name,writer,price){
    this.name=name;//实例化的对象的name属性赋值给book类的name
    this.writer=writer;
    this.price=price;
}//函数名小写，类名大写

// 设置 Book 的 prototype 属性
Book.prototype.getRMB = function(){
    return this.price+"元";
}


var book = new Book("book1","Tom","59.9")
var book2 =  new Book("book2","jack","29.9")

// 调用成员方法
book.getRMB()

console.log(book.getRMB == book2.getRMB) // true， 所有对象共用共享同一个 getRMB
```

如上代码之所以能成功运行，源于js在`new`做了一些魔法

我们还是以上面的Book类为例，展示`new`不为人知的一些事

```javascript
//构造函数：
function Book(name,writer,price){
    this.name=name;
    this.writer=writer;
    this.price=price;
    return this // 不return和return this 在使用 new 的时候行为一致
}
// 设置 Book 的 prototype 属性
Book.prototype.getRMB = function(){
    return this.price+"元";
}

// var book = new Book("book1","Tom","59.9") 干的事

var book = Book.call(
    {},        // 新建一个对象
    "book1",   // 传入参数
    "Tom",
    "59.9"
    )//call最常见的用途是改变函数体内的this指向，指向了新建的对象，而新建的对象赋值给了book，即将this指向了book在这个例子中。call创建了一个新的空对象{}并将其作为this上下文传递给Book构造函数。然后，它传递了三个参数  "book1" ,  "Tom" ,  "59.9"  给构造函数，这些参数分别用于设置this.name,this.writer,this.price属性。最后Book.call返回了这个新创建的对象  book 。 
 //所以， Book.call({}, "book1", "Tom", "59.9")的作用是创建了一个新的Book对象，并设置了其属性值为"book1","Tom","59.9" ，且改变this指向。

// 最关键一步,改变__proto__指向
book.__proto__ = Book.prototype;
```

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231023202511976.png" alt="image-20231023202511976" style="zoom:80%;" />

由于`__proto__`指向改变，当我们调用`getRMB`的时候，会向上查找到`__proto__.getRMB`完成调用。

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012163920470.png" alt="image-20231012163920470" style="zoom:80%;" />

### 原型链实现继承

```javascript
function Goods(name){
    this.name=name;
}//构造函数
Goods.prototype.getName = function(){
    return "商品名字："+this.name;
}

Goods.prototype.getRMB = function(){
    return "商品价格："+this.price+"元";
}

function Book(name,writer,price){
    // 调用父类构造函数
    Goods.call(this,name);  
    this.name=name;
    this.writer=writer;
    this.price=price;
}
// 实现继承
Book.prototype.__proto__ = Goods.prototype

// 或者不想操作 __proto__ 属性，使用ES5的 Object.create
// Book.prototype = Object.create(Goods.prototype)
//Object.create,等价于上面的Book.prototype.__proto__ = Goods.prototype，但是系统不希望我们访问到__proto__等隐藏属性，所以建议使用包装好了的Object.create。

// 或者这样也行
// Book.prototype = new Goods()
// 思考这样做的不完美地方
// 1. 对于相同的属性有多份拷贝，浪费内存。会将goods（）中的参数name代入prototype中，造成冗余浪费内存。
// 2. 无法给Goods传参数，因为参数只有在调用时才知道
// 3. 调用2次Goods的构造函数，影响效率。

// 设置 Book 的 prototype 属性
Book.prototype.getRMB = function(){
    return "图书价格："+this.price+"元";
}

var book = new Book("book1","Tom","59.9");
console.log(book.getName())                       // 商品名字：book1
console.log(book.getRMB())                        // 图书价格：59.9元
```

思考为什么 `book.getRMB()`调用的是`Book`的方法，而非`Goods`的方法？（继承覆写）

因为js属性查找首先查找自身属性，如果没有，是顺着`__proto__`向上查找，`book.__porto__`等于`Book.prototype`,`Book.prototype`有getRMB()属性，就被book调用

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012174657700.png" alt="image-20231012174657700" style="zoom:80%;" />



<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012201332863.png" alt="image-20231012201332863" style="zoom:80%;" />

这两种实现继承的方式都有一些不完美的地方。   

1. `Book.prototype.__proto__ = Goods.prototype` ：这种方式直接将  `Book.prototype`  的原型对象设置为  `Goods.prototype` ，这意味着  `Book`  和  `Goods`  的原型对象共享同一个对象。这样做的问题是，如果修改了  `Book.prototype`  的属性或方法，也会影响到  `Goods.prototype` ，可能会导致意外的行为。  
2.  `Book.prototype = new Goods()` ：这种方式通过创建一个  `Goods`  的实例，并将其设置为  `Book.prototype` ，从而继承了  `Goods`  的属性和方法。然而，这种方式存在一个问题，即在创建  `Book`  的实例时，会调用  `Goods`  的构造函数。这可能会导致不必要的副作用和意外行为，特别是如果  `Goods`  的构造函数有副作用或需要传递参数时。  
3.  为了解决这些问题，可以使用更好的继承方式，比如使用  `Object.create()`  或者使用现代的类和继承语法（ES6+）。这些方式更直观、灵活，并且避免了上述问题。下面是使用  `Object.create()`  的示例：

```javascript
Book.prototype = Object.create(Goods.prototype);
Book.prototype.constructor = Book;
```

这样做可以创建一个新的对象作为  `Book.prototype`  的原型，并确保  `Book.prototype.constructor`  指向正确的构造函数。这种方式更安全、可靠，并且更符合面向对象编程的原则。





#### JavaScript的Object.create()方法

ES5定义了一个名为Object.create()的方法，它创建一个对象，其中第一个参数就是这个对象的原型，Object.create()提供第二个可选参数，用以对对象的属性进行进一步描述。

```javascript
// Object.create()是一个静态方法
// 以下展示不同参数的用法

// 一个参数
var o = Object.create(null) // 相当于空对象，任何属性都没有
var o = Object.create(Object.prototype) // 相当于var o = {}
var o = Object.create({x: 1, y: 2}) // 相当于var o = {}; o.prototype = {x: 1, y: 2}

// 第二个参数是一个对象，用于给创建的对象添加属性和属性描述的
// 属性又分为数据属性和存取器属性
// 数据属性的描述符对象的属性有value(值)、writable(可写性)、enumerable(可枚举性)、configurable(可配置性)
// 存取器属性的描述符对象的属性有get(读取)、set(写入)、enumerable(可枚举性)、configurable(可配置性)

// 两个参数
var o = Object.create({x: 1, y: 2}, {
   a: {
   		value: 100,
   		......
   }
}) // 向创建的对象o添加一个数据属性a，值为100，其它描述属性默认为false

var o = Object.create({x: 1, y: 2}, {
   a: {
   		get() {
   			return this.x + this.y
   		},
   		......
   	}
}) // 向创建的对象o添加一个存取器属性a，o.a时执行其get方法，set属性默认为undefined，其余描述属性默认为false

```

#### JavaScript手写Object.create函数

手写 Object.create 函数。Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的`__proto__`

代码：

```javascript
function create(parentPrototype, props) {
  function Fn() {
 
  }
  Fn.prototype = parentPrototype;
  let fn = new Fn();
  for (let key in props) {
    Object.defineProperty(fn, key, {
      enumerable: true, // 如果不枚举对象中无法查看到这个对象
      ...props[key]
    })
  }
  return fn
}
 
 
function Parent() {
  this.name = "parent";
}
 
Parent.prototype.eat = function () {
  console.log("eat");
};
 
function Child() {
  this.age = 9;
  Parent.call(this);
}
 
Child.prototype = create(Parent.prototype, { constructor: { value: Child } });
 
// { constructor: { value: Child } }  这段代码保证 Child 的 prototype 的 constructor 还指向 Child 的构造函数
 
let child = new Child();
console.log(child.constructor,'constructor'); // [Function: Child] 'constructor'
child.eat() // eat
```

### 语法

> ```javascript
> Object.create(proto, [ propertiesObject ]); 
> ```

### 参数介绍

> **proto**

> > 一个对象，作为新创建对象的原型。如果 proto 参数不是 null 或一个对象值，则抛出一个 TypeError 异常。null表示没有原型对象(这样就创建了一个"干净的对象")

> **propertiesObject**

> > 一个对象值，可以包含若干个属性，属性名为新建对象的属性名，属性值为那个属性的属性描述符对象.(属性将做简单介绍，后面将详细解答)

### 详细使用

#### 简单对象创建

> 继续上面的创建"干净"的对象，我们可以这么做:

> ```javascript
>  var clearObj = Object.create(null);
>    //Object with no prototype
> ```

> 现在我想创建一个银行账户对象，占时关注它是哪个银行的

> ```javascript
> var account = Object.create(Object.prototype,{
>    type: {
>        value: "建设银行"
>        //enumerable: false
>        //configurable: false
>        //writable: false
>    }
>    });
>    account.type; // "建设银行"
> ```
>
> #### writable属性使用

> 继续上面的例子，有好奇的同学可能已经发现了，上面的例子中，我们做一下操作:

> ```javascript
> account.type = "人民银行"; //"人民银行"
> account.type; // "建设银行"
> ```

> 将writable属性设置为true

> ```javascript
> account.type = "人民银行"; //"人民银行"
> account.type; // "人民银行"
> ```

#### configurable属性使用

> ```javascript
> delete account.type // false
> ```

> configurable属性的问题，将它设置为true

> ```javascript
> account.type; // "建设银行"
> delete account.type // true
> account.type; // undefined
> ```

#### enumerable属性值

> 现在我要遍历account对象

> ```javascript
> for(var i in account){
> console.log(account[i]);
> }
> // undefined
> ```

> enumerable属性值,如果enumerable属性设置为true

> ```javascript
> for(var i in account){
> console.log(account[i]);
> }
> // "建设银行"
> ```

#### get和set的用法

> 现在我需要我的account对象有另外一个属性：账户号码,我需要如果修改了给出特定格式，没有账户需要给出警告

> ```javascript
> var account = Object.create(Object.prototype,{
> type: {
>     value: "建设银行",
> 	enumerable: true,
> 	configurable: false, // 不能被删除
> 	writable: false // 不能被修改
>  },
> number: {
> 	 get: function(){
> 	if((typeof number) === "undefined"){
> 	//说明没有设置number
> 	return "您还没有开通账户!请联系前台!";
> }
> 	return "您的账户号码是："+number;
> },
> 
> set: function(num){
> 	 number = num;
> 	if(this.cTime === 0){
> 	console.log("账户开通成功！");
> 	this.cTime++;
> }else{
> 	console.log("账户号码已经被修改！");
> 	 }
> }
> },
> cTime: {
> 	value: 0,
>  	writable: true
> }
> });
> 
> account.type; // "建设银行"
> account.number; // "您还没有开通账户!请联系前台!"
> account.number = "610XXXXXXXXXX21";
> // "账户开通成功！"
> account.number; // "您的账户号码是：610XXXXXXXXXX21"
> account.number = "610XXXXXXXXXX88";
> // "账户号码已经被修改！"
> account.number; // "您的账户号码是：610XXXXXXXXXX88"
> ```

### 注意

> - 在使用set,get函数的时候，不能和value属性和writable属性一起用，会报错



## 完整的原型图

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012174300962.png" alt="image-20231012174300962" style="zoom:80%;" />

## 问答题

1. js中对象的属性查找机制是什么？请写出实现属性查找机制的伪代码

   > js属性查找首先查找自身属性，如果没有，是顺着`__proto__`不断向上查找，直到查找到`null`为止
   >
   > ```javascript
   > findProperty(obj,property){
   >     if(obj.hasOwnProperty(property)){
   >         return obj[property];
   >     }
   >     var __proto__ = obj.__proto__;
   >     while(__proto__){
   >         if(__proto__.hasOwnProperty(property)){
   >             return __proto__[property]
   >         }
   >         __proto__ = __proto__.__proto__;
   >     }
   >     return undefined
   > }
   > ```
   >
   > 

2. 自学ES5的 `Object.create()` 函数，然后用自己的代码重新实现

   > ```javascript
   > function createObject(parentPrototype,F) {
   >   F.prototype.__proto__ = parentPrototype;
   >   let fn = new F();
   >   return fn
   > }
   >  
   > function Parent() {
   >   this.name = "parent";
   > }
   > Parent.prototype.eat = function () {
   >   console.log("eat");
   > };
   >  
   > function Child() {
   >   this.age = 9;
   >   Parent.call(this);
   > } 
   > createObject(Parent.prototype,Child);
   > ```

3. 使用原型链实现继承，本质通过改变对象的什么，来实现继承？

   > 本质通过改变对象的`protorype.__proto__`的指向

4. 当我们使用`new`关键字，其背后干了哪些事？

   > ```javascript
   > // var book = new Book("book1","Tom","59.9") 干的事
   > 
   > var book = Book.call(
   >     {},        // 新建一个对象
   >     "book1",   // 传入参数
   >     "Tom",
   >     "59.9"
   >     )
   > // 最关键一步,改变__proto__指向
   > book.__proto__ = Book.prototype;
   > ```

5. 讲义中使用 `Book.prototype = new Goods()` 实现继承有什么不完美的地方？

   > 1. 属性有多份拷贝
   > 2. 无法给Goods传参数，因为参数只有在调用时才知道

6. 画出代码题1的原型图，需要画到`null`

   > <img src="C:\Users\86153\Documents\WeChat Files\wxid_kelrfb1wo3622\FileStorage\Temp\68d5c0ab74f7c36c8288b114079c504.png" alt="68d5c0ab74f7c36c8288b114079c504" style="zoom: 67%;" />

## 代码题

1. 假定我们的代码中需要4个类，分别是 `Animal`，`Dog`，`Cat`，`Human`。`Animal` 有方法 `eat`,`sleep`;`Dog`,`Cat`有方法`bark`；`Human`有方法`speak`；请使用js中的继承实现。

   ```javascript
   function Animal(eat,sleep){
       this.eat = eat;
       this.sleep = sleep;
   }
   Animal.prototype.eat = function(){
       return this.eatwhat;
   }
   Animal.prototype.sleep = function(){
       return this.whensleep;
   }
   
   function Dog(eat,sleep,bark){
       Animal.call(this,eat,sleep){
           this.eat = eat;
       	this.sleep = sleep;
           this.bark = bark;       
       }
       Dog.prototype = Object.create(Animal.prototype);
       Dog.prototype.constructor = Dog;
       Dog.prototype.bark = function(){
           return whybark;
       }
   }
   
   function Cat(eat,sleep,bark){
       Animal.call(this,eat,sleep){
           this.eat = eat;
       	this.sleep = sleep;
           this.bark = bark;       
       }
       Cat.prototype.__proto__ = Animal.prototype;
       Cat.prototype.bark = function(){
           return whybark;
       }
   }
   
   function Human(eat,sleep,speak){
       Animal.call(this,eat,sleep){
           this.eat = eat;
       	this.sleep = sleep;
           this.speak = speak;       
       }
       Human.prototype= Object.create(Animal.prototype);
       Human.prototype.constructor = Human;
       Human.prototype.speak = function(){
           return speaklanguage;
       }
   }
   ```
   
   

### 类和ES6+的继承语法
1、面向对象：是一种开发思想，一切皆为对象。对象是属性和行为的结合体

2、面向过程：也是一种开发思想。开发中的每个细节，开发者都要考虑到。

3、类：具有相同属性和行为的对象的集合

4、ES5中实现类的功能：构造函数，在构造函数中封装了属性和方法。缺陷是构造函数和普通函数的定义方式是一样的

5、ES6中类的定义方式：语义性更强、语法更简洁

     class 类名{
                 属性
                 行为
          }

 class 是关键字，专门用来定义类。

6、ES6中支持getter/setter来获取属性值、设置属性值

 （1）定义get方法、set方法的目的是：用于隐藏对象的属性名

 （2）在使用get方法、set方法方法时不用带’()’

二、类定义时注意的问题
1、类的属性和方法（函数）：类可以有属性也没有没有属性，可以有方法也可以没有方法

2、类的属性是放在构造方法中初始化的，若类没有属性，可以不显式定义构造方法，此时，系统会自动生成一个无参的空的构造方法

三、类的继承
1、基本的概念：
 （1）父类（基类）：可以派生子类的类

 （2）子类(派生类)：由父类派生而来的类

2、面向对象的三大特性
 （1）封装性：对象是属性和行为的封装体 —- 数据安全

 （2）继承性：子类可以继承父类的属性和方法 —- 代码复用

 （3）多态性：同一个消息传递给不同对象，出现的效果不同 —- 应用灵活、可以适应不同的需求

3、继承的实现
 （1）ES5中继承的实现：没有类的概念

         a、构造函数：构造函数名就是类名，在ES5中类的继承实际就是构造函数的继承
         b、实现：通过call、apply、bind函数来实现构造函数的继承

（2）ES6中的继承：通过关键字extends实现

```javascript
		//1.定义父类Fatcher
        class Fatcher{
            constructor(name,age){
                this.name = name
                this.age = age
            }
            fun(){
                console.log('我是父类中的方法......')
            }
        }
        //2.定义子类Son，继承自Father类
        class Son extends Fatcher{
            constructor(name,age){
                super(name,age); //调用父类的构造函数
            }
            hobby(){
                console.log('我喜欢篮球')
            }
            show(){
                console.log('姓名：',this.name)
                console.log('年龄：',this.age)
            }
        }
        let s1 = new Son('张三',25)
        s1.hobby()
        s1.show()
```

​        a、super：指向父类。super([参数])表示调用父类的构造函数

​		 b、如果在子类的构造函数中调用父类的构造函数，那么super()必须作为子类构造函数中的第一条语句在执行子类的构造函数之前必须先执行父类的构造函数(先有父，后有子)

​		c、方法覆盖(Overwrite)：在继承过程中，若父类的某个方法与子类的某个方法同名，则子类方法覆盖父类的同名方法

​		d、在子类的方法中可以使用super调用父类中的某个方法

​		e、不允许多继承，只能单继承

​			 多继承：类的直接父类有多个

​			单继承：类的直接父类只有一个父类