## 什么是域？

出于安全的考虑，浏览器**同源策略**会限制来自不同域名、协议、端口（不同的域）资源之间的访问，这个时候，我们就需要**跨域**访问其他不同域上服务器的资源。

下表展示了相对 http://bbs.mafengshe.com/a/b.html 同源检测的示例:

http https:协议名  

bbs.mafengshe.com：主机名，   

主机名后跟端口号，默认是80，不写的情况默认端口号80   

a/路径名  

b.html文件名

| URL                                  | 结果 | 原因     |
| ------------------------------------ | ---- | -------- |
| http://bbs.mafengshe.com/a/b/c.html  | 成功 | 相同域名 |
| http://bbs.mafengshe.com/b/c.html    | 成功 | 相同域名 |
| https://bbs.mafengshe.com/a/b.html   | 失败 | 不同协议 |
| http://bbs.mafengshe.com:90/a/b.html | 失败 | 不同端口 |
| http://work.mafengshe.com/a/b/c.html | 失败 | 不同域名 |

另外，如果是协议（http和https）或者端口的不同，前端js是无法实现跨域访问的，需要后台实现。

## 如何跨域？

想要跨域，首先要从同源策略下手，**突破同源策略的限制**。

### 使用document.domain更改源

我们可以通过document.domain设置当前域的值为**自身或者是当前域的父级**，设置成父域后，较短的域将用于后续的检查。

假设在 http://bbs.mafengshe.com/a/b.html 域下执行下面语句

```js
document.domain = 'mafengshe.com'
```

这样，页面就能通过对 http://mafengshe.com/a/other.html 的同源检测。不过，document.domain 无法把 mafengshe.com 设成 otherdomail.com。如下图，将domain=test.a.com设置成www.b.com失败，但是可以设置成a.com其中a.com是test.a.com的父域，（域名:后面的是父域，前面的是子域）

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231007214813126.png" alt="image-20231007214813126" style="zoom:80%;" />

浏览器单独保存端口号。任何的赋值操作，包括`document.domain = document.domain`都会以null值覆盖掉原来的端口号。因此`company.com:8080`页面的脚本不能仅通过设置`document.domain = "company.com"`就能与`company.com`通信(company.com:8080和company.com的端口号不一致）。必须在他们双方中都进行赋值，以确保端口号都为 null 。`document.domain` 属性用于获取或设置当前文档的域名。这个属性只接受域名，而不接受端口号。

注意：使用 document.domain 来允许子域安全访问其父域时，您需要在**父域和子域中都设置 document.domain 且为相同的值**。这是必要的，即使这样做只是将父域设置回其原始值。不这样做可能会导致权限错误。例如截图中的例子，截图页面网址为test.a.com,通过domain设置成了父域a.com，所以当前页面test.a.com可以访问,a.com下的文件（a.com/canvas)，但是被访问网页也需要设置domain为a.com,才可以是实现跨域成功。

### 使用document.name 存储信息

`window`对象有个`name`属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面（甚至不同域名）都是共享一个`window.name`的，每个页面对`window.name`都有读写的权限，`window.name`是持久存在一个窗口载入过的所有页面中的，所以我们可以通过window.name在不同iframe间传递信息，name可以存储2MB的信息。

### 通过JSONP实现跨域

>  JSON（JavaScript object notation）js对象简谱，<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231008130044838.png" alt="image-20231008130044838" style="zoom:80%;" />
>
> 示图中json将一个对象（包括数组）转成了字符串。JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。JSON采用简洁的文本形式表示结构化数据，可读性较高，易于理解和生成。它基于JavaScript语言的一个子集，但与具体编程语言无关，可以被多种编程语言解析和生成。这使得JSON成为跨平台和跨语言数据交换的理想选择。（cookie，跨域）。JSON的数据结构由键值对组成，键值对之间使用逗号分隔。键是字符串，值可以是字符串、数字、布尔值、数组、对象或null。对象由花括号{}包围，数组由方括号[]包围。
>
> JSON的优势在于其简洁性和易解析性。与XML相比，JSON的数据描述更加紧凑，使用的字符更少，易于传输和解析。同时，JSON的层级结构以及简单的键值对形式使得数据的组织和访问更加直观和便捷。
>
> JSON的应用范围非常广泛。它常用于Web开发中的前后端数据传输、API接口设计、配置文件、日志记录和存储、移动应用程序与服务器之间的数据交互等场景。许多编程语言都提供了内置的JSON处理库或函数，使得对JSON数据进行解析和生成变得简单和高效。
>
> 需要注意的是，JSON只是一种数据格式，不包含逻辑运算和动态行为。它的设计初衷是用来描述和交换数据，而不是用于程序控制或函数调用。
>
> 总之，JSON是一种轻量级的数据交换格式，具有简洁性、易读性和跨平台的特点。它在Web开发、数据交互和配置文件等领域得到广泛应用，并且成为编程语言间数据交换的标准格式之一。
>
> <img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231008131023443.png" alt="image-20231008131023443" style="zoom:80%;" />

JSONP(JSON with Padding)是[JSON](http://baike.baidu.com/item/JSON)的一种“使用模式”，而 HTML 的`<script>` 元素是一个例外。利用 `<script>` 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。

JSONP(JSON with Padding)是[JSON](http://baike.baidu.com/item/JSON)的一种“使用模式”，JSONP由回调函数和数据组成，该数据就是函数的参数。

因为同源策略的缘故，我们无法访问访问非同源的资源，但是HTML 的`<script>` 元素是一个例外。利用 `<script>` 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。

```js
/**原理如下：
*  通过script标签请求js
*  后台获取get的参数
*  后台返回带上参数的fetchData(data)
*  浏览器在script请求完成后，返回的函数会被执行，参数就传过来了
*  至此跨域通信完成
**/
function fetchData(res){
    console.log('The responsed data is: '+ res.data);
}
var script = document.createElement('script');
script.src = 'http://www.baidu.com/json/?callback=fetchData';
document.body.insertBefore(script, document.body.firstChild);
```

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231008163810360.png" alt="image-20231008163810360" style="zoom:80%;" />

#### JSONP的优缺点

JSONP的优点是：它不像`XMLHttpRequest`对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。

JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行`JavaScript`调用的问题。

**优点**：

- 不像`XMLHttpRequest`对象实现的Ajax请求那样受到同源策略的限制
- 兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持
- 数据调用获取简单

**缺点**：

- 只支持GET请求而不支持POST等其它类型的HTTP请求
- 它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行`JavaScript`调用的问题
- 安全性不能保证
- 调用失败的时候无法返回错误码

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231009185358902.png" alt="image-20231009185358902" style="zoom: 80%;" />

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231009185423340.png" alt="image-20231009185423340" style="zoom: 80%;" />

跨域访问：

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231007204527646.png" alt="image-20231007204527646" style="zoom:67%;" />

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231007204555281.png" alt="image-20231007204555281" style="zoom:67%;" />

其中iframe的网址为http://www.b.com:3000/canvas.html,若想从当前文件访问frame的dom元素，需要当前的网址也是和frame一致

### 跨域资源共享（CORS）

#### 什么是CORS？

CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。

它允许浏览器向跨源服务器，发出[`XMLHttpRequest`](http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html)请求，从而克服了AJAX只能[同源](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)使用的限制。

#### CORS实现跨域的原理

CORS背后的思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是成功还是失败

CORS跨域的实现需要前浏览器端和服务器端共同支持。后端服务器通过设置`Access-Control-Allow-Origin`(访问控制允许原点)的值为可被允许的源或者`*`（任意源）,当浏览器获取到该头字段信息，就会允许AJax跨域访问了。

对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。

因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。

后端必须设置响应头的值，否则Ajax跨域访问实现不了：

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231009184940503.png" alt="image-20231009184940503" style="zoom:80%;" />

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231009185004260.png" alt="image-20231009185004260" style="zoom:80%;" />

#### 非简单请求

首先先介绍简单请求这一概念；满足以下条件即为简单请求

- HTTP方法是下列之一

  ```
  HEAD
  GET
  POST
  ```

- 不能人为设置除下面以外的请求头：

  ```
  Accept
  Accept-Language
  Content-Language
  Content-Type （需要注意额外的限制）
  DPR
  Downlink
  Save-Data
  Viewport-Width
  Width
  ```

- 请求头中的Content-Type请求头的值是下列之一

  ```
  application/x-www-form-urlencoded
  multipart/form-data
  text/plain
  ```

不满足以上要求的请求，即为非简单请求。非简单请求是可能修改服务器资源的请求，比如请求方法是PATCH，PUT或DELETE； 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。"预检"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。

服务器收到"预检"请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。

服务器端需要返回注入下面的 response header：

```
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, POST, PUT, DELETE, PATCH 
Access-Control-Allow-Headers: X-Custom-Header
```

一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，进行跨域资源访问。

#### 与JSONP的比较

- JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求
- 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理
- JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS）

### 使用HTML5的window.postMessage方法跨域

`window.postMessage(message,targetOrigin)` 方法是`html5`新引进的特性，可以使用它来向其它的`window`对象发送消息，无论这个window对象是属于同源或不同源，目前`IE8+、FireFox、Chrome、Opera`等浏览器都已经支持`window.postMessage`方法。





## 问答题

1. 了解什么是域
   假设当前显示页面地址为 http://bbs.mafengshe.com/a/b.html
   1. http://bbs.mafengshe.com/a/b/c.html，成功
   2. http://bbs.mafengshe.com/a.html，成功，
   3. http://bbs.mafengshe.com/pic.png成功
   4. https://bbs.mafengshe.com/a/b.html失败,协议不同
   5. http://bbs.mafengshe.com:81/a/b.html失败，端口号不同
   6. http://work.mafengshe.com/a/b.html失败，域名不同
   7. http://mafengshe.com/a/b/c.html，失败，域名不同
   8. file:///a/b.html，失败，协议不同

2. 是什么原因造成直接跨域访问失败？

   > 浏览器**同源策略**会限制来自不同域名、协议、端口（不同的域）资源之间的访问

3. 跨域有哪几种方法？他们的原理各是什么？各有什么局限性？（如果有的话）
   需要回答四种跨域方法

   > 1. 使用document.domain更改源  :可以通过document.domain设置当前域的值为**自身或者是当前域的父级**假设在 http://bbs.mafengshe.com/a/b.html 域下执行下面语句```document.domain = 'mafengshe.com'```这样，页面就能通过对 http://mafengshe.com/a/other.html 的同源检测。不过，document.domain 无法把 mafengshe.com 设成 otherdomail.com。浏览器单独保存端口号。任何的赋值操作，包括`document.domain = document.domain`都会以null值覆盖掉原来的端口号。因此`company.com:8080`页面的脚本不能仅通过设置`document.domain = "company.com"`就能与`company.com`通信
   >
   > 2. 使用document.name 存储信息 ：`window`对象有个`name`属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面（甚至不同域名）都是共享一个`window.name`的，每个页面对`window.name`都有读写的权限，`window.name`是持久存在一个窗口载入过的所有页面中的，所以我们可以通过window.name在不同iframe间传递信息，name可以存储2MB的信息。
   >
   > 3. 通过JSONP实现跨域：因为同源策略的缘故，我们无法访问访问非同源的资源，但是HTML 的`<script>` 元素是一个例外。利用 `<script>` 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。通过script标签的src请求js，后台返回带上参数的callback(data)，浏览器在script请求完成后，返回的函数会被执行，参数就传过来了，至此跨域通信完成。![image-20231008152552406](C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231008152552406.png)
   >
   > 4. 跨域资源共享（CORS）:CORS背后的思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是成功还是失败。
   >
   >    CORS跨域的实现需要浏览器前端和服务器端共同支持。服务器通过设置`Access-Control-Allow-Origin`的值为可被允许的源或者`*`,当浏览器获取到该头字段信息，就会允许AJax跨域访问了。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。![image-20231008152736193](C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231008152736193.png)
   
4. 本地如何模拟跨域访问？
   请演示并截图

   > <img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231007204527646.png" alt="image-20231007204527646" style="zoom:67%;" />
   >
   > ![image-20231008153301575](C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231008153301575.png)
   >
   > <img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231007204555281.png" alt="image-20231007204555281" style="zoom:67%;" />
   >
   > 图一网页网址为http://www.a.com:3000/kuayu，二图是当前网页想要访问frame里面的dom元素，但是返回值报错，因为其中iframe的网址为http://www.b.com:3000/canvas,因为浏览器的同源策略，访问的域名不同，导致这种跨域访问不成功。
   >
   > 若想从当前网页访问frame的dom元素，需要当前的网址也是和frame一致，如图三，才可以成功，也可以采取其他方式跨域访问，降域jsonp或者cors。

## 代码题

1. 请使用 `降域` 实现 iframe 跨域

2. 请实现 JSONP 跨域，后端可采用静态服务器

   https://github.com/bunanan19/mfs-homework/blob/main/js-base/kuayu.html

# serve、express工具使用：

> npm serve是一个用于**启动本地开发服务器**的命令。它是Node Package Manager（NPM）的一部分，用于管理和安装JavaScript软件包。通过运行npm serve命令，可以在本地启动一个**静态服务器**，用于开发和测试网站或应用程序。通过对hosts里面对主机名的修改，形成映射关系，不仅可以通过localhost访问，还可以通过映射后的网址访问到主机服务器，hosts文件路径：C:\Windows\System32\drivers\etc

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231020173338250.png" alt="image-20231020173338250" style="zoom:80%;" />



> 使用express可以快速创建一个web服务器。npm express是一个流行的Node.js框架，用于构建Web应用程序和API。它提供了简单而强大的功能，包括路由、中间件、模板引擎等，使开发人员能够快速构建高效的服务器端应用程序。通过使用npm express，开发人员可以轻松处理HTTP请求和响应，构建灵活的路由和处理逻辑，并且可以方便地与其他npm模块集成。总的来说，npm express是一个优秀的工具，可用于快速构建可靠的Node.js服务器端应用程序。

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231020174303149.png" alt="image-20231020174303149" style="zoom:80%;" /><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231020174431701.png" alt="image-20231020174431701" style="zoom:80%;" />

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231021150108149.png" alt="image-20231021150108149" style="zoom:80%;" />



# GET和POST的区别

> **1.数据传输方式不同**
>
> GET方法的数据传输是通过URL传递的，而POST方法的数据传输是通过HTTP请求体传递的。在使用GET方法时，浏览器将请求的参数附加到URL的末尾，以“?”号开始，并用“&”符号将多个参数连接在一起。例如，以下是使用GET方法请求的示例：
>
> http://example.com/page?name=value&age=value
>
> 在使用POST方法时，浏览器将请求的数据打包并放置在HTTP请求体中。请求头中会包含请求体的大小等信息。以下是使用POST方法请求的示例：
>
> POST /page HTTP/1.1 Host: example.com Content-Type: application/x-www-form-urlencoded Content-Length: 20
>
> name=value&age=value
>
> **2.数据大小限制不同**
>
> GET方法将数据附加到URL中，因此数据大小有限制。在URL中，只能传递ASCII字符，并且URL的长度有限制。不同的浏览器和Web服务器对URL长度的限制不同，但通常在2KB到8KB之间。因此，使用GET方法传输大量数据可能会导致URL过长，从而影响请求的性能。
>
> POST方法将数据放在HTTP请求体中，因此数据大小不受限制。但是，Web服务器和Web应用程序可能会对POST请求的大小进行限制。这是为了避免网络拥塞和服务器过载等问题。通常，Web服务器和Web应用程序对POST请求的大小限制在1MB到2MB之间。
>
> **3.安全性不同**
>
> GET方法的参数是通过URL传递的，因此可以很容易地在浏览器地址栏中看到。如果参数包含敏感信息，例如用户名和密码等，这将是一个安全风险。因此，GET方法不适合传递敏感数据。
>
> POST方法将数据放在HTTP请求体中，因此相对于GET方法更加安全。因为POST方法的请求体不会在浏览器地址栏中显示，所以敏感信息不会暴露在URL中。但是，POST方法的请求体可能会被截获并读取，所以如果数据是敏感的，还需要采取其他安全措施。
>
> **4.缓存机制不同**
>
> GET方法具有缓存机制。如果浏览器请求的资源已经在本地缓存中存在，浏览器将使用缓存而不是向服务器发送请求。这可以提高Web应用程序的性能。但是，如果应用程序的数据频繁变化，使用GET方法可能会导致浏览器缓存过期，从而影响性能。
>
> POST方法没有缓存机制。每次使用POST方法发送请求时，浏览器都会向Web服务器发送请求，Web服务器也会重新处理请求。因此，POST方法的性能相对于GET方法较低。
>
> **5.幂等性不同**
>
> 在计算机科学中，幂等性是指对同一操作执行多次所产生的影响是相同的。在HTTP协议中，GET方法是幂等的，也就是说对同一URL执行多次GET请求，服务器的响应是相同的。因为GET方法只用于获取资源，不对服务器端的资源做任何改变。
>
> 而POST方法不是幂等的，也就是说对同一URL执行多次POST请求，服务器的响应可能会不同。因为POST方法会对服务器端的资源进行改变，如果多次执行相同的POST请求，可能会导致服务器的状态发生变化。



# jsonp知识点补充

跨域，在建议后端搭建起来后，www.a.com:3000只能通过Ajax访问到当前域名下的数据，访问www.b.com:3000属于跨域访问，会报错，跨域失败：

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231021155944110.png" alt="image-20231021155944110" style="zoom:80%;" />

想要实现跨域，使用jsonp：

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231021161235649.png" alt="image-20231021161235649" style="zoom:80%;" />

> 为什么jsonp不能发起post请求：JSONP的最基本的原理是：动态添加一个`<script>`标签，而script标签的src属性是没有跨域的限制的。这样说来，这种跨域方式其实与ajax XmlHttpRequest协议无关了。可以说jsonp的方式原理上和`<script src="http://跨域/...xx.js"></script>`是一致的，因为他的原理实际上就是 使用js的script标签 进行传参，那么必然是get方式的了，和浏览器中敲入一个url一样。JSONP 是一种【请求一段 JS 脚本，把执行这段脚本的结果当做数据】的玩法。（src中请求都是GET）`<script>`标签，只支持GET



使用jQuery 运用jsonp的本质是动态的添加了script标签去跨域访问（script标签的src属性是没有跨域的限制的），当返回成功后又删除生成的script标签，

下面的请求就是jsonp请求，请求类型是script，后面的callback就是跟在url后的get请求体：

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231021164305349.png" alt="image-20231021164305349" style="zoom:80%;" />

如果删除`dataType: "jsonp",`,该请求就变成了xhr请求，ajax的用法，图中json请求是使用Ajax实现动态生成页数的例子，请求类型是xhr，最下面的是使用jsonp请求，请求类型为script：

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231021164912351.png" alt="image-20231021164912351" style="zoom:80%;" />



查看response的内容：如果请求的callback：jQuery111104………219是一个函数，那么服务器端写的数据当作参数”text“：”hello“传给了jQuery1111……219这个函数。所以使用jsonp，返回体不是一段json字符串，而是一段js代码，将json化了的数据包装到了js代码里面，json化的数据又传给了callback的jQuery回调函数。

**所以jsonp的执行流程是：先动态生成一个script标签，script标签里面有src属性，便发起get请求，请求后服务器返回一段 JS 脚本，拿到这段脚本的数据后，传给了jQuery，jQuery执行成功success 里面的function。返回成功的同时，callback创建的jQuery的临时回调函数销毁，生成的script标签删除。完成一次跨域。**

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231021164417101.png" alt="image-20231021164417101" style="zoom:80%;" />

而采用Ajax，xhr请求的返回体直接是json字符串化后的数据

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231021165135901.png" alt="image-20231021165135901" style="zoom:80%;" />

当请求成功返回成功，这个回调函数立马被删除，

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231021171423296.png" alt="image-20231021171423296" style="zoom:80%;" />

增删dom的痕迹：

将跨域访问延迟五秒，发现五秒后再head标签里面，自动添加了一条script标签，将返回体5秒后执行，5秒后，得到了返回体，script标签删除。

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231021171944475.png" alt="image-20231021171944475" style="zoom:80%;" />

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231021171838746.png" alt="image-20231021171838746" style="zoom:80%;" />

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231021172205245.png" alt="image-20231021172205245" style="zoom:80%;" />



# cors知识点补充

在同一个域(www.b.com)下，Ajax访问成功：

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231021185306306.png" alt="image-20231021185306306" style="zoom:80%;" />

在不同域下，访问失败，因为Ajax请求不支持跨域，而且在请求头里面没有access-control-allow-origin：

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231021185203562.png" alt="image-20231021185203562" style="zoom:80%;" />

使用cors跨域，后端请求头里面设置，成功访问：

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231021185953880.png" alt="image-20231021185953880" style="zoom:80%;" />

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231021192951804.png" alt="image-20231021192951804" style="zoom:80%;" />



### 使用HTML5的window.postMessage方法跨域

window.postMessage() 方法允许来自一个文档的脚本可以传递文本消息到另一个文档里的脚本，而不用管是否跨域。一个文档里的脚本还是不能调用在其他文档里方法和读取属性，但他们可以用这种消息传递技术来实现安全的通信。

这项技术称为“跨文档消息传递”，又称为“窗口间消息传递”或者“跨域消息传递”。

postMessage() 方法，该方法允许有限的通信 —— 通过异步消息传递的方式 —— 在来自不同源的脚本之间。

postMessage 可用于解决以下方面的问题：

+ 页面和其打开的新窗口的数据传递
+ 页面与嵌套的 iframe 消息传递
+ 多窗口之间消息传递

想要使用 postMessage 实现跨域通信和页面间数据通信，只要记住 window 提供的 postMessage 方法和 message 事件就ok了。

#### 一、语法

`otherWindow.postMessage(message, targetOrigin, [transfer]);`
`otherWindow`:其他窗口的一个引用，比如 iframe 的 contentWindow 属性、执行 window.open 返回的窗口对象、或者是命名过或数值索引的 window.frames。

`message`:要发送的数据。它将会被结构化克隆算法序列化，所以无需自己序列化（部分低版本浏览器只支持字符串，所以发送的数据最好用JSON.stringify() 序列化）。

`targetOrigin`:通过 targetOrigin 属性来指定哪些窗口能接收到消息事件，其值可以是字符串“*”（表示无限制）或者一个 URI（如果要指定和当前窗口同源的话可设置为"/"）。在发送消息的时候，如果目标窗口的协议、主机地址或端口号这三者的任意一项不匹配 targetOrigin 提供的值，那么消息就不会发送。

#### 二、接收消息
如果指定的源匹配的话，那么当调用 postMessage() 方法的时候，在目标窗口的Window对象上就会触发一个 message 事件。

```js
window.addEventListener("message", (event)=>{
   var origin = event.origin;
   // 通常，onmessage()事件处理程序应当首先检测其中的origin属性，忽略来自未知源的消息
   if (origin !== "http://example.org:8080")
     return;
   // ...
}, false);
```

event 的属性有：

+ data: 从其他 window 传递过来的数据副本。 

+ origin: 调用 postMessage 时，消息发送窗口的 origin。例如：“http://example.com:8080”。

+ source: 对发送消息的窗口对象的引用。可以使用此来在具有不同 origin 的两个窗口之间建立双向数据通信。 

#### 三、使用场景
当想要在Web页面中嵌入一个来自其他站点的模块或者“gadget”的时候，利用 postMessage() 和 message 事件实现的跨域消息传递是很有用的。

首先 gadget 的开发者可以将 gadget 内容定义在一个 HTML 页面中，它负责监听 message 事件，并将它们分发给对应的 js 函数去处理。然后，嵌入 gadget 的Web页面就可以通过 postMessage() 方法传递消息来和 gadget 进行交互了。

四、完整示例
1. 不同 origin 的两个窗口之间建立双向数据通信

   ```js
   /**
   * localhost:10002/index页面
   **/
   // 接收消息
   window.addEventListener('message', (e) => {
        console.log(e.data)
   })
   // 发送消息
   const targetWindow = window.open('http://localhost:10001/user');
   setTimeout(()=>{
        targetWindow.postMessage('来自10002的消息', 'http://localhost:10001')
   }, 3000)
   ```

   ```js
   /**
   * localhost:10001/user页面
   **/
   window.addEventListener('message', (e) => {
        console.log(e.data)
        if (event.origin !== "http://localhost:10002") 
        return;
        e.source.postMessage('来自10001的消息', e.origin)
   })
   ```

   

2. 页面与嵌套的 iframe 消息传递

http://www.domain1.com/a.html

```js
<iframe id="iframe" src="http://www.domain2.com/b.html"></iframe>
 
<script>
var iframe = document.getElementById('iframe');
 
iframe.onload = function() {
   // 向domain2发送跨域数据
   iframe.contentWindow.postMessage('来自domain1的消息', 'http://www.domain2.com');
};
 
// 接受domain2返回数据
window.addEventListener('message',(e) => {
    console.log(e.data);
}, false);
</script>
```

http://www.domain2.com/b.html

```js
<script>
// 接收domain1的数据
window.addEventListener('message',(e) => {
    console.log(e.data);
 
    if(e.origin !== 'http://www.domain1.com')
    return;
 
    // 发送消息给domain1
    window.parent.postMessage('来自domain2的消息', e.origin);
}, false);
</script>
```




#### 五、安卓平台差异化处理
```js
/* Android 平台 Post Message 消息监听 Hook */
window.Android_handleMessage = message => {
    // Android 使用 Base64 编码格式，需要先解码
    let data = decodeURIComponent(escape(window.atob(message)));
};
```

#### 示例

```js
/*
 * A 窗口的域名是<http://example.com:8080>，以下是 A 窗口的 script 标签下的代码：
 */

var popup = window.open(...popup details...);

// 如果弹出框没有被阻止且加载完成

// 这行语句没有发送信息出去，即使假设当前页面没有改变 location（因为 targetOrigin 设置不对）
popup.postMessage("The user is 'bob' and the password is 'secret'",
                  "https://secure.example.net");

// 假设当前页面没有改变 location，这条语句会成功添加 message 到发送队列中去（targetOrigin 设置对了）
popup.postMessage("hello there!", "http://example.com");

function receiveMessage(event)
{
  // 我们能相信信息的发送者吗？(也许这个发送者和我们最初打开的不是同一个页面).
  if (event.origin !== "http://example.com")
    return;

  // event.source 是我们通过 window.open 打开的弹出页面 popup
  // event.data 是 popup 发送给当前页面的消息 "hi there yourself!  the secret response is: rheeeeet!"
}
window.addEventListener("message", receiveMessage, false);
```

```js
/*
 * 弹出页 popup 域名是 http://example.com，以下是 script 标签中的代码：
 */

//当 A 页面 postMessage 被调用后，这个 function 被 addEventListener 调用
function receiveMessage(event) {
  // 我们能信任信息来源吗？
  if (event.origin !== "http://example.com:8080") return;

  // event.source 就当前弹出页的来源页面
  // event.data 是 "hello there!"

  // 假设你已经验证了所受到信息的 origin (任何时候你都应该这样做), 一个很方便的方式就是把 event.source
  // 作为回信的对象，并且把 event.origin 作为 targetOrigin
  event.source.postMessage(
    "hi there yourself!  the secret response " + "is: rheeeeet!",
    event.origin,
  );
}

window.addEventListener("message", receiveMessage, false);
```

#### 六、安全问题
如果你不希望从其他网站接收 message，请不要为 message 事件添加任何事件监听器。
如果你确实希望从其他网站接收message，请始终使用 origin 和 source 属性验证发件人的身份。
当你使用 postMessage 将数据发送到其他窗口时，始终指定精确的目标 origin，而不是 *。
七、兼容性
所有主流浏览器（包括IE8）都支持。

原文链接：https://blog.csdn.net/huangpb123/article/details/83692019



Nginx反向代理



postman测试访问



```js
const express = require('express');
const app = express();

// 启用CORS中间件
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
  next();
});

// 用户注册接口
app.post('/register', (req, res) => {
  const { username } = req.body;

  // 检查用户名是否存在
  if (username === 'mafengshe') {
    res.status(200).json({ errno: 1, errmsg: '用户名已经存在', data: {} });
  } else {
    res.status(200).json({ errno: 0, errmsg: '', data: {} });
  }
});

app.listen(3000, () => {
  console.log('Server is running on port 3000');
});
```

