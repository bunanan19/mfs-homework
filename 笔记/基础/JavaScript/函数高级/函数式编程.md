# 函数式编程

函数式是 JavaScript 中很重要的一块，这部分交给大家自学。

[javascript函数式编程要掌握的知识点讲解](https://www.cnblogs.com/tugenhua0707/p/5046854.html)

[JavaScript 与函数式编程](https://www.cnblogs.com/Chen-XiaoJun/p/6188713.html)

### 一：理解call和apply 及arguments.callee

  ECMAScript3给Function的原型定义了两个方法，他们是Function.prototype.call 和 Function.prototype.apply. 其实他们的作用是一样的，只是传递的参数不一样而已；

  **1. apply;** 接受2个参数，第一个参数指定了函数体内this对象的指向，第二个参数为一个类似数组的集合，比如如下代码：

```javascript
var yunxi = function(a,b){

   console.log([a,b]); // [1,2]

   console.log(this === window); // true

};

yunxi.apply(null,[1,2]);
```

  如上代码，我们第一个参数传入null，函数体内默认会指向与宿主对象，即window对象；因此我们可以在yunxi函数内打印下值为true即可看到：

  下面我们来看看使用call方法的实例如下：

```javascript
var yunxi = function(a,b){

   console.log([a,b]); // [1,2]

   console.log(this === window); // true

};

yunxi.call(null,1,2);
```

可以看到 call方法的第二个参数是以逗号隔开的参数；

  **那么call和apply用在什么地方呢？**

1. call和apply 最常见的用途是改变函数体内的this指向，如下代码:

```javascript
var longen = {
    name:'yunxi'
};
var longen2 = {
    name: '我叫涂根华'
};
var name = "我是来测试的";
var getName = function(){
    return this.name;
};
console.log(getName()); // 打印 "我是来测试的";
console.log(getName.call(longen)); // 打印 yunxi
console.log(getName.call(longen2)); // 打印 "我叫涂根华"
```

  第一次调用 getName()方法，因为它是普通函数调用，所以它的this指向与window，因此打印出全局对象的name的值；

  第二次调用getName.call(longen); 执行这句代码后，getName这个方法的内部指针this指向于longen这个对象了，因此打印this.name实际上是longen.name，因此返回的是name=”yunxi”; 

  但是this指针也有列外的情况，比如一个点击元素，当我们点击一个元素的时候，this指针就指向与那个点击元素，但是当我们在内部再包含一个函数后，在函数内再继续调用this的话，那么现在的this指针就指向了window了；比如如下代码：

```javascript
document.getElementById("longen").onclick = function(){
    console.log(this); // this 就指向于div元素对象了
    var func = function(){
        console.log(this); // 打印出window对象
    }
    func();
}
```

 如上代码。可以看到外部this指向与被点击的那个元素，内部普通函数调用，this指针都是指向于window对象。但是我们可以使用call或者apply方法来改变this的指针的；如下代码：

```javascript
document.getElementById("longen").onclick = function(){
    console.log(this); // this 就指向于div元素对象了
    var func = function(){
        console.log(this); // 就指向于div元素对象了
    }
    func.call(this);
}
```

 如上代码我们使用call方法调用func函数，使this指向与func这个对象了，当然上面的方法我们还可以不使用call或者apply方法来改变this的指针，我们可以在外部先使用一个变量来保存this的指针，在内部调用的时候我们可以使用哪个变量即可，如下代码演示：

```javascript
document.getElementById("longen").onclick = function(){
    console.log(this); // this 就指向于div元素对象了
    var self = this;
    var func = function(){
        console.log(self); // 就指向于div元素对象了
    }
    func();
}  
```

**arguments.callee的理解**

  callee是arguments的一个属性，它可以被用作当前函数或函数体执行的环境中，或者说调用一个匿名函数；返回的是当前正在被执行的Function对象；简单的来说就是当前执行环境的函数被调用时候，arguments.callee对象会指向自身，就是当前的那个函数的引用；

如下代码：

```javascript
var count = 1;
var test = function() {
    console.log(count + " -- " + (test.length == arguments.callee.length) );
    // 打印出 1 -- true 2 -- true  3 -- true 
    if (count++ < 3) {
        // 调用test()函数自身
        arguments.callee();
    }
};
test();
```

arguments.callee()的含义是调用当前正在执行的函数自身，比如上面的test的匿名函数；

**Function.prototype.bind介绍**

目前很多高级浏览器都支持Function.prototype.bind方法，该方法用来指定函数内部的this指向。为了支持各个浏览器，我们也可以自己来简单的模拟一个~

如下代码：

```javascript
Function.prototype.bind = function(context) {
    var self = this;
    return function(){
        return self.apply(context,arguments);
    }
}
var yunxi = {
    name: 'yunxi'
};

var func = function(){
    console.log(this.name); // yunxi
}.bind(yunxi);

func();
```

如上代码所示：func这个函数使用调用bind这个方法，并且把对象yunxi作为参数传进去，然后bind函数使用return返回一个函数，当我们调用func()执行这个方法的时候，其实我们就是在调用bind方法内的return返回的那个函数，在返回的那个函数内context的上下文其实就是我们以参数yunxi对象传进去的，因此this指针指向与yunxi这个对象了~ 所以打印出this.name 就是yunxi那个对象的name了;

 除了上面我们看到的介绍apply或者call方法可以改变this指针外，我们还可以使用call或者apply来继承对象的方法；实质也就是改变this的指针了；

比如有如下代码：

```javascript
var Yunxi = function(name){
    this.name = name;
};

var Longen = function(){
    Yunxi.apply(this,arguments);
}; 
//apply方法改变了Yunxi构造函数内部的this指向。通过使用  apply方法，我们可以将  Longen构造函数中的this指向传递给Yunxi构造函数，从而实现属性和方法的继承。

Longen.prototype.getName = function(){
    return this.name;
};

var longen = new Longen("tugenhua");
console.log(longen.getName());  // 打印出tugenhua
```

 如上代码：我先实例化Longen这个对象，把参数传进去，之后使用Yunxi.apply(this,arguments)这句代码来改变Longen这个对象的this的指针，使他指向了Yunxi这个对象，因此Yunxi这个对象保存了longen这个实例化对象的参数tugenhua，因此当我们调用longen.getName这个方法的时候，我们返回this.name，即我们可以认为返回的是 Yunxi.name 因此返回的是 tugenhua，我们只是借用了下Yunxi这个对象内的this.name来保存Longen传进去的参数而已；



### 二：闭包的理解

**闭包的结构有如下2个特性**

 1.封闭性：外界无法访问闭包内部的数据，如果在闭包内声明变量，外界是无法访问的，除非闭包主动向外界提供访问接口；

 2.持久性：一般的函数，调用完毕之后，系统自动注销函数，而对于闭包来说，在外部函数被调用之后，闭包结构依然保存在

 系统中，闭包中的数据依然存在，从而实现对数据的持久使用。

 缺点：

 使用闭包会占有内存资源，过多的使用闭包会导致内存溢出等.

如下代码：

```javascript
function a(x) {
    var a = x;
    var b = function(){
        return a;
    }
    return b;
}
var b = a(1);
console.log(b()); // 1
```

首先在a函数内定义了2个变量，1个是存储参数，另外一个是闭包结构，在闭包结构中保存着b函数内的a变量，默认情况下，当a函数调用完之后a变量会自动销毁的，但是由于闭包的影响，闭包中使用了外界的变量，因此a变量会一直保存在内存当中，因此变量a参数没有随着a函数销毁而被释放，因此引申出闭包的缺点是：过多的使用闭包会占有内存资源，或内存溢出等肯能性；

```javascript
// 经典的闭包实列如下：
function f(x){              //外部函数
    var a = x;              // 外部函数的局部变量，并传递参数
    var b = function(){     // 内部函数 
        return a;           // 访问外部函数中的局部变量
    };
    a++;                    // 访问后，动态更新外部函数的变量
    return b;               // 返回内部函数
}
var c = f(5);               // 调用外部函数并且赋值
console.log(c());           // 调用内部函数，返回外部函数更新后的值为6
```

**下面我们来看看如下使用闭包的列子**

 在如下代码中有2个函数，f函数的功能是：把数组类型的参数中每个元素的值分别封装在闭包结构中，然后把闭包存储在一个数组中，并返回这个数组，但是在函数e中调用函数f并向其传递一个数组["a","b","c"],然后遍历返回函数f返回数组，我们运行打印后发现都是c undefined。

在  `for`  循环中，我们将函数推入  `arrs`  数组，但并没有立即执行这些函数。相反，它们只是被添加到数组中，并在稍后被调用。   当  `for`  循环结束后， `arrs`  数组中包含了三个函数。这些函数都是在循环结束时创建的，并且共享了相同的父级作用域，其中包括  `temp`  变量。   当我们在  `e`  函数中遍历  `ar`  数组并调用其中的函数时，它们才会执行。由于函数是在循环结束后执行的，它们引用的  `temp`  变量都是循环结束时的最后一个值，即 "c"。而i循环玩后的值为3，x[3]的值超出了索引，为undefined。

因此，每次调用函数时，都会打印出 "c  undefined"。 

在执行f函数中的循环时候，把值虽然保存在temp中，但是每次循环后temp值在不断的变化，当for循环结束后，此时temp值将保持为最后一次迭代的值，为c，因此当调用的时候 打印出来的是temp为c，最后i=3， `x[i]`  在这里是  `undefined` ，是因为arrs[3]为undefined ，  `i`  在循环结束后的最后一次迭代已经超出了数组的索引范围(0到length-1)，i=x.length,所以  `x[i]`  返回  `undefined`。

 解决闭包的缺陷我们可以再在外面包一层函数，每次循环的时候，把temp参数和i参数传递进去 如代码二

```javascript
// 代码一
function f(x) {
    var arrs = [];
    for(var i = 0; i < x.length; i++) {
        var temp = x[i];
        arrs.push(function(){
            console.log(temp + ' ' +x[i]); // c undefined。由于闭包的特性，当外部函数执行完毕之后，才会执行内部函数，for循环结束后，才会执行arrs.push中的函数。 
        });
    }
    return arrs;
}
function e(){
    var ar = f(["a","b","c"]);
    for(var i = 0,ilen = ar.length; i < ilen; i++) {
        ar[i]();
    }
}
e(); 
// 代码二：
function f2(x) {
    var arrs = [];
    for(var i = 0; i < x.length; i++) {
        var temp = x[i];
        (function(temp,i){
            arrs.push(function(){
                console.log(temp + ' ' +x[i]); 
            });
        })(temp,i);//在每次循环迭代时都创建了一个新的作用域，并将  temp  和  i  的值作为参数传递给这个作用域。这样，每个函数都会在自己的作用域中捕获到对应迭代的  temp  和  i  的值，而不是共享外部作用域的变量。因此，每个函数在被调用时都会打印出正确的值，而不会受到循环结束后  temp  和  i  的变化的影响。 通过使用立即执行函数表达式创建新的作用域，我们避免了闭包中共享变量的问题，确保了每个函数在被调用时都能正确地访问到对应迭代的变量值。 
    }
    return arrs;
}
function e2(){
    var ar = f2(["a","b","c"]);
    for(var i = 0,ilen = ar.length; i < ilen; i++) {
        ar[i]();
    }
}
e2(); 
```



### 三：javascript中的this详解

this的指向常见的有如下几点需要常用到：

1. 全局对象的this是指向与window；
2. 作为普通函数调用。
3. 作为对象方法调用。
4. 构造器调用。
5. Function.prototype.call 或 Function.prototype.apply调用。

下面我们分别来介绍一下：

  **1. 全局对象的this；**

```javascript
console.log(this); // this指向于window
//setTimeout() 和 setInterval()函数内部的this指针是指向于window的，如下代码：
 function test(){
    console.log(11);
 }
 setTimeout(function(){
    console.log(this === window); // true
    this.test(); // 11 
 });
```

 **2. 作为普通函数调用；**

```javascript
如下代码：
var name = "longen";
function test(){
    return this.name;
}
console.log(test()); // longen
```

 当作为普通函数调用时候，this总是指向了**全局对象**，在浏览器当中，全局对象一般指的是window；

 **3. 作为对象的方法调用。**

  如下代码：

```javascript
var obj = {
    "name": "我的花名改为云溪了，就是为了好玩",
    getName: function(){
        console.log(this); // 在这里this指向于obj对象了
        console.log(this.name); // 打印 我的花名改为云溪了，就是为了好玩
    }
};
obj.getName(); // 对象方法调用
```

但是呢，我们不能像如下一样调用对象了，如下调用对象的话，this还是执行了window，如下代码：

```javascript
var name = "全局对象名字";
var obj = {
    "name": "我的花名改为云溪了，就是为了好玩",
    getName: function(){
        console.log(this);  // window
        console.log(this.name); // 全局对象名字
    }
};
var yunxi = obj.getName; 
yunxi();//this动态绑定
```

运行yunxi()函数，还是会像调用普通函数一样，this指向了window的；这是因为在 JavaScript 中，函数的执行上下文（execution context）和  `this`  的绑定是在调用时确定的。   在这个例子中，我们将  `obj.getName`  赋值给了  `yunxi`  变量。然后，当我们调用  `yunxi()`  时，实际上是将函数作为普通函数来调用，而不是作为对象的方法。   在普通函数调用中， `this`  默认绑定到全局对象（在浏览器环境中是  `window`  对象）。因此，当我们在  `yunxi()`  函数中打印  `this`  时，它指向了全局对象  `window` 。   由于  `getName`  函数中的  `this`  是在调用时绑定的，而不是在定义时绑定的，所以在这种情况下， `this`  的值取决于函数的调用方式。

  **4. 构造器调用。**

  Javascript中不像Java一样，有类的概念，而JS中只能通过构造器创建对象，通过new 对象，当new运算符调用函数时候，该函数会返回一个对象，一般情况下，构造器里面的this就是指向返回的这个对象；

如下代码：

```
var Obj = function(){
    this.name = "yunxi";
};
var test = new Obj();
console.log(test.name); // yunxi
```

**注意：构造器函数第一个字母需要大写，这是为了区分普通函数还是构造器函数而言；**

如上代码：通过调用 new Obj()方法 返回值保存到test变量中，那么test就是那个对象了，所以内部的this就指向与test对象了，因此test.name就引用到了内部的this.name 即输出 “yunxi”字符串；

但是也有例外的情况，比如构造器显示地返回了一个对象的话，那么这次继续调用的话，那么会最终会返回这个对象，比如如下代码：

```javascript
var obj = function(){
    this.name = "yunxi";
    return {
        "age": "27"
    }
};
var test = new obj();
console.log(test.name); // undefined
```

那么继续调用的话，会返回unedfined，因为返回的是那个对象，对象里面没有name这个属性，因此值为undefined；



四：理解函数引用和函数调用的区别

 看下面的代码分析:

```javascript
// 函数引用 代码一
function f(){
    var x = 5;
    return x;
}
var a = f;
var b = f;

console.log(a===b); // true
// 函数调用 代码二
function f2() {
    var x = 5;
    return x;
}
var a2 = f2();
var b2 = f2();
console.log(a2 === b2);

// 函数调用 代码三
function f3(){
    var x = 5;
    return function(){
        return x;
    }
}
var a3 = f3();
var b3 = f3();
console.log(a3 === b3); // false
```

如上的代码：代码一和代码二分部是函数引用和函数调用的列子，返回都为true，代码三也是函数调用的列子，返回且为false

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231014163710396.png" alt="image-20231014163710396" style="zoom:80%;" /><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231014164104578.png" alt="image-20231014164104578" style="zoom:80%;" /><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231014164122733.png" alt="image-20231014164122733" style="zoom:80%;" />

 我们现在来理解下函数引用和函数调用的本质区别：当引用函数时候，多个变量内存存储的是函数的相同的入口指针，因此对于同一个函数来讲，无论多少个变量引用，他们都是相等的，因为对于引用类型(对象，数组，函数等)都是比较的是内存地址，如果他们内存地址一样的话，说明是相同的；但是对于函数调用来讲，比如代码三;每次调用的时候，都被分配一个新的内存地址，所以他们的内存地址不相同，因此他们会返回false，但是对于代码二来讲，我们看到他们没有返回函数，只是返回数值，他们比较的不是内存地址，而是比较值，所以他们的值相等，因此他们也返回true，我们也可以看看如下实列化一个对象的列子，他们也被分配到不同的内存地址，因此他们也是返回false的；如下代码测试：

```javascript
function F(){
    this.x = 5;
}
var a = new F();
var b = new F();
console.log(a === b); // false，当我们比较  a  和  b  是否相等时，即  a === b ，它们的引用地址是不同的，因此结果为  false 
```





#### 1. 引用类型有哪些？非引用类型有哪些2.如下代码输出什么？为什么

1. 引用类型：对象、数组、函数、正则。指的是那些保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针执行内存中的另一个位置，由该位置保存对象。
2. 非引用类型：数值、布尔值、undefined，null，string
3. 区别：在于数据的保存的形式不同。
    非引用类型的数据，其保存的方式是在内存中的栈空间，开辟一个固定大小的空间进行固定位置的保存，并且数据的访问形式是后进先出。
    引用类型的数据，其保存的形式是在内存的堆空间开辟一个动态的空间保存来保存数据的值(因为数据的大小不固定)，当我们访问这个变量的时候其实是根据出存在栈空间的指针寻址来查找到相应的堆内存空间

```jsx
var obj1 = {a:1, b:2};
var obj2 = {a:1, b:2};
console.log(obj1 == obj2);     //false,这是两个毫无关系的对象，指针所指向的地址不同
console.log(obj1 = obj2);      //{a:1,b:2},obj2指向的地址赋值给obj1，obj1和obj2共用一个地址
console.log(obj1 == obj2);    //true,因为两个对象指针所指向的地址是一样的
```

#### 2. 如下代码输出什么? 为什么

```jsx
var a = 1
var b = 2
var c = { name: '饥人谷', age: 2 }
var d = [a, b, c]
var aa = a
var bb = b
var cc = c
var dd = d
a = 11
b = 22
c.name = 'hello'
d[2]['age'] = 3
console.log(aa)            //1,因为aa和a是两个数值，不是引用类型，改变其中一个不影响另一个
console.log(bb)           //2,理由同上
console.log(cc)            //{name: "hello",age:3},c和cc指向同一个地址，c.name=“hello”改变了原来数据中的name值，所以cc输出后的值也跟着变了
console.log(dd)          //[1,2,{name:"hello",age:3}],d[2]和c都指向了同一个地址，所以数据中的name修改了，d[2]["age"]=3又改变了数据中的age值，所以输出结果为这样
```

#### 4.如下代码输出什么? 为什么

```jsx
var a = 1
var c = { name: 'jirengu', age: 2 }
function f1(n){
  ++n
}
function f2(obj){
  ++obj.age
}
f1(a) 
f2(c) 
f1(c.age) 
console.log(a)    //1 调用f1()时，f1中相当于声明了var n=a,只是把a的值赋给了n,++n只是改变了n的值，对a没有影响
console.log(c)    //{name:"jirengu",age:3} 调用f2时，f2中相当于声明了var obj=c,说明obj和c指向了同一个地址，当obj改变了数据中的值时，c的值也改变了
```



### 五：理解js中的链式调用

  我们使用jquery的时候，jquery的简单的语法及可实现链式调用方法，现在我们自己也封装一个链式调用的方法，来理解下 jquery中如何封装链式调用 无非就是每次调用一个方法的时候 给这个方法返回this即可，this指向该对象自身，我们看看代码：

```javascript
// 定义一个简单的对象，每次调用对象的方法的时候，该方法都返回该对象自身
var obj = {
    a: function(){
        console.log("输出a");
        return this;
    },
    b:function(){
        console.log("输出b");
        return this;
    }
};
console.log(obj.a().b()); // 输出a 输出b 
//1. 调用  obj.a() ，它会向控制台打印 "输出a"，然后返回  obj 。 
//2. 由于  a()  返回的是  obj ，我们可以在返回的对象上调用  .b() 。  
//3. 调用  obj.b() ，它会向控制台打印 "输出b"，然后再次返回  obj 。  
//通过将方法调用链接在一起（ obj.a().b() ），我们可以按顺序调用两个方法。每个方法的调用都会打印一条消息，并返回  obj ，使得后续的方法可以在返回的对象上调用。 

// 下面我们再看下 上面的通过Function扩展类型添加方法的demo如下：
Function.prototype.method = function(name,func) {
    if(!this.prototype[name]) {
        this.prototype[name] = func;
        return this;
    }
}
//给字符串添加方法
String.method('trim',function(){
    return this.replace(/^\s+|\s+$/g,'');//返回了去除空白字符的字符串“abc”
});
String.method('log2',function(){
    console.log("链式调用");
    return this;
});//对字符串abc输出内容然后返回字符串
String.method('r',function(){
    return this.replace(/a/,'');
});//对字符串abc删除a并返回该字符串
var str = " abc ";
console.log(str.trim().log2().r()); // 输出  链式调用  和 bc
```



### 六：理解使用函数实现历史记录--提高性能

 函数可以使用对象去记住先前操作的结果，从而避免多余的运算。比如我们现在测试一个费波纳茨的算法，我们可以使用递归函数计算fibonacci数列，一个fibonacci数字是之前两个fibonacci数字之和，最前面的两个数字是0和1；代码如下：

```javascript
var count = 0;
 var fibonacci = function(n) {
    count++;
    return n < 2 ? n : fibonacci(n-1) + fibonacci(n-2);
     //n<2等于n，n>=2等于fibonacci(n-1) + fibonacci(n-2)
 };
 for(var i = 0; i <= 10; i+=1) {
    console.log(i+":"+fibonacci(i));
 }
 console.log(count); // 453
```

我们可以看到如上 fibonacci函数总共调用了453次，for循环了11次，它自身调用了442次，如果我们使用下面的记忆函数的话，那么就可以减少他们的运算次数，从而提高性能；

思路：先使用一个临时数组保存存储结果，当函数被调用的时候，先看是否已经有存储结果 如果有的话，就立即返回这个存储结果，否则的话，调用函数运算下；代码如下：

```javascript
var count2 = 0;
var fibonacci2 = (function(){
    var memo = [0,1];
    var fib = function(n) {
        var result = memo[n];
        count2++;
        if(typeof result !== 'number') {
            result = fib(n-1) + fib(n-2);
            memo[n] = result;
        }
        return result;
    };
    return fib;
 })();
 for(var j = 0; j <= 10; j+=1) {
    console.log(j+":"+fibonacci2(j));
 }
 console.log(count2); // 29
```

这个函数也返回了同样的结果，但是只调用了函数29次，循环了11次，也就是说函数自身调用了18次，从而减少无谓的函数的调用及运算，下面我们可以把这个函数进行抽象化，以构造带记忆功能的函数，如下代码：

```javascript
var count3 = 0;
var memoizer = function(memo,formula) {
    var recur = function(n) {
        var result = memo[n];
        count3++;   // 这句代码只是说明运行函数多少次，在代码中并无作用，实际使用上可以删掉
        if(typeof result !== 'number') {
            result = formula(recur,n);
            memo[n] = result;
        }
        return result;
    };
    return recur;
 };
 var fibonacci3 = memoizer([0,1],function(recur,n){
    return recur(n-1) + recur(n-2);
 });
 // 调用方式如下
 for(var k = 0; k <=10; k+=1) {
    console.log(k+":"+fibonacci3(k));
 }
 console.log(count3); // 29
```

如上封装 memoizer 里面的参数是实现某个方法的计算公式，具体的可以根据需要自己手动更改，这边的思路无非就是想习惯使用对象去保存临时值，从而减少不必要的取值存储值的操作；



### 七：理解通过Function扩展类型

  javascript 允许为语言的基本数据类型定义方法。通过Object.prototype添加原型方法，该方法可被所有的对象使用。

  这对函数，字符串，数字，正则和布尔值都适用，比如如下现在给Function.prototype增加方法，使该方法对所有函数都可用，代码如下：

```javascript
Function.prototype.method = function(name,func) {
    if(!this.prototype[name]) {
        this.prototype[name] = func;
        return this;
    }
}
Number.method('integer',function(){
    return Math[this < 0 ? 'ceil' : 'floor'](this);
});
console.log((-10/3).integer()); // -3

String.method('trim',function(){
    return this.replace(/^\s+|\s+$/g,'');
});
console.log(" abc ".trim()); // abc
```



### 八：理解使用模块模式编写代码

使用函数和闭包可以构建模块，所谓模块，就是一个提供接口却隐藏状态与实现的函数或对象。使用函数构建模块的优点是：减少全局变量的使用；

比如如下：我想为String扩展一个方法，该方法的作用是寻找字符串中的HTML字符字体并将其替换为对应的字符；

```javascript
// 如下代码：
Function.prototype.method = function(name,func) {
    if(!this.prototype[name]) {
        this.prototype[name] = func;
        return this;
    }
}
String.method('deentityify',function(){
    var entity = {
        quot: '"',
        It: '<',
        gt: '>'
    };
    return function(){
        return this.replace(/&([^&;]+);/g,function(a,b){
            var r = entity[b];
            return typeof r === 'string' ? r : a;
        });
    }//&”开头，以“;”结尾的任意字符（不包括“&”和“;”）。其中，“([^&;]+)”表示匹配一个或多个非“&”和非“;”字符。
}());
console.log("&It;&quot;&gt;".deentityify()); // <">

//回调函数的第一个参数 a是匹配到的完整字符串，而第二个参数 b 是匹配到的捕获组（capturing group）的内容。在这个特定的回调函数中a 参数代表了匹配到的完整字符实体，例如&It; 。而 b 参数代表了匹配到的字符实体中去除了 & 和  ;  的部分，即捕获组的内容。 在回调函数中，我们使用 entity[b] 来获取 entity 对象中对应字符实体的替换值。如果 r是一个字符串类型，则将其作为替换值返回。否则，如果 r 不是一个字符串类型，则保持原样，即返回 a。
  
//这是因为在正则表达式中，使用括号 () 创建捕获组。当正则表达式进行匹配时，如果有捕获组存在，匹配到的内容会被存储在对应的捕获组中。  
//在这个特定的正则表达式  /&([^&;]+);/g  中，我们使用了一个捕获组  ([^&;]+)  来匹配一个或多个非&和非;字符。这个捕获组的内容会被存储在回调函数的第二个参数  b  中。 
//当正则表达式进行全局匹配时，每次匹配到一个字符实体时，回调函数会被调用，且第一个参数  a  是匹配到的完整字符串，第二个参数  b  是匹配到的捕获组的内容。 
```

模块模式利用函数作用域和闭包来创建绑定对象与私有成员的关联，比如在上面的deentityify()方法才有权访问字符实体表entity这个数据对象；

**模块开发的一般形式是**：定义了私有变量和函数的函数，利用闭包创建可以访问到的私有变量和函数的特权函数，最后返回这个特权函数，或把他们保存到可以访问的地方。

模块模式一般会结合实例模式使用。javascript的实例就是使用对象字面量表示法创建的。对象的属性值可以是数值或者函数，并且属性值在该对象的生命周期中不会发生变化；比如如下代码属于模块模式：定义了一个私有变量name属性，和一个实例模式(对象字面量obj)并且返回这个对象字面量obj，对象字面量中的方法与私有变量name进行了绑定；

```javascript
// 比如如下经典的模块模式
var MODULE = (function(){
    var name = "tugenhua";
    var obj = {
        setName: function() {
            this.name = name;
        },
        getName: function(){
            return this.name;
        }
    };
    return obj;
})();
MODULE.setName()
console.log(MODULE.getName()); // tugenhua
```



### 九：理解惰性实列化

在页面中javascript初始化执行的时候就实例化类，如果在页面中没有使用这个实列化的对象，就会造成一定的内存浪费和性能损耗；这时候，我们可以使用惰性实列化来解决这个问题，惰性就是把实列化推迟到需要使用它的时候才去做，做到 "按需供应";

```javascript
// 惰性实列化代码如下
var myNamespace = function(){
    var Configure = function(){
        var privateName = "tugenhua";
        var privateGetName = function(){
            return privateName;
        };
        var privateSetName = function(name) {
            privateName = name;
        };
        // 返回单列对象
        return {
            setName: function(name) {
                privateSetName(name);
            },
            getName: function(){
                return privateGetName();
            }
        }
    };
    // 存储Configure实列
    var instance;
    return {
        init: function(){
            // 如果不存在实列，就创建单列实列
            if(!instance) {
                instance = Configure();
            }
            // 创建Configure单列
            for(var key in instance) {
                if(instance.hasOwnProperty(key)) {
                    this[key] = instance[key];
                }
            }
            this.init = null;
            return this;
        }
    }
}();
// 调用方式
myNamespace.init();
var name = myNamespace.getName();
console.log(name); // tugenhua
```

如上代码是惰性化实列代码：它包括一个单体Configure实列，直接返回init函数，先判断该单体是否被实列化，如果没有被实列化的话，则创建并执行实列化并返回该实列化，如果已经实列化了，则返回现有实列；执行完后，则销毁init方法，只初始化一次



### 十：推荐分支函数(解决兼容问题的更好的方法)

  **分支函数的作用是**：可以解决兼容问题if或者else的重复判断的问题，我们一般的做法是：根据兼容的不同写if，else等，这些判断来实现兼容，但是这样明显就有一个缺点，每次执行这个函数的时候，都需要进行if和else的检测，效率明显不高，我们现在使用分支函数来实现当初始化的时候进行一些检测，在之后的运行代码过程中，代码就无需检测了；

```javascript
// 我们先来看看传统的封装ajax请求的函数
//创建XMLHttpRequest对象：
var xmlhttp;
function createxmlhttp(){
    if (window.XMLHttpRequest){
        // code for IE7+, Firefox, Chrome, Opera, Safari
        xmlhttp=new XMLHttpRequest();
    }
    else{
      // code for IE6, IE5
      xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
    }
}
// 下面我们看看分支函数代码如下：
var XHR = (function(){
    var standard = {
        createXHR : function() {
            return new XMLHttpRequest();
        }
    };
    var oldActionXObject = {
        createXHR : function(){
            return new ActiveXObject("Microsoft.XMLHTTP");
        }
    };
    var newActionXObject = {
        createXHR : function(){
            return new ActiveXObject("Msxml2.XMLHTTP");
        }
    };
    if(standard.createXHR) {
        return standard;
    }else {
        try{
            newActionXObject.createXHR();
            return newActionXObject;
        }catch(e){
            oldActionXObject.createXHR();
            return oldActionXObject;
        }
    }
})();
console.log(XHR.createXHR()); //xmlHttpRequest对象
```

上面的代码就是分支函数，分支的原理是：声明几个不同名称的对象，且为该不同名称对象声明一个相同的方法，然后根据不同的浏览器设计来实现，接着开始进行浏览器检测，并且根据浏览器检测来返回哪一个对象，不论返回的是哪一个对象，最后它一致对外的接口都是createXHR方法的；



### 十一：惰性载入函数（也是解决兼容问题的）

和上面分支的原理是一样的，代码也可以按照上面的推荐分支风格编码的；解决的问题也是解决多个if条件判断的；代码如下：

```javascript
// 代码如下：
var addEvent = function(el,type,handler){
    addEvent = el.addEventListener ? function(el,type,handler){
        el.addEventListener(type,handler,false);
    } : function(el,type,handler) {
        el.attachEvent("on" + type,handler);
    }
    addEvent(el,type,handler);
};
```

惰性载入函数也是在函数内部改变自身的一种方式，在重复执行的时候就不会再进行检测的；惰性载入函数的分支只会执行一次，即第一次调用的时候，其优点如下：

1. 要执行的适当代码只有在实际调用函数时才执行。
2. 第一次调用该函数的时候，紧接着内部函数也会执行，但是正因为这个，所以后续继续调用该函数的话，后续的调用速度会很快；因此避免了多重条件；



### 十二：理解函数节流

  DOM操作的交互需要更多的内存和CPU时间，连续进行过多的DOM相关的操作可能会导致浏览器变慢甚至崩溃，函数节流的设计思想是让某些代码可以在间断的情况下连续重复执行，实现该方法可以使用定时器对该函数进行节流操作;

比如：第一次调用函数的时候，创建一个定时器，在指定的时间间隔下执行代码。当第二次执行的时候，清除前一次的定时器并设置另一个，将其替换成一个新的定时器;

```javascript
// 如下简单函数节流代码演示
var throttle = {
    timeoutId: null,
    // 需要执行的方法
    preformMethod: function(){
    
    },
    // 初始化需要调用的方法
    process: function(){
        clearTimeout(this.timeoutId);
        var self = this;
        self.timeoutId = setTimeout(function(){
            self.preformMethod();
        },100);
    }
};
// 执行操作
throttle.process();
```

函数节流解决的问题是一些代码(比如事件)无间断的执行，这可能会影响浏览器的性能，比如浏览器变慢或者直接崩溃。比如对于mouseover事件或者click事件，比如点击tab项菜单，无限的点击，有可能会导致浏览器会变慢操作，这时候我们可以使用函数节流的操作来解决；







长久以来，面向对象在 JavaScript 编程范式中占据着主导地位。不过，最近人们对函数式编程的兴趣正在增长。函数式编程是一种编程风格，它强调将程序状态变化（即副作用[side effect]）的次数减到最小。因此，函数式编程鼓励使用不可变数据（immutable data）和纯函数（pure functions）（“纯”意味着没有副作用的）。它也更倾向于使用声明式的风格，鼓励使用命名良好的函数，这样就能使用在我们视线之外的那些打包好的细节实现，通过描述希望发生什么以进行编码。

　　尽管面向对象编程与函数式编程之间有些矛盾，它们却并非互斥的关系。JavaScript 所拥有的工具，能支持这两种方式。甚至可以说，就算不把它孤立地当作函数式语言使用，还是有不少来自函数式方法的概念和最佳实践可以帮助我们，让代码更干净，可读性更强，推理起来更简单。

### **副作用最小化**

　　所谓副作用，指的是函数内部产生了超出函数之外的变化。函数可能会做一些事，如操作 DOM、修改更高层作用域中的变量值，或者将数据写入数据库。这些带来的就是副作用。

```javascript
// 有副作用的函数：修改更高层作用域中的变量值
var x = 10;

const myFunc = function ( y ) {
  x = x + y;
};

myFunc( 3 );
console.log( x ); // 13

myFunc( 3 );
console.log( x ); // 16
```

　　副作用并非天生邪恶。不产生任何副作用的程序也无法影响世界，因此也没有任何意义（除非是作为理论兴趣进行研究）。不过，副作用确实是危险的，应当尽量避免使用，除非绝对必要。

　　当函数产生副作用的时候，仅凭借输入输出的内容，不足以明确函数究竟做了什么工作。必须了解上下文环境、程序状态的历史，这让函数更难理解。在不可预测的交互方式下，副作用可能带来一些 bug，且函数因上述依赖，测试起来也更困难。

　　副作用最小化是函数式编程中最基础的原则，接下来的多数小节都可以当作是避免副作用的一些办法概要。

**视数据为不可变动的（Immutable）**

　　变动（mutation）指的是值在原位置上的变化（an in-place change to a value）。不可变值意味着，一旦创建出来，永远都不会变化。在 JavaScript 中，简单值如数字、字符串、布尔值这些是不可变的。不过，像对象、数组这样的数据结构都是可变的。

```javascript
// push 方法改变了数组
const x = [1, 2];
console.log( x ); // [1, 2]

x.push( 3 );
console.log( x ); // [1, 2, 3]
```

**为什么要避免变动数据呢？**

　　变动是一种副作用。程序中变化的东西越少，需要跟踪记录的也就越少，程序也就越简单。

　　JavaScript 中维持对象、数组等数据结构不可变性的可用工具很有限。通过 Object.freeze 可以强制实现对象的不可变，但作用深度只有一层：

```javascript
const frozenObject = Object.freeze( { valueOne : 1, valueTwo : { nestedValue : 1 } } );
frozenObject.valueOne = 2; // 不允许
frozenObject.valueTwo.nestedValue = 2; // 竟然允许了!
```

　　不过，还是有一些很棒的工具库解决了这些问题，其中最著名的要数 Immutable 了。

　　对多数应用来说，使用工具库来保证不可变性有些矫枉过正。很多情况下，简单地将数据当作是不可变的，就能让我们受益良多。

**避免变动：数组**

　　JavaScript 数组方法可以被概括为变动方法 (mutator methods) 和非变动方法。应当尽可能避免变动方法。

　　举例来说，concat 方法可以用来替代 push 方法。push 改变了原数组；concat 返回由原数组和作为参数的数组组成的新数组，而原来的数组还是完整的。

```javascript
// push 改变了数组
const arrayOne = [1, 2, 3];
arrayOne.push( 4 );

console.log( arrayOne ); // [1, 2, 3, 4]

// concat 生成了新数组，原数组保持不变
const arrayTwo = [1, 2, 3];
const arrayThree = arrayTwo.concat([ 4 ]);

console.log( arrayTwo ); // [1, 2, 3]
console.log( arrayThree ); // [1, 2, 3, 4]
```

　　还有一些非变动方法，包括 map、filter、reduce 等。

**避免变动：对象**

　　可以使用 Object.assign 方法，而非直接编辑对象。该方法将源对象的属性复制到目标对象中，并将目标对象返回。如果总是用一个空对象作为目标对象，就能通过 Object.assign 避免直接编辑对象。

```javascript
const objectOne = { valueOne : 1 };
const objectTwo = { valueTwo : 2 };

const objectThree = Object.assign( {}, objectOne, objectTwo );

console.log( objectThree ); // { valueOne : 1, valueTwo : 2 }
```

**关于 const**

const 很有用，却不会使数据不可变。它只能防止变量被重新赋值。这不能混为一谈。

```javascript
const x = 1;
x = 2; // 不允许

const myArray = [1, 2, 3];
myArray = [0, 2, 3]; // 不允许

myArray[0] = 0; // 允许了!
```

**书写纯函数**

　　纯函数 不会改变程序的状态，也不会产生可感知的副作用。纯函数的输出，仅仅取决于输入值。无论何时何地被调用，只要输入值相同，返回值也就一样。

　　纯函数是最小化副作用的重要工具。另外，与上下文无关的特点，也让它们有了高可测试性和可复用性。

　　前面讲副作用的小节中的代码里， myFunc 函数就是非纯函数，注意两次调用时输入相同但每次返回结果却不同。不过，它也能改写成纯函数：

```javascript
// 将全局变量变为局部变量
const myFunc = function ( y ) {
  const x = 10;
  return x + y;
}

console.log(myFunc( 3 )); // 13
console.log(myFunc( 3 )); // 13
// 将 x 作为参数传递
const x = 10;

const myFunc = function ( x, y ) {
  return x + y;
}

console.log(myFunc( x, 3 )); // 13
console.log(myFunc( x, 3 )); // 13
```

你的程序最终肯定还是会产生一些副作用。当副作用产生的时候，小心应对，尽可能地约束、限制它们的影响。

**书写返回函数的函数（Function-Generating Functions）**

找一些程经验的人，让他们猜猜下面的代码做了什么：

例1

```javascript
const numbers = [1, 2, 3];

for ( let i = 0; i < numbers.length; i++ ) {
  console.log( numbers[i] );
}
```

例2

```javascript
const numbers = [1, 2, 3];

const print = function ( input ) {
  console.log( input );
};

numbers.forEach( print );
```

　　我测试过的所有人在例 2 上运气更好。例 1 展示的是命令式方法，将一列数字打印出来。例 2 展示的是声明式方法。将循环遍历数组、在控制台打印数字这些细节各种包装成 forEach 和 print 函数，无需知道如何做，就可以表达我们需要程序做什么。这让代码可读性更高。例 2 的最后一行看起来，很接近英语句子。

　　采用这种方法，涉及到编写大量函数。利用现有函数编写生成新函数的函数，可以让这个过程中的重复（DRY-er）更少。

　　特别地，JavaScript 的两个特性让这种形式的函数生成变得可能。第一个是闭包。函数能够访问包含作用域中的变量，就算该作用域已不复存在，这就是闭包。第二个特性是，JavaScript 将函数当作值来对待。这使书写高阶函数成为可能，高阶函数可以接收函数作为参数，并/或返回函数。

　　这些特性组合在一起，我们就可以编写返回函数的函数了。返回的函数能“记住”传给生成函数的参数，并在程序的其他地方使用这些参数。

**函数组合**

　　通过函数组合，可能将函数组合在一起形成新的函数。一起来看例子：

```javascript
// 通过 add 和 square 函数组合生成 addThenSquare
const add = function ( x, y ) {
  return x + y;
};

const square = function ( x ) {
  return x * x;
};

const addThenSquare = function ( x, y ) {
  return square(add( x, y ));
};
```

　　你可能会发现一直在重复这种利用更小的函数生成一个更复杂的函数的形式。通常编写一个组合函数会更有效率：

```javascript
const add = function ( x, y ) {
  return x + y;
};

const square = function ( x ) {
  return x * x;
};

const composeTwo = function ( f, g ) {
  return function ( x, y ) {
    return g( f ( x, y ) );
  };
};

const addThenSquare = composeTwo( add, square );
```



　　还可以走得更远，编写一个更一般化的组合函数：

```javascript
// 这个版本的 composeTwo 的初始化函数可以接收任意数量的参数
const composeTwo = function ( f, g ) {
  return function ( ...args ) {
    return g( f( ...args ) );
  };
};

// composeMany 可以接收任意数量的函数
// 其初始化函数能接收任意数量的参数
const composeMany = function ( ...args ) {
  const funcs = args;
  return function ( ...args ) {
    funcs.forEach(( func ) => {
      args = [func.apply( this, args )]; //将数组  args  中的元素作为参数传递给函数  func ，并在执行函数时指定上下文为  this
    });
    return args[0];
  };
};
在执行过程中，它会遍历所有的函数，并将参数依次传递给它们。每次执行完一个函数后，将其返回的结果作为下一个函数的参数，直到所有函数都执行完毕。最后，它返回最后一个函数的结果作为整个组合函数的结果。
对于每个函数，它使用apply方法将当前的参数args传递给该函数，并将函数返回的结果重新赋值给args数组
在这段代码中， funcs  是一个函数数组，它的值等于传递给  composeMany  函数的函数参数  args 。这个数组中存储了一组函数。 
然后，在返回的函数中，使用  forEach  方法对  funcs  数组进行遍历。对于数组中的每个函数  func ，通过  func.apply(this, args)  执行函数，并将结果重新赋值给  args  数据数组。这样，在下一次循环中，新的  args  数据数组会作为参数传递给下一个函数。这个过程会一直重复，直到所有的函数都执行完毕。 

在这段代码中，第一个  ...args  是指函数数组，它用于接收传递给  composeMany  函数的参数，这些参数是一组函数。 而第二个  ...args  是指数据数组，它用于接收传递给组合函数的参数，也就是在执行组合函数时传入的实际数据。 虽然它们都使用了  ...args  的语法，但它们的含义是不同的。第一个  ...args  是用于接收函数参数的，而第二个  ...args  是用于接收组合函数的实际数据参数的。

比如：
const addOne = function (x) {
  return x + 1;
};

const multiplyByTwo = function (x) {
  return x * 2;
};

const subtractThree = function (x) {
  return x - 3;
};

const composeMany = function (...args) {
  const funcs = args;
  return function (x) {
    funcs.forEach((func) => {
      x = func(x);
    });
    return x;
  };
};

const composedFunction = composeMany(addOne, multiplyByTwo, subtractThree);

console.log(composedFunction(5)); // Output: 9
```

　　组合函数的最终形式取决于你所需的通用性水平，以及偏好的 API 类型。

**偏函数（Partial Application）**

　　偏函数 指定一个或多个参数，然后返回另一个函数，该函数稍后会被完整调用。

　　在下面的例子中，double、triple 和 quadruple 都是 multiply 函数的偏函数。

```javascript
const multiply = function ( x, y ) {
  return x * y;
};

const partApply = function ( fn, x ) {
  return function ( y ) {
    fn( x, y );
  };
};

const double = partApply( multiply, 2 );
//使用  partApply  函数将  multiply  函数和参数  2  组合起来，将返回的结果赋值给  double  变量。这样， double  就成为了一个新的函数，它只需要传入一个参数  y ，然后会调用  multiply  函数，将  2  和  y  作为参数，返回它们的乘积。 
const triple = partApply( multiply, 3 );
const quadruple = partApply( multiply, 4 );

const result = double(2);
console.log(result); // Output: 4
```

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231015135431879.png" alt="image-20231015135431879" style="zoom:80%;" /><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231015135440942.png" alt="image-20231015135440942" style="zoom:80%;" />

**柯里化**

　　柯里化是将接收多个参数的函数转换为一系列只接收一个参数的函数的过程。

```javascript
const multiply = function ( x, y ) {
  return x * y;
};

const curry = function ( fn ) {
  return function ( x ) {
    return function ( y ) {
      return fn( x, y );
    };
  };
};

const curriedMultiply = curry( multiply );

const double = curriedMultiply( 2 );
const triple = curriedMultiply( 3 );
const quadruple = curriedMultiply( 4 );

console.log(triple( 6 )); // 18
```

　　柯里化和偏函数在概念上很相似（可能不会两个都需要使用），但仍然有所不同。主要区别在于，柯里化总是生成函数套链，每次只接收一个参数，而偏函数返回的函数可以一次接收多个参数。 比较它们作用于最少接收三个参数的函数时，这种差别就更明晰了：

```javascript
const multiply = function ( x, y, z ) {
  return x * y * z;
};

const curry = function ( fn ) {
  return function ( x ) {
    return function ( y ) {
      return function ( z ) {
        return fn( x, y, z );
      };
    };
  };
};

const partApply = function ( fn, x ) {
  return function ( y, z ) {
    return fn( x, y, z );
  };
};

const curriedMultiply = curry( multiply );
const partiallyAppliedMultiply = partApply( multiply, 10 );

console.log(curriedMultiply( 10 )( 5 )( 2 )); // 100
console.log(partiallyAppliedMultiply( 5, 2 )); // 100
```

**递归**

　　递归函数是这样一种函数，它会一直调用自身，直至满足基本条件。递归函数是高度声明式的。它们也很优雅，写起来很爽！

　　下面是计算递归计算阶乘的例子：

```javascript
const factorial = function ( n ) {
  if ( n === 0 ) {
    return 1;
  }
  return n * factorial( n - 1 );
};

console.log(factorial( 10 )); // 3628800
```

　　在 JavaScript 中使用递归函数需要细心一些。每次函数调用都会向调用栈（call stack）中加入新的调用帧（call frame），当函数返回的时候，该调用帧从调用栈中弹出。递归函数调用在返回之前调用自身，所以很容易就会超出调用栈的限制，导致程序崩溃。

　　不过，这可以通过尾调用优化来避免。

**尾调用优化**

　　尾调用指的是，某个函数的最后一步动作是调用函数。尾调用优化指的是，当语言编译器识别到尾调用的时候，会对其复用相同的调用帧。这意味着，在编写尾调用的递归函数时，调用帧的限制永远不会被超出，因为调用帧会被反复使用。

　　下面是将前面的递归函数采用尾递归优化重写之后的例子:

```javascript
const factorial = function ( n, base ) {
  if ( n === 0 ) {
    return base;
  }
  base *= n;
  return factorial( n - 1, base );
};

console.log(factorial( 10, 1 )); // 3628800
```

　　ES2015 语言规范中已包含了适当的尾部调用的支持，但目前在大部分环境中尚未得到支持。可以在这里查看你能否使用。

**小结**

　　函数式编程容纳了许多思想，借助它们可以优化代码。纯函数和不可变数据将副作用的危害最小化，声明式编程让代码可读性大大提高。在与复杂性的斗争中，这些是我们应当拥抱的重要工具。