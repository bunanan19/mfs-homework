## 什么是域？

出于安全的考虑，浏览器**同源策略**会限制来自不同域名、协议、端口（不同的域）资源之间的访问，这个时候，我们就需要**跨域**访问其他不同域上服务器的资源。

下表展示了相对 http://bbs.mafengshe.com/a/b.html 同源检测的示例:

http https:协议名  

bbs.mafengshe.com：主机名，   

主机名后跟端口号，默认是80，不写的情况默认端口号80   

a/路径名  

b.html文件名

| URL                                  | 结果 | 原因     |
| ------------------------------------ | ---- | -------- |
| http://bbs.mafengshe.com/a/b/c.html  | 成功 | 相同域名 |
| http://bbs.mafengshe.com/b/c.html    | 成功 | 相同域名 |
| https://bbs.mafengshe.com/a/b.html   | 失败 | 不同协议 |
| http://bbs.mafengshe.com:90/a/b.html | 失败 | 不同端口 |
| http://work.mafengshe.com/a/b/c.html | 失败 | 不同域名 |

另外，如果是协议（http和https）或者端口的不同，前端js是无法实现跨域访问的，需要后台实现。

## 如何跨域？

想要跨域，首先要从同源策略下手，**突破同源策略的限制**。

### 使用document.domain更改源

我们可以通过document.domain设置当前域的值为**自身或者是当前域的父级**，设置成父域后，较短的域将用于后续的检查。

假设在 http://bbs.mafengshe.com/a/b.html 域下执行下面语句

```js
document.domain = 'mafengshe.com'
```

这样，页面就能通过对 http://mafengshe.com/a/other.html 的同源检测。不过，document.domain 无法把 mafengshe.com 设成 otherdomail.com。如下图，将domain=test.a.com设置成www.b.com失败，但是可以设置成a.com其中a.com是test.a.com的父域，（域名:后面的是父域，前面的是子域）

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231007214813126.png" alt="image-20231007214813126" style="zoom:80%;" />

浏览器单独保存端口号。任何的赋值操作，包括`document.domain = document.domain`都会以null值覆盖掉原来的端口号。因此`company.com:8080`页面的脚本不能仅通过设置`document.domain = "company.com"`就能与`company.com`通信(company.com:8080和company.com的端口号不一致）。必须在他们双方中都进行赋值，以确保端口号都为 null 。`document.domain` 属性用于获取或设置当前文档的域名。这个属性只接受域名，而不接受端口号。

注意：使用 document.domain 来允许子域安全访问其父域时，您需要在**父域和子域中都设置 document.domain 且为相同的值**。这是必要的，即使这样做只是将父域设置回其原始值。不这样做可能会导致权限错误。例如截图中的例子，截图页面网址为test.a.com,通过domain设置成了父域a.com，所以当前页面test.a.com可以访问,a.com下的文件（a.com/canvas)，但是被访问网页也需要设置domain为a.com,才可以是实现跨域成功。

### 使用document.name 存储信息

`window`对象有个`name`属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面（甚至不同域名）都是共享一个`window.name`的，每个页面对`window.name`都有读写的权限，`window.name`是持久存在一个窗口载入过的所有页面中的，所以我们可以通过window.name在不同iframe间传递信息，name可以存储2MB的信息。

### 通过JSONP实现跨域

>  JSON（JavaScript object notation）js对象简谱，<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231008130044838.png" alt="image-20231008130044838" style="zoom:80%;" />
>
> 示图中json将一个对象（包括数组）转成了字符串。JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。JSON采用简洁的文本形式表示结构化数据，可读性较高，易于理解和生成。它基于JavaScript语言的一个子集，但与具体编程语言无关，可以被多种编程语言解析和生成。这使得JSON成为跨平台和跨语言数据交换的理想选择。（cookie，跨域）。JSON的数据结构由键值对组成，键值对之间使用逗号分隔。键是字符串，值可以是字符串、数字、布尔值、数组、对象或null。对象由花括号{}包围，数组由方括号[]包围。
>
> JSON的优势在于其简洁性和易解析性。与XML相比，JSON的数据描述更加紧凑，使用的字符更少，易于传输和解析。同时，JSON的层级结构以及简单的键值对形式使得数据的组织和访问更加直观和便捷。
>
> JSON的应用范围非常广泛。它常用于Web开发中的前后端数据传输、API接口设计、配置文件、日志记录和存储、移动应用程序与服务器之间的数据交互等场景。许多编程语言都提供了内置的JSON处理库或函数，使得对JSON数据进行解析和生成变得简单和高效。
>
> 需要注意的是，JSON只是一种数据格式，不包含逻辑运算和动态行为。它的设计初衷是用来描述和交换数据，而不是用于程序控制或函数调用。
>
> 总之，JSON是一种轻量级的数据交换格式，具有简洁性、易读性和跨平台的特点。它在Web开发、数据交互和配置文件等领域得到广泛应用，并且成为编程语言间数据交换的标准格式之一。
>
> <img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231008131023443.png" alt="image-20231008131023443" style="zoom:80%;" />

JSONP(JSON with Padding)是[JSON](http://baike.baidu.com/item/JSON)的一种“使用模式”，而 HTML 的`<script>` 元素是一个例外。利用 `<script>` 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。

JSONP(JSON with Padding)是[JSON](http://baike.baidu.com/item/JSON)的一种“使用模式”，JSONP由回调函数和数据组成，该数据就是函数的参数。

因为同源策略的缘故，我们无法访问访问非同源的资源，但是HTML 的`<script>` 元素是一个例外。利用 `<script>` 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。

```js
/**原理如下：
*  通过script标签请求js
*  后台获取get的参数
*  后台返回带上参数的fetchData(data)
*  浏览器在script请求完成后，返回的函数会被执行，参数就传过来了
*  至此跨域通信完成
**/
function fetchData(res){
    console.log('The responsed data is: '+ res.data);
}
var script = document.createElement('script');
script.src = 'http://www.baidu.com/json/?callback=fetchData';
document.body.insertBefore(script, document.body.firstChild);
```

#### JSONP的优缺点

JSONP的优点是：它不像`XMLHttpRequest`对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。

JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行`JavaScript`调用的问题。

**优点**：

- 不像`XMLHttpRequest`对象实现的Ajax请求那样受到同源策略的限制
- 兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持
- 数据调用获取简单

**缺点**：

- 只支持GET请求而不支持POST等其它类型的HTTP请求
- 它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行`JavaScript`调用的问题
- 安全性不能保证
- 调用失败的时候无法返回错误码



<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231007204527646.png" alt="image-20231007204527646" style="zoom:67%;" />

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231007204555281.png" alt="image-20231007204555281" style="zoom:67%;" />

其中iframe的网址为http://www.b.com:3000/canvas.html,若想从当前文件访问frame的dom元素，需要当前的网址也是和frame一致

### 跨域资源共享（CORS）

#### 什么是CORS？

CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。

它允许浏览器向跨源服务器，发出[`XMLHttpRequest`](http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html)请求，从而克服了AJAX只能[同源](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)使用的限制。

#### CORS实现跨域的原理

CORS背后的思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是成功还是失败

CORS跨域的实现需要前浏览器端和服务器端共同支持。服务器通过设置`Access-Control-Allow-Origin`的值为可被允许的源或者`*`,当浏览器获取到该头字段信息，就会允许AJax跨域访问了。

对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。

因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。

#### 非简单请求

首先先介绍简单请求这一概念；满足以下条件即为简单请求

- HTTP方法是下列之一

  ```
  HEAD
  GET
  POST
  ```

- 不能人为设置除下面以外的请求头：

  ```
  Accept
  Accept-Language
  Content-Language
  Content-Type （需要注意额外的限制）
  DPR
  Downlink
  Save-Data
  Viewport-Width
  Width
  ```

- 请求头中的Content-Type请求头的值是下列之一

  ```
  application/x-www-form-urlencoded
  multipart/form-data
  text/plain
  ```

不满足以上要求的请求，即为非简单请求。非简单请求是可能修改服务器资源的请求，比如请求方法是PATCH，PUT或DELETE； 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。"预检"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。

服务器收到"预检"请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。

服务器端需要返回注入下面的 response header：

```
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, POST, PUT, DELETE, PATCH 
Access-Control-Allow-Headers: X-Custom-Header
```

一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，进行跨域资源访问。

#### 与JSONP的比较

- JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求
- 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理
- JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS）

### 使用HTML5的window.postMessage方法跨域

`window.postMessage(message,targetOrigin)` 方法是`html5`新引进的特性，可以使用它来向其它的`window`对象发送消息，无论这个window对象是属于同源或不同源，目前`IE8+、FireFox、Chrome、Opera`等浏览器都已经支持`window.postMessage`方法。





## 问答题

1. 了解什么是域
   假设当前显示页面地址为 http://bbs.mafengshe.com/a/b.html
   1. http://bbs.mafengshe.com/a/b/c.html，成功
   2. http://bbs.mafengshe.com/a.html，成功，
   3. http://bbs.mafengshe.com/pic.png成功
   4. https://bbs.mafengshe.com/a/b.html失败,协议不同
   5. http://bbs.mafengshe.com:81/a/b.html失败，端口号不同
   6. http://work.mafengshe.com/a/b.html失败，域名不同
   7. http://mafengshe.com/a/b/c.html，失败，域名不同
   8. file:///a/b.html，失败，协议不同

2. 是什么原因造成直接跨域访问失败？

   > 浏览器**同源策略**会限制来自不同域名、协议、端口（不同的域）资源之间的访问

3. 跨域有哪几种方法？他们的原理各是什么？各有什么局限性？（如果有的话）
   需要回答四种跨域方法

   > 使用document.domain更改源  
   >
   > 使用document.name 存储信息 
   >
   > 通过JSONP实现跨域
   >
   > 跨域资源共享（CORS）
   >
   > 使用HTML5的window.postMessage方法跨域
   
4. 本地如何模拟跨域访问？
   请演示并截图

   > 使用serve模拟静态网页，后端可采用静态服务器

## 代码题

1. 请使用 `降域` 实现 iframe 跨域

   > 

2. 请实现 JSONP 跨域，后端可采用静态服务器

   > 