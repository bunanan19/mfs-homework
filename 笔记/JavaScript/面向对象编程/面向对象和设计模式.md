# 面向对象和设计模式

## 类的声明

> 以下以 ES5 为例，ES6 引入 `class` 关键字，可以像其他语言一样直接使用 `class` 声明类

我们可以使用 function 关键字，类似于声明一个函数一样，声明一个类。

```javascript
function Book(name,writer,price){
    this.name=name;
    this.writer=writer;
    this.price=price;
}
```

注意，根据命名规范，如果 function 声明的是类，类名首字母需要大写。

声明好了类，我们就可以使用 `new` 关键字来生成一个对象

```javascript
var book = new Book("book1","Tom","59.9")
```

Ï当然，我们也可以给 Book 类添加成员方法，给 类添加成员方法 一般有两种常用方法

### 使用 `this` 赋值成员方法（不好）

我们可以像声明成员变量一样声明类的成员方法，毕竟 js 中函数是一等公民，可以当变量一样使用

```javascript
function Book(name,writer,price){
    this.name=name;
    this.writer=writer;
    this.price=price;
    // 这里需要注意保留 Book 函数域内的 this
    var that = this;
    // function 中的 this 是指向自身的，所以需要使用 that
    this.getRMB = function (){
        return that.price+"元";
    }
}

var book = new Book("book1","Tom","59.9")
var book2 = new Book("book2","jack","29.9")

// 调用成员方法
book.getRMB()

console.log(book.getRMB == book2.getRMB) //false，每个对象的 getRMB 都是独立的新生成的函数，但当对象过多时，会生成很多对应函数，消耗了大量内存（缺点）
```

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012181933331.png" alt="image-20231012181933331" style="zoom: 67%;" />



<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231013134257237.png" alt="image-20231013134257237" style="zoom: 67%;" /><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231013134337297.png" alt="image-20231013134337297" style="zoom: 67%;" />

在Book里面使用that和不使用的区别。两者调用book.getRMB（）都是没有问题的，但是将其赋值给变量，调用变量时出现了问题。使用that function 目的是为了避免出现错误，防范性编程。

图一未使用，test返回undefined元，证明this.price为undefined，this没有指向book，是因为this是动态绑定，（静态绑定，变量一旦赋值，之后变量的值不会改变，除非重新赋值，写代码的时候就可以确定变量的值。）调用test时，就是调用function匿名函数，其中的this是动态绑定，（代码执行时值才确定，写代码的时候不一定是最后执行的值）此时代码执行但是this没有对应的新对象去对应，便去对应window对象，此时this指向window，但是price未定义，所以为undefined。

图二使用that实现了this的静态绑定



<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231013144209475.png" alt="image-20231013144209475" style="zoom:67%;" />这里的call改变了this的内部指向，将this指向了o对象，在javascript中，call方法可以用来代替一个对象调用一个方法，可以将一个函数的对象上下文从初始化改为新的对象，也就是括号里面的原本的对象改为call()前面的对象。obj1.method1.call(obj2,argument1,argument2)
如上，call的作用就是把obj1的方法放到obj2上使用，后面的argument1..这些做为参数传入．call，apply，

### 使用 `prototype` 声明成员方法

我们可以通过给类的 constructor 添加 `prototype` ，js 会自动给其生成的对象添加 `__proto__` 属性，形成原型链. 从而实现对象共享成员方法

```javascript
function BookP(name,writer,price){
    this.name=name;
    this.writer=writer;
    this.price=price;
}

// 设置 BookP 的 prototype 属性
BookP.prototype.getRMB = function(){
    return this.price+"元";
}


var bookp = new BookP("book1","Tom","59.9")
var bookp2 =  new BookP("book2","jack","29.9")

// 调用成员方法
bookp.getRMB()

console.log(bookp.getRMB == bookp2.getRMB) // true， 所有对象共用一个 getRMB
```

这个方法所有对象共享同一成员函数，效率更高，建议使用

## 代码封装

学会了类的概念，我们就可以使用类来封装模块，使得我们的代码可重用，同时又屏蔽了代码的复杂性。

下面就以 `返回顶部` 为例，进行代码封装

### 目的

我们在外部可以使用如下代码，即可在页面中添加 `返回顶部` 按钮

```javascript
var ele = $(".back-top")
new BackTop(ele);
```

### 实现

```javascript
function BackTop($node){
    var timer;
    $node.on("click",function(){
        window.scrollTo(0,0);
    })
    // $node.click(function(){
    //     window.scrollTo(0,0);
    // })
    window.onscroll = function () {
        console.log("onscroll")

        // 防止事件过多，造成卡顿，故降低事件密度
        clearTimeout(timer)
        timer = setTimeout(function () {
            var windowH = $(window).height();//获取当前窗口高度
            var scrollTop = $(window).scrollTop();//获取当前滚动高度
            if(scrollTop > windowH *0.5){
                $node.addClass("show")
            }
            if(scrollTop < windowH *0.5){
                $node.removeClass("show")
            }
        }, 50)
        //滚动事件发生后的50毫秒内检查窗口的滚动位置，并根据条件向  $node  元素添加或删除  show  类。如果在这50毫秒内再次触发滚动事件，之前的定时器会被取消，重新设置一个新的定时器。这样可以避免在连续滚动时频繁执行代码，以提高性能。
    }
}
//$  符号代表 jQuery 库。jQuery 是一个广泛使用的 JavaScript 库，简化了 HTML 文档的遍历、事件处理和操作。它提供了一种简洁的语法来与 HTML 元素进行交互和操作。 
//因此， $(".back-top")  使用  $  符号作为 jQuery 函数，以选择具有类名 "back-top" 的 HTML 元素。它返回一个 jQuery 对象，表示所选元素，并允许您对其进行各种操作。  
//总结一下， $  是 jQuery 库的简写符号， $(".back-top")  使用 jQuery 来选择具有类名 "back-top" 的 HTML 元素。
```

我们可以把复杂的逻辑包装在 `BackTop`这个类里

完整代码可以参看[这里](https://mafengshe.github.io/fe-demo/back-top.html)

## 常用设计模式

### 工厂模式

我们来看一个简单的例子：

```javascript
var employee1 = new Object();
employee1.position = "Front end engineer";
employee1.tool = "I love vscode.";
employee1.introduction = function () {
    console.log("I am a " + this.position + ", and " + this.tool);
}
var employee2 = new Object();
employee2.position = "UI designer";
employee2.tool = "I love photoshop.";
employee2.introduction = function () {
    console.log("I am a " + this.position + ", and " + this.tool);
}
employee1.introduction(); // I am a Front end engineer, and I love vscode.
employee2.introduction(); // I am a UI designer, and I love photoshop.
```

在上边这个例子中，我们定义了两个employee，一个是Front End Engineer，另一个是UI designer，他们都有position属性和tool属性，也都有introduction方法。如果我们需要创建很多个类似employee的对象呢，那我们就需要重复很多类似的代码。接下来，我们做一些简单的修改：

```javascript
function Employee(type) {
    var employee;
    if (type == "programmer") {
        employee = new Programmer();
    } else if (type == "designer") {
        employee = new Designer();
    }
    employee.introduction = function () {
        console.log("I am a " + this.position + ", and " + this.tool);
    }
    return employee;

}

function Programmer() {
    this.position = "Front end engineer";
    this.tool = "I love vscode.";
}
function Designer() {
    this.position = "UI designer";
    this.tool = "I love photoshop.";
}

var employee1 = Employee("programmer");
employee1.introduction();//I am a Front end engineer, and I love vscode.
var employee2 = Employee("designer");
employee2.introduction();//I am a UI designer, and I love photoshop.
```

### 单例模式

单例模式提供了一种将代码组织为一个逻辑单元的手段，这个逻辑单元中的代码可以通过单一变量进行访问。 优点是：

- 可以用来划分命名空间，减少全局变量的数量。
- 使用单体模式可以使代码组织的更为一致，使代码容易阅读和维护。
- 可以被实例化，且实例化一次。
- 单体模式如果有实例化的话，那么只实例化一次，要实现一个单体模式的话，我们无非就是使用一个变量来标识该类是否被实例化，如果未被实例化的话，那么我们可以实例化一次，否则的话，直接返回已经被实例化的对象。
- **在单例模式中，instance是类的静态成员，也是单例对象**。

  单例模式是指一个类只有一个实例，且该类能自行创建这个实例的一种模式。单例模式中的instance是该单例对象的引用，可以直接访问，不需要实例化该类的对象1。在单例模式中，该类提供一个获取单例对象的方法getInstance。如果单例初始值是null，还未构建，则构建单例对象并返回；如果单例对象一开始就被new Singleton()主动构建，则不再需要判空操作。

```javascript
function Singleton(name){
    this.name = name;
};
Singleton.prototype.getName = function(){
    return this.name;
}
// 获取实例对象
Singleton.getInstance = function() {
    if(!this.instance) {
        this.instance = new Singleton();
    }
    return this.instance;
}
// 测试单体模式的实例
var a = Singleton.getInstance();
//调用 Singleton.getInstance() 时， this.instance 指的是 Singleton 构造函数内部的 this.instance ，而不是 a.instance 。a等于其返回值
var b = Singleton.getInstance();

console.log(a == b) // true，为同一个对象,a和b相等是因为它们引用的是同一个实例。
```

在实际使用中，如遇模式对话框等场景，我可以考虑使用单例模式

```javascript
// 单体模式
var Singleton = function(name){
    this.name = name;
    this.instance = null;
};
Singleton.prototype.getName = function(){
    return this.name;
}
// 获取实例对象
function getInstance(name) {
    if(!this.instance) {
        this.instance = new Singleton(name);
    }
    return this.instance; //this指向getInstance
}
// 测试单体模式的实例
var a = getInstance("aa");
var b = getInstance("bb");
```

// 因为单体模式是只实例化一次，所以下面的实例是相等的

console.log(a === b); // true

由于单体模式只实例化一次，因此第一次调用，返回的是a实例对象，当我们继续调用的时候，b的实例就是a的实例，因此下面都是打印的是aa；

console.log(a.getName());// aa

console.log(b.getName());// aa

### 其他设计模式

其实还有很多设计模式，如

- 模块模式
- 代理模式
- 职责链模式
- 命令模式
- 模板方法模式
- 策略模式
- 订阅模式
- 中介者模式

具体可以参看[这里](http://www.cnblogs.com/tugenhua0707/p/5198407.html)



## 问答题

1. 什么是类，类有什么用？

   > **类是封装对象属性和行为的载体，是具有共同特征和行为的一类事物的统称**。
   >
   > 类的作用是定义对象，规范对象的行为，为对象的创建提供定义。类中定义了对象的属性和方法，对象的属性是以成员变量的形式定义的，对象的行为是以方法的形式定义的。类的实例也被称为对象，一个类可以创建多个对象，每个对象都拥有类中定义的属性和行为。

2. js中如何声明类，

   > 我们可以使用 function 关键字，类似于声明一个函数一样，声明一个类。

3. 构造函数允许返回自定义对象吗？如果 return 返回自定义对象会怎么样？

   > 在JavaScript构造函数中：如果return值类型，那么对构造函数没有影响，实例化对象返回空对象；如果return引用类型（数组，函数，对象），那么实例化对象就会返回该引用类型。
   >
   > 如果return返回this，与没有return是一样的，因为this就是指的new的那个实例对象
   >
   > - 传统语言中，构造函数是没有返回值的。构造函数与普通函数的区别可以认为是：构造函数中没有return语句，普通函数可以return；构造函数中使用this定义成员变量和成员方法，普通函数中不使用this关键字定义成员变量和方法。然而在JavaScript中构造函数可以有返回值也可以没有。
   >
   > - 如果有return
   >
   >   > - 没有返回值的情况像其他传统语言一样，返回实例化的对象
   >   >
   >   >   ```javascript
   >   >   function Person(){
   >   >   this.name="monster1935";
   >   >   this.age='24';
   >   >   this.sex="male";
   >   >   }
   >   >   console.log(Person());  //undefined
   >   >   console.log(new Person());//Person {name: "monster1935", age: "24", sex: "male"}
   >   >   ```
   >   >
   >   >   
   >   >
   >   > - 如果存在返回值则检查其返回值是否为引用类型，如果为非引用类型，如（string,number,boolean,null,undefined），上述几种类型的情况与没有返回值的情况相同，实际返回实例化的对象
   >   >
   >   >   ```javascript
   >   >   function Person(){
   >   >   this.name="monster1935";
   >   >   this.age='24';
   >   >   this.sex="male";
   >   >   return "monster1935";
   >   >   }
   >   >   ```
   >   >
   >   >   
   >   >
   >   > - 如果存在返回值是引用类型，则实际返回该引用类型
   >   >
   >   >   ```javascript
   >   >   function Person(){
   >   >   this.name="monster1935";
   >   >   this.age='24';
   >   >   this.sex="male";
   >   >   return {
   >   >       name:'Object',
   >   >       age:'12',
   >   >       sex:'female'
   >   >   }
   >   >   }
   >   >   console.log(Person());  //Object {name: "Object", age: "12", sex: "female"}
   >   >   console.log(new Person());//Object {name: "Object", age: "12", sex: "female"}
   >   >   ```
   >   >
   >   >   
   >
   > 
   >
   > 这是一个例子：
   >
   > ```javascript
   > function MyObject() {
   > this.myProperty = "Hello";
   > return new MyOtherObject();
   > }
   > 
   > function MyOtherObject() {
   > this.myOtherProperty = "World";
   > }
   > 
   > let obj = new MyObject();
   > console.log(obj.myOtherProperty); // "World"
   > ```
   >
   > 在 JavaScript 中，构造函数允许返回自定义对象。当构造函数中使用  `return`  语句返回一个对象时，会发生以下情况：   1. 如果返回的是一个对象（自定义对象），则该对象将成为通过构造函数创建的实例。这意味着实例将具有返回的对象的属性和方法。   2. 如果返回的是一个非对象（如基本类型或其他非对象类型），则会忽略返回值，仍然返回通过构造函数创建的实例。   下面是一个示例，展示了构造函数返回自定义对象的情况：
   >
   > ```javascript
   >function Person(name, age) {
   > this.name = name;
   >this.age = age;
   > 
   > // 返回自定义对象
   > return {
   > greeting: function() {
   > console.log("Hello, I'm " + this.name + " and I'm " + this.age + " years old.");
   > }
   > };
   > }
   > 
   > var person = new Person("John", 30);
   > person.greeting(); // 输出：Hello, I'm undefined and I'm undefined years old.
   > ```
   > 
   > 在这个示例中，构造函数  `Person`  返回一个自定义对象，其中包含一个  `greeting`  方法。当通过  `new Person("John", 30)`  创建实例时，返回的对象成为实例，并且可以调用  `greeting`  方法。   需要注意的是，当构造函数返回自定义对象时，原本构造函数中的其他属性和方法将被忽略，因为返回的对象将完全替代实例。因此，构造函数返回自定义对象可能会改变实例的行为和结构。
   
4. 使用 `this` 赋值成员方法和使用 `prototype` 声明成员方法的区别是什么？

   > 在JavaScript中，`this`和`prototype`都用于处理对象和对象方法，但它们的功能和用途是有所不同的。
   >
   > `this`关键字在JavaScript中通常指向函数运行时的上下文。在对象的方法中，`this`通常指向方法所属的对象。
   >
   > ```javascript
   > let obj = {
   >  value: 10,
   >  increment: function() {
   >      this.value++;
   >  }
   > };
   > 
   > obj.increment();
   > console.log(obj.value); // 输出：11
   > ```
   >
   > 在这个例子中，`this`在`increment`方法中指向`obj`对象，所以当我们调用`increment`方法时，`value`属性会增加。
   >
   > 而`prototype`是JavaScript中对象类型（如函数）的一个内部属性。每个对象类型都有一个原型对象，而这个原型对象包含可以被特定类型的所有实例共享的属性和方法。当试图访问一个对象的属性时，如果该对象自身没有这个属性，那么JavaScript会在这个对象的原型（也就是它的`prototype`属性）中查找这个属性，这就是原型链。
   >
   > 使用`prototype`声明成员方法，可以让所有的实例共享这个方法，而不是每个实例都有自己的方法副本。例如：
   >
   > ```javascript
   > function MyObject() {
   >  this.value = 10;
   > }
   > 
   > MyObject.prototype.increment = function() {
   >  this.value++;
   > }
   > 
   > let obj1 = new MyObject();
   > let obj2 = new MyObject();
   > 
   > obj1.increment();
   > obj2.increment();
   > 
   > console.log(obj1.value); // 输出：11
   > console.log(obj2.value); // 输出：11
   > ```
   >
   > 在这个例子中，我们创建了一个`MyObject`构造函数，并且我们在它的`prototype`上定义了`increment`方法。所以，所有的`MyObject`实例（如`obj1`和`obj2`）都可以访问这个共享的方法。注意这个方法不会影响原型链，它只改变调用这个方法的对象。
   >
   > 使用 `this` 赋值成员方法时，不同新对象继承类的方法是不同的，都是各自新创建的副本。
   >
   > 使用 `prototype` 声明成员方法时，不同实例对象继承的方法是同一个，是让所有的实例共享这个方法，而不是每个实例都有自己的方法副本。

5. 请自学js中实现继承的方法，并说说js实现继承的本质是什么？

   > JavaScript 中的继承是通过原型链实现的。每个对象都有一个指向它的原型（prototype）的链接，当试图访问一个对象的属性时，如果该对象内部不存在这个属性，那么 JavaScript 就会在对象的原型上寻找这个属性，这就是原型链。
   >
   > 实现继承的一种基本方法是使用 `Object.create()` 方法或者new 方法，它创建一个新对象，使用构造函数类的`prototype`作为新创建对象的`prototype.__proto__`。

6. 常见的设计模式有哪些？请说出至少5个

   > - 工厂模式
   > - 单例模式
   > - 模块模式
   > - 代理模式
   > - 职责链模式
   > - 命令模式

## 代码题

1. 请实现`BackTop` 这个类，实现点击回到顶部的效果，外部只需要使用如下调用方式即可。

   ```javascript
   var ele = $(".back-top")
   new BackTop(ele);
   ```

   ```javascript
   function BackTop($node){
       var timeId;
       $node[0].addEventListener('click',function(){
           window.scrollTo(0,0);
       })
       window.onscroll = function(){
           clearTimeout(timeId)
           timeId = setTimeout(function(){
               var T = $(window).scrollTop();
               var H = $(window).height();
               if(T > H*0.5){
                   $node.addClass("show")
               } else{
                   $node.removeClass("show")
               }
           },100)
       }
   }
   ```

   

2. 请手动实现 instanceOf(obj,Clazz) 函数，其行为和js元素提供的 `obj instanceof Clazz`一致

   在JavaScript中，`obj instanceof Clazz` 是一个用于检查 `obj` 是否是 `Clazz` 类的实例的表达式。如果 `obj` 是 `Clazz` 的实例，或者是 `Clazz` 的子类的实例，那么这个表达式会返回 `true`。

   ```javascript
   function instanceOf(obj, Clazz) {
     if (typeof Clazz !== 'function') {
       throw new TypeError(Clazz '必须是函数');
     }
   
     if (typeof obj !== 'object' || obj === null) {
       return false;
     }
   
     let proto = Object.getPrototypeOf(obj);
     while (proto !== null) {
       if (proto === Clazz.prototype) {
         return true;
       }
       proto = Object.getPrototypeOf(proto);
     }
   
     return false;
   }
   ```

   

3. 请动手实现工厂模式

   ```javascript
   function createProduct(type) {
     if (type === 'A') {
       return new ProductA();
     } else if (type === 'B') {
       return new ProductB();
     } else {
       throw new Error(type'不存在');
     }
   }
   
   function ProductA() {
     this.type = 'A';
     this.operation = function() {
       console.log('This is product A.');
     };
   }
   
   function ProductB() {
     this.type = 'B';
     this.operation = function() {
       console.log('This is product B.');
     };
   }
   
   var product1 = createProduct('A');
   var product2 = createProduct('B');
   
   // 调用产品实例的方法
   product1.operation();
   product2.operation();
   ```
   
   
   
4. 请动手实现单例模式

   ```javascript
   // 单体模式
   var Singleton = function(name){
       this.name = name;
       this.instance = null;
   };
   Singleton.prototype.getName = function(){
       return this.name;
   }
   // 获取实例对象
   Singleton.getInstance = function() {
       if(!this.instance) {
           this.instance = new Singleton(name);
       }
       return this.instance;
   }
   // 测试单体模式的实例
   var a = Singleton.getInstance("aa");
   var b = Singleton.getInstance("bb");
   var c = new Singleton();
   
   console.log(a==b);//true
   console.log(a==c);//false
   ```
   
   
   
5. 请自学js中实现继承的方法，并实现如下的类的继承关系：人和狗都继承自动物类，动物类有吃和睡两个方法，人和狗对吃和睡都有自己的实现。

   ```javascript
   function Animal(name) {
       this.name = name;
   }
   
   Animal.prototype.eat = function() {
       console.log(this.name + " is eating.");
   };
   Animal.prototype.sleep = function() {
       console.log(this.name + " is sleeping.");
   };
   
   // 人类
   function Person(name,where,what) {
       Animal.call(this, name);  // 调用父类（动物）的构造函数
       this.where=where;
       this.what=what;
   }
   Person.prototype.__proto__ = Animal.prototype;
   // 人类的方法
   Person.prototype.eat = function() {
       console.log(this.name + " is eating the " +this.what);
   };
   Person.prototype.sleep = function() {
       console.log(this.name + " is sleeping in the " + this.where);
   };
   
   // 狗类
   function Dog(name,when,what) {
       Animal.call(this, name);  // 调用父类（动物）的构造函数
       this.when=when;
       this.what=what;
   }
   Dog.prototype.__proto__ = Animal.prototype;
   
   // 狗的方法
   Dog.prototype.eat = function() {
       console.log(this.name + " is eating the " + this.what );
   };
   Dog.prototype.sleep = function() {
       console.log(this.name + " is sleeping when " + this.when);
   };
   
   var Jack = new Person("Jack","bed","rice");
   var fu = new Dog("fu","8:00","apple");
   Jack.eat();
   fu.sleep();
   ```
   
   <img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231013155720638.png" alt="image-20231013155720638" style="zoom:80%;" />