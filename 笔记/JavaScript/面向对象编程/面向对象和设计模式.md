# 面向对象和设计模式

## 类的声明

> 以下以 ES5 为例，ES6 引入 `class` 关键字，可以像其他语言一样直接使用 `class` 声明类

我们可以使用 function 关键字，类似于声明一个函数一样，声明一个类。

```javascript
function Book(name,writer,price){
    this.name=name;
    this.writer=writer;
    this.price=price;
}
```

注意，根据命名规范，如果 function 声明的是类，类名首字母需要大写。

声明好了类，我们就可以使用 `new` 关键字来生成一个对象

```javascript
var book = new Book("book1","Tom","59.9")
```

Ï当然，我们也可以给 Book 类添加成员方法，给 类添加成员方法 一般有两种常用方法

### 使用 `this` 赋值成员方法

我们可以像声明成员变量一样声明类的成员方法，毕竟 js 中函数是一等公民，可以当变量一样使用

```javascript
function Book(name,writer,price){
    this.name=name;
    this.writer=writer;
    this.price=price;
    // 这里需要注意保留 Book 函数域内的 this
    var that = this;
    // function 中的 this 是指向自身的，所以需要使用 that
    this.getRMB = function (){
        return that.price+"元";
    }
}

var book = new Book("book1","Tom","59.9")
var book2 = new Book("book2","jack","29.9")

// 调用成员方法
book.getRMB()

console.log(book.getRMB == book2.getRMB) //false，每个对象的 getRMB 都是独立的函数
```

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012181933331.png" alt="image-20231012181933331" style="zoom:80%;" />



### 使用 `prototype` 声明成员方法

我们可以通过给类的 constructor 添加 `prototype` ，js 会自动给其生成的对象添加 `__proto__` 属性，形成原型链. 从而实现对象共享成员方法

```javascript
function BookP(name,writer,price){
    this.name=name;
    this.writer=writer;
    this.price=price;
}

// 设置 BookP 的 prototype 属性
BookP.prototype.getRMB = function(){
    return this.price+"元";
}


var bookp = new BookP("book1","Tom","59.9")
var bookp2 =  new BookP("book2","jack","29.9")

// 调用成员方法
bookp.getRMB()

console.log(bookp.getRMB == bookp2.getRMB) // true， 所有对象共用一个 getRMB
```

这个方法所有对象共享同一成员函数，效率更高，建议使用

## 代码封装

学会了类的概念，我们就可以使用类来封装模块，使得我们的代码可重用，同时又屏蔽了代码的复杂性。

下面就以 `返回顶部` 为例，进行代码封装

### 目的

我们在外部可以使用如下代码，即可在页面中添加 `返回顶部` 按钮

```javascript
var ele = $(".back-top")
new BackTop(ele);
```

### 实现

```javascript
function BackTop($node){
    var timer;
    $node.on("click",function(){
        window.scrollTo(0,0);
    })
    window.onscroll = function () {
        console.log("onscroll")

        // 防止事件过多
        clearTimeout(timer)
        timer = setTimeout(function () {
            var windowH = $(window).height();
            var scrollTop = $(window).scrollTop();
            if(scrollTop > windowH *0.5){
                $node.addClass("show")
            }
            if(scrollTop < windowH *0.5){
                $node.removeClass("show")
            }
        }, 50)
    }
}
//$  符号代表 jQuery 库。jQuery 是一个广泛使用的 JavaScript 库，简化了 HTML 文档的遍历、事件处理和操作。它提供了一种简洁的语法来与 HTML 元素进行交互和操作。 
//因此， $(".back-top")  使用  $  符号作为 jQuery 函数，以选择具有类名 "back-top" 的 HTML 元素。它返回一个 jQuery 对象，表示所选元素，并允许您对其进行各种操作。  
//总结一下， $  是 jQuery 库的简写符号， $(".back-top")  使用 jQuery 来选择具有类名 "back-top" 的 HTML 元素。
```

我们可以把复杂的逻辑包装在 `BackTop`这个类里

完整代码可以参看[这里](https://mafengshe.github.io/fe-demo/back-top.html)

## 常用设计模式

### 工厂模式

我们来看一个简单的例子：

```javascript
var employee1 = new Object();
employee1.position = "Front end engineer";
employee1.tool = "I love vscode.";
employee1.introduction = function () {
    console.log("I am a " + this.position + ", and " + this.tool);
}
var employee2 = new Object();
employee2.position = "UI designer";
employee2.tool = "I love photoshop.";
employee2.introduction = function () {
    console.log("I am a " + this.position + ", and " + this.tool);
}
employee1.introduction(); // I am a Front end engineer, and I love vscode.
employee2.introduction(); // I am a UI designer, and I love photoshop.
```

在上边这个例子中，我们定义了两个employee，一个是Front End Engineer，另一个是UI designer，他们都有position属性和tool属性，也都有introduction方法。如果我们需要创建很多个类似employee的对象呢，那我们就需要重复很多类似的代码。接下来，我们做一些简单的修改：

```javascript
function Employee(type) {
    var employee;
    if (type == "programmer") {
        employee = new Programmer();
    } else if (type == "designer") {
        employee = new Designer();
    }
    employee.introduction = function () {
        console.log("I am a " + this.position + ", and " + this.tool);
    }
    return employee;

}

function Programmer() {
    this.position = "Front end engineer";
    this.tool = "I love vscode.";
}
function Designer() {
    this.position = "UI designer";
    this.tool = "I love photoshop.";
}

var employee1 = Employee("programmer");
employee1.introduction();//I am a Front end engineer, and I love vscode.
var employee2 = Employee("designer");
employee2.introduction();//I am a UI designer, and I love photoshop.
```

### 单例模式

单例模式提供了一种将代码组织为一个逻辑单元的手段，这个逻辑单元中的代码可以通过单一变量进行访问。 优点是：

- 可以用来划分命名空间，减少全局变量的数量。
- 使用单体模式可以使代码组织的更为一致，使代码容易阅读和维护。
- 可以被实例化，且实例化一次。

```javascript
function Singleton(name){
    this.name = name;
};
Singleton.prototype.getName = function(){
    return this.name;
}
// 获取实例对象
Singleton.getInstance = function() {
    if(!this.instance) {
        this.instance = new Singleton();
    }
    return this.instance;
}
// 测试单体模式的实例
var a = Singleton.getInstance();
var b = Singleton.getInstance();

console.log(a == b) // true，为同一个对象
```

在实际使用中，如遇模式对话框等场景，我可以考虑使用单例模式

### 其他设计模式

其实还有很多设计模式，如

- 模块模式
- 代理模式
- 职责链模式
- 命令模式
- 模板方法模式
- 策略模式
- 订阅模式
- 中介者模式

具体可以参看[这里](http://www.cnblogs.com/tugenhua0707/p/5198407.html)



## 问答题

1. 什么是类，类有什么用？

   > **类是封装对象属性和行为的载体，是具有共同特征和行为的一类事物的统称**。
   >
   > 类的作用是定义对象，规范对象的行为，为对象的创建提供定义。类中定义了对象的属性和方法，对象的属性是以成员变量的形式定义的，对象的行为是以方法的形式定义的。类的实例也被称为对象，一个类可以创建多个对象，每个对象都拥有类中定义的属性和行为。

2. js中如何声明类，

   > 我们可以使用 function 关键字，类似于声明一个函数一样，声明一个类。

3. 构造函数允许返回自定义对象吗？如果 return 返回自定义对象会怎么样？

   > 构造函数可以返回自定义对象。如果构造函数返回一个自定义对象，那么这个返回的对象将会作为新创建的对象的 `[[Prototype]]`（也就是 `__proto__` 属性）。在 JavaScript 中，对象都有一个指向其原型（prototype）的链接，当我们访问一个对象的属性时，如果该对象内部不存在这个属性，那么 JavaScript 就会在对象的原型上寻找这个属性，这就是原型链。
   >
   > 这是一个例子：
   >
   > ```javascript
   > function MyObject() {
   >     this.myProperty = "Hello";
   >     return new MyOtherObject();
   > }
   > 
   > function MyOtherObject() {
   >     this.myOtherProperty = "World";
   > }
   > 
   > let obj = new MyObject();
   > console.log(obj.myOtherProperty); // "World"
   > ```
   >
   > 在这个例子中，`MyObject` 构造函数返回了一个新的 `MyOtherObject` 实例。当我们创建 `MyObject` 的新实例时，这个实例实际上是 `MyOtherObject` 的实例，因此我们可以访问 `MyOtherObject` 的属性 `myOtherProperty`。
   >
   > 然而，这种情况并不常见，因为通常我们希望一个构造函数修改其自身创建的对象（也就是 this），而不是返回一个新的对象。如果你想创建一个返回特定对象类型的构造函数，你可能需要重新考虑你的设计，或者使用工厂模式或者构建器模式等其他设计模式。
   >
   > 在 JavaScript 中，构造函数允许返回自定义对象。当构造函数中使用  `return`  语句返回一个对象时，会发生以下情况：   1. 如果返回的是一个对象（自定义对象），则该对象将成为通过构造函数创建的实例。这意味着实例将具有返回的对象的属性和方法。   2. 如果返回的是一个非对象（如基本类型或其他非对象类型），则会忽略返回值，仍然返回通过构造函数创建的实例。   下面是一个示例，展示了构造函数返回自定义对象的情况：
   >
   > ```javascript
   > function Person(name, age) {
   >   this.name = name;
   >   this.age = age;
   > 
   >   // 返回自定义对象
   >   return {
   >     greeting: function() {
   >       console.log("Hello, I'm " + this.name + " and I'm " + this.age + " years old.");
   >     }
   >   };
   > }
   > 
   > var person = new Person("John", 30);
   > person.greeting(); // 输出：Hello, I'm John and I'm 30 years old.
   > ```
   >
   > 在这个示例中，构造函数  `Person`  返回一个自定义对象，其中包含一个  `greeting`  方法。当通过  `new Person("John", 30)`  创建实例时，返回的对象成为实例，并且可以调用  `greeting`  方法。   需要注意的是，当构造函数返回自定义对象时，原本构造函数中的其他属性和方法将被忽略，因为返回的对象将完全替代实例。因此，构造函数返回自定义对象可能会改变实例的行为和结构。

4. 使用 `this` 赋值成员方法和使用 `prototype` 声明成员方法的区别是什么？

   > 在JavaScript中，`this`和`prototype`都用于处理对象和对象方法，但它们的功能和用途是有所不同的。
   >
   > `this`关键字在JavaScript中通常指向函数运行时的上下文。在对象的方法中，`this`通常指向方法所属的对象。
   >
   > ```javascript
   > let obj = {
   >     value: 10,
   >     increment: function() {
   >         this.value++;
   >     }
   > };
   > 
   > obj.increment();
   > console.log(obj.value); // 输出：11
   > ```
   >
   > 在这个例子中，`this`在`increment`方法中指向`obj`对象，所以当我们调用`increment`方法时，`value`属性会增加。
   >
   > 而`prototype`是JavaScript中对象类型（如函数）的一个内部属性。每个对象类型都有一个原型对象，而这个原型对象包含可以被特定类型的所有实例共享的属性和方法。当试图访问一个对象的属性时，如果该对象自身没有这个属性，那么JavaScript会在这个对象的原型（也就是它的`prototype`属性）中查找这个属性，这就是原型链。
   >
   > 使用`prototype`声明成员方法，可以让所有的实例共享这个方法，而不是每个实例都有自己的方法副本。例如：
   >
   > ```javascript
   > function MyObject() {
   >     this.value = 10;
   > }
   > 
   > MyObject.prototype.increment = function() {
   >     this.value++;
   > }
   > 
   > let obj1 = new MyObject();
   > let obj2 = new MyObject();
   > 
   > obj1.increment();
   > obj2.increment();
   > 
   > console.log(obj1.value); // 输出：11
   > console.log(obj2.value); // 输出：11
   > ```
   >
   > 在这个例子中，我们创建了一个`MyObject`构造函数，并且我们在它的`prototype`上定义了`increment`方法。所以，所有的`MyObject`实例（如`obj1`和`obj2`）都可以访问这个共享的方法。注意这个方法不会影响原型链，它只改变调用这个方法的对象。

5. 请自学js中实现继承的方法，并说说js实现继承的本质是什么？

   > JavaScript 中的继承是通过原型链实现的。每个对象都有一个指向它的原型（prototype）的链接，当试图访问一个对象的属性时，如果该对象内部不存在这个属性，那么 JavaScript 就会在对象的原型上寻找这个属性，这就是原型链。
   >
   > 实现继承的一种基本方法是使用 `Object.create()` 方法，它创建一个新对象，使用现有的对象作为新创建对象的`__proto__`。

6. 常见的设计模式有哪些？请说出至少5个

   > - 工厂模式
   > - 单例模式
   > - 模块模式
   > - 代理模式
   > - 职责链模式
   > - 命令模式

## 代码题

1. 请实现`BackTop` 这个类，实现点击回到顶部的效果，外部只需要使用如下调用方式即可。

   ```javascript
   var ele = $(".back-top")
   new BackTop(ele);
   ```

   ```javascript
   function BackTop($node){
       var timeId;
       $node.addEventListener('click',function(){
           window.scrollTo(0,0);
       })
       window.onscroll = function(){
           clearTimeout(timeId)
           timeId = setTimeout(function(){
               var T = $(window).scrollTop();
               var H = $(window).height();
               if(T > H*0.5){
                   $node.addClass("show")
               } else{
                   $node.removeClass("show")
               }
           },100)
       }
   }
   ```

   

2. 请手动实现 instanceOf(obj,Clazz) 函数，其行为和js元素提供的 `obj instanceof Clazz`一致

   在JavaScript中，`obj instanceof Clazz` 是一个用于检查 `obj` 是否是 `Clazz` 类的实例的表达式。如果 `obj` 是 `Clazz` 的实例，或者是 `Clazz` 的子类的实例，那么这个表达式会返回 `true`。

   ```javascript
   function instanceOf(obj, Clazz) {
     if (typeof Clazz !== 'function') {
       throw new TypeError(Clazz '必须是函数');
     }
   
     if (typeof obj !== 'object' || obj === null) {
       return false;
     }
   
     let proto = Object.getPrototypeOf(obj);
     while (proto !== null) {
       if (proto === Clazz.prototype) {
         return true;
       }
       proto = Object.getPrototypeOf(proto);
     }
   
     return false;
   }
   ```

   

3. 请动手实现工厂模式

   ```javascript
   // 定义一个工厂函数
   function createProduct(type) {
     if (type === 'A') {
       return new ProductA();
     } else if (type === 'B') {
       return new ProductB();
     } else {
       throw new Error('Invalid product type.');
     }
   }
   
   // 定义产品A的构造函数
   function ProductA() {
     this.type = 'A';
     this.operation = function() {
       console.log('This is product A.');
     };
   }
   
   // 定义产品B的构造函数
   function ProductB() {
     this.type = 'B';
     this.operation = function() {
       console.log('This is product B.');
     };
   }
   
   // 使用工厂函数创建产品实例
   var product1 = createProduct('A');
   var product2 = createProduct('B');
   
   // 调用产品实例的方法
   product1.operation(); // 输出：This is product A.
   product2.operation(); // 输出：This is product B.
   ```

   

4. 请动手实现单例模式

   ```javascript
   var Singleton = (function() {
     var instance; // Private instance variable
   
     function createInstance() {
       // Private method to create the Singleton instance
       var object = new Object("I am the Singleton instance");
       return object;
     }
   
     return {
       getInstance: function() {
         // Public method to get the Singleton instance
         if (!instance) {
           instance = createInstance();
         }
         return instance;
       }
     };
   })();
   
   // Usage:
   var singleton1 = Singleton.getInstance();
   var singleton2 = Singleton.getInstance();
   
   console.log(singleton1 === singleton2); // Output: true
   
   ```

   

5. 请自学js中实现继承的方法，并实现如下的类的继承关系：人和狗都继承自动物类，动物类有吃和睡两个方法，人和狗对吃和睡都有自己的实现。

   ```javascript
   // 动物类
   function Animal(name) {
       this.name = name;
   }
   
   // 动物类的方法
   Animal.prototype.eat = function() {
       console.log(this.name + " is eating.");
   };
   
   Animal.prototype.sleep = function() {
       console.log(this.name + " is sleeping.");
   };
   
   // 人类
   function Person(name) {
       Animal.call(this, name);  // 调用父类（动物）的构造函数
   }
   
   // 人类继承动物
   Person.prototype = Object.create(Animal.prototype);
   Person.prototype.constructor = Person;
   
   // 人类的方法
   Person.prototype.eat = function() {
       console.log(this.name + " is eating.");
       // 可以在此处添加人类特有的吃的方法逻辑
   };
   
   Person.prototype.sleep = function() {
       console.log(this.name + " is sleeping.");
       // 可以在此处添加人类特有的睡的方法逻辑
   };
   
   // 狗类
   function Dog(name) {
       Animal.call(this, name);  // 调用父类（动物）的构造函数
   }
   
   // 狗类继承动物
   Dog.prototype = Object.create(Animal.prototype);
   Dog.prototype.constructor = Dog;
   
   // 狗的方法
   Dog.prototype.eat = function() {
       console.log(this.name + " is eating.");
       // 可以在此处添加狗特有的吃的方法逻辑
   };
   
   Dog.prototype.sleep = function() {
       console.log(this.name + " is sleeping.");
       // 可以在此处添加狗特有的睡的方法逻辑
   };
   ```

   