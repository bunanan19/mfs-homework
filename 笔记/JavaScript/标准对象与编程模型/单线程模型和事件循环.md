# 单线程模型和事件循环

## 定时器

首先要先讲解下定时器，js中的定时器有两种： setTimeout() 和 setInterval()

### setTimeout()

> setTimeout(code,millisec)

|   参数   | 解释                                             |
| :------: | :----------------------------------------------- |
|   code   | 必需。要调用的函数后要执行的 JavaScript 代码串。 |
| millisec | 必需。在执行代码前需等待的毫秒数。               |

return 定时器 id，可以通过 clearTimeout(id) 取消定时器任务

> 注意：code可以为function或者string

setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。

```js
var id = setTimeout(function(){
    console.log('console.log("10秒后打印")')
},10*1000)
// clearTimeout(id)
```

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012105655468.png" alt="image-20231012105655468" style="zoom:80%;" />

### setInterval()  [ˈɪntərvl]

> setInterval(code,millisec)

|   参数   | 解释                                             |
| :------: | :----------------------------------------------- |
|   code   | 必需。要调用的函数后要执行的 JavaScript 代码串。 |
| millisec | 必需。在执行代码前需等待的毫秒数。               |

return 定时器 id，可以通过 clearInterval(id) 取消定时器任务

> 注意：code可以为function或者string

setInterval() 方法用于在指定的毫秒数后调用函数或计算表达式。

```js
var id = setInterval(function(){
    console.log('console.log("10秒后打印")')
},10*1000)
// clearInterval(id)
```

### 使用setTimeout()实现setInterval()

```js
function mySetInterval(fun,millisec){
    setTimeout(function(){
        fun();
        mySetInterval(fun,millisec)
    },millisec);
}

这段代码是一个JavaScript函数，名为mySetInterval。这个函数接受两个参数，一个是要重复执行的函数fun，另一个是时间间隔millisec。

这个mySetInterval函数的工作原理如下：

setTimeout函数被调用，传入的参数是一个匿名函数和millisec指定的时间间隔。
当给定的时间间隔过去后，匿名函数被调用。
在匿名函数内部，调用传入的fun函数。
调用匿名函数后，递归调用mySetInterval(fun, millisec)。这会导致上述步骤的重复，因此fun函数会每millisec毫秒被调用一次，形成了一个循环。
需要注意的是，这个实现与标准的setInterval函数有所不同。标准的setInterval函数在给定的时间间隔后就会立即调用函数，而这个mySetInterval函数是在给定的时间间隔结束时才第一次调用函数。也就是说，这个函数有一个初始的延迟。
```

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012121443173.png" alt="image-20231012121443173" style="zoom:80%;" />

## 单线程模型

JavaScript是单线程的，同一时刻只能执行特定的任务。

> 进程和线程都是操作系统的概念。进程是应用程序的执行实例，每一个进程都是由私有的虚拟地址空间、代码、数据和其它系统资源所组成；进程在运行过程中能够申请创建和使用系统资源（如独立的内存区域等），这些资源也会随着进程的终止而被销毁。而线程则是进程内的一个独立执行单元，在不同的线程之间是可以共享进程资源的，所以在多线程的情况下，需要特别注意对临界资源的访问控制。在系统创建进程之后就开始启动执行进程的主线程，而进程的生命周期和这个主线程的生命周期一致，主线程的退出也就意味着进程的终止和销毁。主线程是由系统进程所创建的，同时用户也可以自主创建其它线程，这一系列的线程都会并发地运行于同一个进程中。
>
> <img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012122420792.png" alt="image-20231012122420792" style="zoom:80%;" />
>
> <img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012123722386.png" alt="image-20231012123722386" style="zoom:80%;" />
>
> <img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012123911142.png" alt="image-20231012123911142" style="zoom:80%;" />

但是我们经常看到如下代码

```js
foo.onclick = function(e) {
    //...
};
bar.onclick = function(e) {
    //...
};
```

思考：当foo和bar被点击的时候，为什么会执行 function 里的代码？

> 在JavaScript中，当你点击一个元素（如`foo`和`bar`）时，消息队列里面就push了该事件，单线程处理机调度线程任务，触发该元素的"click"事件。在上面的代码中，`foo`和`bar`分别被分配了一个事件处理函数，这两个函数会在对应的元素被点击时被触发。
>
> 当一个事件（如点击、按键、鼠标移动等）被触发时，浏览器会执行与该事件关联的事件处理函数。
>
> 这种事件处理是JavaScript中常见的模式，用于响应用户的交互。事件处理是单线程的，也就是说，当一个事件处理函数正在执行时，其他所有的JavaScript代码（包括其他事件处理函数）都会等待它完成。如果一个事件处理函数需要很长时间来执行，它可能会阻止用户交互，因此，通常需要确保事件处理函数快速且高效。

### 从一道面试题说起

```js
var t = true;

setTimeout(function (){
    t = false;
},1000);

while (t){}

alert('end');

这段代码会产生死循环的原因是因为 while 循环的条件 while (t){} 中的 t 始终为 true 。在JavaScript中， setTimeout 函数是异步的，它会在指定的时间后将回调函数添加到事件队列中。而 while 循环会一直执行，不会给事件队列处理的机会，因此 setTimeout 的回调函数无法执行，导致 t 的值无法被修改为 false ，从而造成了死循环。
```

输出是什么那？不少同学会不假思索的说1s后alert('end')。其实不然，执行这行代码会一直死循环。原因是js是单线程模型，setTimeout()是通过事件循环实现的。

### 事件循环

js中使用事件循环机制，实现并发（注意不是并行）**并发是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。并行是指一组程序按独立异步的速度执行，不等于时间上的重叠（同一个时刻发生）**。



js的事件循环是通过队列（先进先出）实现的，让我先了解下什么是队列

#### 队列

栈是FIFO（先进先出）的数据结构



##### js实现

```js
names = [];
names.push("Cynthia");
names.push("Jennifer");

names.shift();

names.push("foo");
names.push("bar");

names.shift();
```

把所有的push和shift放在一起并*不影响结果*

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011215704679.png" alt="image-20231011215704679" style="zoom:80%;" />

##### js中的应用

事件循环机制

![img](http://fe-base.books.mafengshe.com/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/Javascript/images/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png)

#### 栈

栈是FILO（先进后出）的数据结构 ![img](http://fe-base.books.mafengshe.com/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/Javascript/images/stack.jpg)

##### js实现

```js
names = [];
names.push("Cynthia");
names.push("Jennifer");

names.pop();

names.push("foo");
names.push("bar");

names.pop();
```

push和pop调换顺序会*影响结果*

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011215839311.png" alt="image-20231011215839311" style="zoom:80%;" />

##### js中的应用

函数调用栈

错误处理

```js
function a(){
    b();
}
function b(){
    c();
}
function c(){
    //抛出异常
    throw new Error("throw this")
}
c();
```

### 定时器是准确的吗？

执行下面代码

```js
var start = new Date;
setInterval(function(){
    var end = new Date;
    console.log('Time elapsed:', end - start, 'ms');
    start = end;
}, 500);
```

打印出来的 Time elapsed 会发现不是精确的500ms，可能是499ms，也可能是501ms。

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011220105744.png" alt="image-20231011220105744" style="zoom: 67%;" />

这好像看不出来js的定时器的不准确的规律。我们可以将代码改进一下，发现其规律

```js
var start = new Date;
setInterval(function(){
    var end = new Date;
    console.log('Time elapsed:', end - start, 'ms');
	// start = end;
}, 500);
```

这次我们打印的是从开始执行到当前时间的总时间差，我们可以发现定时器其实总是延后触发的。和事件循环这一机制匹配

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011220439124.png" alt="image-20231011220439124" style="zoom:67%;" />

让我们再执行下一段代码

```js
var start = new Date;
var count = 0;
setInterval(function(){
    var end = new Date;
    console.log('Time elapsed:', end - start, 'ms');
    start = end;
    count++;
    if(count === 2){
        for(var i = 0; i < 1990000000; i++);
    }
}, 500);
```

这次第三次打印的 Time elapsed 有了显著变化

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011220742074.png" alt="image-20231011220742074" style="zoom:67%;" />

再换种写法试试

```js
var start = new Date;
setInterval(function(){
    var end = new Date;
    console.log('Time elapsed:', end - start, 'ms');
    start = end;
}, 500);
for(var i = 0; i < 1990000000; i++);
```

这次是第一次打印的 Time elapsed 有了显著变化

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011220941318.png" alt="image-20231011220941318" style="zoom:67%;" />

### 我们自己实现的 mySetInterval() 和系统提供的 setInterval()行为一致吗？

- id会不断改变，不利于取消
- 事件处理函数内用时过长会影响下一次定时器触发时间

大家可以自行运行下面两段代码对比其中差异

```js
var start = new Date;
setInterval(function(){
    var end = new Date;
    console.log('Time elapsed:', end - start, 'ms');
    start = end;
    for(var i = 0; i < 10000*10000; i++);
},1000)
//时间出现误差，会尽可能修正

var start = new Date;
mySetInterval(function(){
    var end = new Date;
    console.log('Time elapsed:', end - start, 'ms');
    start = end;
    for(var i = 0; i < 10000*10000; i++);
},1000)
//差距时间出现的误差较大，而且一直累积，不会修正
```

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011221100427.png" alt="image-20231011221100427" style="zoom:67%;" /><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011221301544.png" alt="image-20231011221301544" style="zoom:67%;" />



## 问答题

1. setTimeout 或者 setInterval 设置定时器是准时触发的吗？为什么？如果不是，他可能延时触发还是延后触发？

   > 不是准时触发，因为一般会延迟触发，因为执行`var time=new Date()`需要时间，获取date也需要时间。它们的内在运行机制决定了时间间隔参数实际上只是指定了把代码添加到浏览器 UI 线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那定时器中的代码代码就要等前面的任务完成后再执行

2. 如下代码 setInterval 设置的定时器激活间隔为多少？为什么？

   ```js
   setInterval(function(){
     for(var i=0;i<1000*1000*1000;i++);//假设这行代码运行需要100ms
   },1000)
   ```

   > 1000ms,setInterval会修正误差。

3. 如下代码的输出是什么？为什么？

   ```js
   setTimeout(function(){
     console.log(1);
   },0)
   console.log(2);
   ```

   > 先是2，后打印1。
   >
   > 这是因为 JavaScript 使用事件循环来处理异步任务。当代码执行时， `console.log(2)`  语句会同步执行，并立即将  `2`  打印到控制台。   然后， `setTimeout`  函数以 0 毫秒的延迟被调用。即使延迟设置为 0，回调函数 ( `console.log(1)` ) 仍然被视为异步任务，并被添加到事件队列中。   一旦同步任务完成，JavaScript 事件循环将检查事件队列中是否有待处理的任务。在这种情况下，它会找到  `console.log(1)`  任务并执行它，将  `1`  打印到控制台。   因此，输出将是  `2` ，然后是  `1` 。

4. 如下代码执行结果是什么？请解释原因

   ```js
   var t = true;
   
   window.setTimeout(function (){
      t = false;
   },1000);
   while (t){}
   alert('end');
   ```

   > 陷入死循环，因为 while 循环的条件 while (t){} 中的 t 始终为 true 。在JavaScript中， setTimeout 函数是异步的，它会在指定的时间后将回调函数添加到事件队列中。而 while 循环会一直执行，不会给事件队列处理的机会，因此 setTimeout 的回调函数无法执行，导致 t 的值无法被修改为 false ，从而造成了死循环。

5. 我们会在很多代码里看到如下语句，请说明在什么场景下需要使用如下形式代码

   ```js
   setTimeout(function(){
     // balala
     // 这里有很多代码
     // balala
   },0)
   ```

   > 在很多代码中使用  `setTimeout`  函数并将延迟设置为 0 的场景是为了将一段代码放入事件队列中，并在当前任务完成后立即执行。尽管延迟设置为 0，但这个回调函数仍然被视为异步任务。   这种用法通常在以下情况下使用：   1. 异步执行：当需要将一段代码推迟到当前任务完成后执行，而不是立即执行时，可以使用  `setTimeout`  函数将代码放入事件队列中。   2. 避免阻塞：当有大量计算密集型或耗时的操作时，将这些操作放在  `setTimeout`  的回调函数中可以避免阻塞主线程，使页面保持响应。   3. 事件顺序控制：在某些情况下，需要确保某个任务在当前任务完成后执行，但在其他事件处理程序之前执行。通过将代码放入  `setTimeout`  的回调函数中，并将延迟设置为 0，可以确保在事件队列中的适当位置执行。   需要注意的是，尽管延迟设置为 0，但回调函数仍然是异步执行的，它会在当前任务完成后尽快执行，但不会立即执行。这样可以确保其他异步任务和事件处理程序优先执行，避免阻塞主线程。



## 代码题

1. 请用 setTimeout 模拟实现 setInterval，并说明你实现的函数和系统自带的 setInterval 有什么不同

   ```javascript
    var start = new Date();
   function mySetInterval(fun, millisec) {
       setTimeout(function() {
           fun();
           mySetInterval(fun, millisec);
       }, millisec);
   }
   
   function time() {
       var end = new Date();
       console.log(end - start);
   }
   
   mySetInterval(time, 1000);
   
   ```
   
   ```javascript
   var start = new Date;
   setInterval(function(){
       var end = new Date;
       console.log(end - start);
   
   }, 1000);
   ```
   
   
   
   <img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012143605204.png" alt="image-20231012143605204" style="zoom:80%;" /><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231012143717361.png" alt="image-20231012143717361" style="zoom:80%;" />

自己定义的函数误差总是延迟，而且误差很大，还会一直累积，而且自定义的函数返回的id一直会改变。系统的定时器函数误差小，出现误差后会一直修正误差，不会累积，id值是定值，方便清除定时器。