# 单线程模型和事件循环

## 定时器

首先要先讲解下定时器，js中的定时器有两种： setTimeout() 和 setInterval()

### setTimeout()

> setTimeout(code,millisec)

|   参数   | 解释                                             |
| :------: | :----------------------------------------------- |
|   code   | 必需。要调用的函数后要执行的 JavaScript 代码串。 |
| millisec | 必需。在执行代码前需等待的毫秒数。               |

return 定时器 id，可以通过 clearTimeout(id) 取消定时器任务

> 注意：code可以为function或者string

setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。

```js
var id = setTimeout(function(){
    console.log('console.log("10秒后打印")')
},10*1000)
// clearTimeout(id)
```

### setInterval()

> setInterval(code,millisec)

|   参数   | 解释                                             |
| :------: | :----------------------------------------------- |
|   code   | 必需。要调用的函数后要执行的 JavaScript 代码串。 |
| millisec | 必需。在执行代码前需等待的毫秒数。               |

return 定时器 id，可以通过 clearInterval(id) 取消定时器任务

> 注意：code可以为function或者string

setInterval() 方法用于在指定的毫秒数后调用函数或计算表达式。

```js
var id = setInterval(function(){
    console.log('console.log("10秒后打印")')
},10*1000)
// clearInterval(id)
```

### 使用setTimeout()实现setInterval()

```js
function mySetInterval(fun,millisec){
    setTimeout(function(){
        fun();
        mySetInterval(fun,millisec)
    },millisec);
}
这段代码是一个JavaScript函数，名为mySetInterval。这个函数接受两个参数，一个是要重复执行的函数fun，另一个是时间间隔millisec。

这个mySetInterval函数的工作原理如下：

setTimeout函数被调用，传入的参数是一个匿名函数和millisec指定的时间间隔。
当给定的时间间隔过去后，匿名函数被调用。
在匿名函数内部，调用传入的fun函数。
调用匿名函数后，递归调用mySetInterval(fun, millisec)。这会导致上述步骤的重复，因此fun函数会每millisec毫秒被调用一次，形成了一个循环。
需要注意的是，这个实现与标准的setInterval函数有所不同。标准的setInterval函数在给定的时间间隔后就会立即调用函数，而这个mySetInterval函数是在给定的时间间隔结束时才第一次调用函数。也就是说，这个函数有一个初始的延迟。
```

## 单线程模型

JavaScript是单线程的，同一时刻只能执行特定的任务。

> 进程和线程都是操作系统的概念。进程是应用程序的执行实例，每一个进程都是由私有的虚拟地址空间、代码、数据和其它系统资源所组成；进程在运行过程中能够申请创建和使用系统资源（如独立的内存区域等），这些资源也会随着进程的终止而被销毁。而线程则是进程内的一个独立执行单元，在不同的线程之间是可以共享进程资源的，所以在多线程的情况下，需要特别注意对临界资源的访问控制。在系统创建进程之后就开始启动执行进程的主线程，而进程的生命周期和这个主线程的生命周期一致，主线程的退出也就意味着进程的终止和销毁。主线程是由系统进程所创建的，同时用户也可以自主创建其它线程，这一系列的线程都会并发地运行于同一个进程中。

但是我们经常看到如下代码

```js
foo.onclick = function(e) {
    //...
};
bar.onclick = function(e) {
    //...
};
```

思考：当foo和bar被点击的时候，为什么会执行 function 里的代码？

### 从一道面试题说起

```js
var t = true;

setTimeout(function (){
    t = false;
},1000);

while (t){}

alert('end');

代码会无限循环，因为变量 t 在 while 循环中被设置为 true，然后你设置了一个定时器，1秒（1000毫秒）后将 t 设置为 false。但是，这个定时器并不会立即终止 while 循环。当定时器时间到达后，t 被设为 false，但是由于 while 循环的执行并非立即重算循环条件，而是要等到本次循环执行完毕后才会进行，所以本次 while 循环并不会立即终止。
```

输出是什么那？不少同学会不假思索的说1s后alert('end')。其实不然，执行这行代码会一直死循环。原因是js是单线程模型，setTimeout()是通过事件循环实现的。

### 事件循环

js中使用事件循环机制，实现并发（注意不是并行）**并发是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。并行是指一组程序按独立异步的速度执行，不等于时间上的重叠（同一个时刻发生）**。

![img](http://fe-base.books.mafengshe.com/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/Javascript/images/%E5%B9%B6%E5%8F%91%EF%BC%9F%E5%B9%B6%E8%A1%8C%EF%BC%9F.jpg)

js的事件循环是通过队列实现的，让我先了解下什么是队列

#### 队列

栈是FIFO（先进先出）的数据结构

![img](http://fe-base.books.mafengshe.com/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/Javascript/images/queue.jpg)

##### js实现

```js
names = [];
names.push("Cynthia");
names.push("Jennifer");

names.shift();

names.push("foo");
names.push("bar");

names.shift();
```

把所有的push和shift放在一起并*不影响结果*

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011215704679.png" alt="image-20231011215704679" style="zoom:80%;" />

##### js中的应用

事件循环机制

![img](http://fe-base.books.mafengshe.com/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/Javascript/images/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png)

#### 栈

栈是FILO（先进后出）的数据结构 ![img](http://fe-base.books.mafengshe.com/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/Javascript/images/stack.jpg)

##### js实现

```js
names = [];
names.push("Cynthia");
names.push("Jennifer");

names.pop();

names.push("foo");
names.push("bar");

names.pop();
```

push和pop调换顺序会*影响结果*

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011215839311.png" alt="image-20231011215839311" style="zoom:80%;" />

##### js中的应用

函数调用栈

错误处理

```js
function a(){
    b();
}
function b(){
    c();
}
function c(){
    //抛出异常
    throw new Error("throw this")
}
c();
```

### 定时器是准确的吗？

执行下面代码

```js
var start = new Date;
setInterval(function(){
    var end = new Date;
    console.log('Time elapsed:', end - start, 'ms');
    start = end;
}, 500);
```

打印出来的 Time elapsed 会发现不是精确的500ms，可能是499ms，也可能是501ms。

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011220105744.png" alt="image-20231011220105744" style="zoom: 67%;" />

这好像看不出来js的定时器的不准确的规律。我们可以将代码改进一下，发现其规律

```js
var start = new Date;
setInterval(function(){
    var end = new Date;
    console.log('Time elapsed:', end - start, 'ms');
	// start = end;
}, 500);
```

这次我们打印的是从开始执行到当前时间的总时间差，我们可以发现定时器其实总是延后触发的。和事件循环这一机制匹配

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011220439124.png" alt="image-20231011220439124" style="zoom:67%;" />

让我们再执行下一段代码

```js
var start = new Date;
var count = 0;
setInterval(function(){
    var end = new Date;
    console.log('Time elapsed:', end - start, 'ms');
    start = end;
    count++;
    if(count === 2){
        for(var i = 0; i < 1990000000; i++);
    }
}, 500);
```

这次第三次打印的 Time elapsed 有了显著变化

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011220742074.png" alt="image-20231011220742074" style="zoom:67%;" />

再换种写法试试

```js
var start = new Date;
setInterval(function(){
    var end = new Date;
    console.log('Time elapsed:', end - start, 'ms');
    start = end;
}, 500);
for(var i = 0; i < 1990000000; i++);
```

这次是第一次打印的 Time elapsed 有了显著变化

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011220941318.png" alt="image-20231011220941318" style="zoom:67%;" />

### 我们自己实现的 mySetInterval() 和系统提供的 setInterval()行为一致吗？

- id会不断改变，不利于取消
- 事件处理函数内用时过长会影响下一次定时器触发时间

大家可以自行运行下面两段代码对比其中差异

```js
var start = new Date;
setInterval(function(){
    var end = new Date;
    console.log('Time elapsed:', end - start, 'ms');
    start = end;
    for(var i = 0; i < 10000*10000; i++);
},1000)


var start = new Date;
mySetInterval(function(){
    var end = new Date;
    console.log('Time elapsed:', end - start, 'ms');
    start = end;
    for(var i = 0; i < 10000*10000; i++);
},1000)
```

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011221100427.png" alt="image-20231011221100427" style="zoom:67%;" /><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231011221301544.png" alt="image-20231011221301544" style="zoom:67%;" />



## 问答题

1. setTimeout 或者 setInterval 设置定时器是准时触发的吗？为什么？如果不是，他可能延时触发还是延后触发？

   > 不是准时触发，因为一般会延迟触发，因为执行`var time=new Date()`需要时间，获取date也需要时间。

2. 如下代码 setInterval 设置的定时器激活间隔为多少？为什么？

   ```js
   setInterval(function(){
     for(var i=0;i<1000*1000*1000;i++);//假设这行代码运行需要100ms
   },1000)
   ```

   > 1100ms,

3. 如下代码的输出是什么？为什么？

   ```js
   setTimeout(function(){
     console.log(1);
   },0)
   console.log(2);
   ```

   > 先是2，后打印1

4. 如下代码执行结果是什么？请解释原因

   ```js
   var t = true;
   
   window.setTimeout(function (){
      t = false;
   },1000);
   while (t){}
   alert('end');
   ```

   > 陷入死循环，while中的t值一直为true，即使1秒后t赋值为false，但是while循环传入的t值只会在while循环更新计算，while循环外部的更新不会再传入循环中

5. 我们会在很多代码里看到如下语句，请说明在什么场景下需要使用如下形式代码

   ```js
   setTimeout(function(){
     // balala
     // 这里有很多代码
     // balala
   },0)
   ```

   > 需要异步执行，



## 代码题

1. 请用 setTimeout 模拟实现 setInterval，并说明你实现的函数和系统自带的 setInterval 有什么不同

   ```javascript
   ```

   