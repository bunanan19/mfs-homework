## 变量的解构（模式匹配pattern match）赋值 

### 数组的解构赋值 

基本用法 ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，只能直接指定值。

```js
var a = 1;
var b = 2;
var c = 3;
```

ES6允许写成下面这样。

```js
var [a, b, c] = [1, 2, 3];
```

上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进 行解构的例子。

```js
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3
let [ , , third] = ["foo", "bar", "baz"];
third // "baz"
let [x, , y] = [1, 2, 3];
x // 1
y // 3
let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]
let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []
```

如果解构不成功，变量的值就等于 undefined 。

```js
var [foo] = [];
var [bar, foo] = [1];
```

以上两种情况都属于解构不成功， foo 的值都会等于 undefined 。 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功

```js
let [x, y] = [1, 2, 3];
x // 1
y // 2
let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
```

上面两个例子，都属于不完全解构，但是可以成功。 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。

```js
// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
```

上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备 Iterator接口（最后一个表达式）。 解构赋值不仅适用于var命令，也适用于let和const命令。

```js
var [v1, v2, ..., vN ] = array;
let [v1, v2, ..., vN ] = array;
const [v1, v2, ..., vN ] = array;
```

对于Set结构，也可以使用数组的解构赋值。

```js
let [x, y, z] = new Set(["a", "b", "c"]);
x // "a"
```

事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。

```js
function* fibs() {
var a = 0;
var b = 1;
while (true) {
yield a;
[a, b] = [b, a + b];
}
}
var [first, second, third, fourth, fifth, sixth] = fibs();
sixth // 5
```

上面代码中， fibs 是一个Generator函数，原生具有Iterator接口。解构赋值会依次从这个接口获取值。



### 默认值

解构赋值允许指定默认值。

```js
var [foo = true] = [];
foo // true
[x, y = 'b'] = ['a']; // x='a', y='b'
[x, y = 'b'] = ['a', undefined]; // x='a', y='b'
```

注意，ES6内部使用严格相等运算符（ === ），判断一个位置是否有值。所以，如果一个数组成员不严格等于 undefined ， 默认值是不会生效的。

```js
var [x = 1] = [undefined];
x // 1
var [x = 1] = [null];
x // null
```

上面代码中，如果一个数组成员是 null ，默认值就不会生效，因为 null 不严格等于 undefined 。 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。

```js
function f() {
console.log('aaa');
}
let [x = f()] = [1];
```

上面代码中，因为 x 能取到值，所以函数 f 根本不会执行。上面的代码其实等价于下面的代码

```js
let x;
if ([1][0] === undefined) {
x = f();
} else {
x = [1][0];
}
```

默认值可以引用解构赋值的其他变量，但该变量必须已经声明。

```js
let [x = 1, y = x] = []; // x=1; y=1
let [x = 1, y = x] = [2]; // x=2; y=2
let [x = 1, y = x] = [1, 2]; // x=1; y=2
let [x = y, y = 1] = []; // ReferenceError
```

上面最后一个表达式之所以会报错，是因为 x 用到默认值 y 时， y 还没有声明。

### 对象的解构赋值

iterator：迭代器（数组与对象的本质差别）

```js
var { foo, bar } = { foo: "aaa", bar: "bbb" };
foo // "aaa"
bar // "bbb"
```

对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变 量必须与属性同名，才能取到正确的值。

```js
var { bar, foo } = { foo: "aaa", bar: "bbb" };
foo // "aaa"
bar // "bbb"
var { baz } = { foo: "aaa", bar: "bbb" };
baz // undefined
```

上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第 二个例子的变量没有对应的同名属性，导致取不到值，最后等于 undefined 。 如果变量名与属性名不一致，必须写成下面这样。

```js
var { foo: baz } = { foo: "aaa", bar: "bbb" };
baz // "aaa"
let obj = { first: 'hello', last: 'world' };
let { first: f, last: l } = obj;
f // 'hello'
l // 'world'
```

这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）

```js
var { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" };
```

也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者

```js
var { foo: baz } = { foo: "aaa", bar: "bbb" };
baz // "aaa"
foo // error: foo is not defined
```

上面代码中，真正被赋值的是变量 baz ，而不是模式 foo 。 注意，采用这种写法时，变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明 过，就会报错。

```ja
let foo;
let {foo} = {foo: 1}; // SyntaxError: Duplicate declaration "foo"
let baz;
let {bar: baz} = {bar: 1}; // SyntaxError: Duplicate declaration "baz"
```

上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为 var 命令允许重新声明，所以这个错误只会在使 用 let 和 const 命令时出现。如果没有第二个let命令，上面的代码就不会报错。

```js
let foo;
({foo} = {foo: 1}); // 成功
let baz;
({bar: baz} = {bar: 1}); // 成功
```

和数组一样，解构也可以用于嵌套结构的对象。

```js
var obj = {
p: [
"Hello",
{ y: "World" }
]
};
var { p: [x, { y }] } = obj;
x // "Hello"
y // "World"
```

注意，这时 p 是模式，不是变量，因此不会被赋值。

```js
var node = {
loc: {
start: {
line: 1,
column: 5
}
}
};
var { loc: { start: { line }} } = node;
line // 1
loc // error: loc is undefined
start // error: start is undefined
```

上面代码中，只有 line 是变量， loc 和 start 都是模式，不会被赋值。 下面是嵌套赋值的例子。

```js
let obj = {};
let arr = [];
({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });
obj // {prop:123}
```

对象的解构也可以指定默认值。

```js
var {x = 3} = {};
x // 3
var {x, y = 5} = {x: 1};
x // 1
y // 5
var { message: msg = "Something went wrong" } = {};
msg // "Something went wrong"
```

默认值生效的条件是，对象的属性值严格等于 undefined 。

```js
var {x = 3} = {x: undefined};
x // 3
var {x = 3} = {x: null};
x // null
```

上面代码中，如果 x 属性等于 null ，就不严格相等于 undefined ，导致默认值不会生效。 如果解构失败，变量的值等于 undefined 。

```js
var {foo} = {bar: 'baz'};
foo // undefined
```

如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。

```js
// 报错
var {foo: {bar}} = {baz: 'baz'}
```

上面代码中，等号左边对象的 foo 属性，对应一个子对象。该子对象的 bar 属性，解构时会报错。原因很简单，因 为 foo 这时等于 undefined ，再取子属性就会报错，请看下面的代码。

```js
var _tmp = {baz: 'baz'};
_tmp.foo.bar // 报错
```

如果要将一个已经声明的变量用于解构赋值，必须非常小心。

```js
// 错误的写法
var x;
{x} = {x: 1};
// SyntaxError: syntax error
```

上面代码的写法会报错，因为JavaScript引擎会将 {x} 理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避 免JavaScript将其解释为代码块，才能解决这个问题。

```js
// 正确的写法
({x} = {x: 1});
```

上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。 解构赋值允许，等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。

```js
({} = [true, false]);
({} = 'abc');
({} = []);
```

上面的表达式虽然毫无意义，但是语法是合法的，可以执行。 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。

```js
let { log, sin, cos } = Math;
```

上面代码将 Math 对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。

### 字符串的解构赋值 

字符串也可以解构赋值。字符串是可以迭代的这是因为此时，字符串被转换成了一个类似数组的对象。

```js
 const [a, b, c, d, e] = 'hello'; 
a // "h" 
b // "e" 
c // "l" 
d // "l" 
e // "o" 
```

类似数组的对象都有一个 length 属性，因此还可以对这个属性解构赋值。 

```js
let {length : len} = 'hello'; 
len // 5
```

### 数值和布尔值的解构赋值 

解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。

```js
let {toString: s} = 123;
s === Number.prototype.toString // true
let {toString: s} = true;
s === Boolean.prototype.toString // true
```

上面代码中，数值和布尔值的包装对象都有 toString 属性，因此变量 s 都能取到值。 解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于 undefined 和 null 无法转为对象，所以对它们 进行解构赋值，都会报错。

```js
let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError
```

### 函数参数的解构赋值 

函数的参数也可以使用解构赋值。

```js
function add([x, y]){
return x + y;
}
add([1, 2]); // 3
```

上面代码中，函数 add 的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量 x 和 y 。对于函数内 部的代码来说，它们能感受到的参数就是 x 和 y 。 下面是另一个例子。

```js
[[1, 2], [3, 4]].map(([a, b]) => a + b);
// [ 3, 7 ]
```

函数参数的解构也可以使用默认值。

```js
function move({x = 0, y = 0} = {}) {
return [x, y];
}
move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
```

上面代码中，函数 move 的参数是一个对象，通过对这个对象进行解构，得到变量 x 和 y 的值。如果解构失 败， x 和 y 等于默认值。 注意，下面的写法会得到不一样的结果。

```js
function move({x, y} = { x: 0, y: 0 }) {
return [x, y];
}
move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, undefined]
move({}); // [undefined, undefined]
move(); // [0, 0]
```

上面代码是为函数 move 的参数指定默认值，而不是为变量 x 和 y 指定默认值，所以会得到与前一种写法不同的结果。 undefined 就会触发函数参数的默认值。

```js
[1, undefined, 3].map((x = 'yes') => x);
// [ 1, 'yes', 3 ]
```

 ### Generator 函数(多了一个*)

```js
function* gen(){
    console.log("--a--")
    yield 1
    console.log("--b--")
    yield 2
    console.log("--c--")
    yield 3
}
```

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231027220657239.png" alt="image-20231027220657239" style="zoom:80%;" />

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231027221201035.png" alt="image-20231027221201035" style="zoom:80%;" />

像断点调试

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231028190011794.png" alt="image-20231028190011794" style="zoom:80%;" />

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231028190028218.png" alt="image-20231028190028218" style="zoom:80%;" />

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231028190047592.png" alt="image-20231028190047592" style="zoom:80%;" />

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231028190104118.png" alt="image-20231028190104118" style="zoom:80%;" />

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231028190114980.png" alt="image-20231028190114980" style="zoom:80%;" />





## 问答题

1. 什么是解构？解构本质是什么？

   > ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。解构的本质是模式匹配

2. 什么是解构默认值？怎样使用？

   > 解构默认值是在解构赋值过程中为变量设置默认值的一种方式。当解构的源值为  `undefined`  或  `null`  时，可以使用解构默认值来为变量提供一个备选值。   解构默认值的使用方式如下：
   >
   > ```js
   > const { prop = defaultValue } = object;
   > ```
   >
   > 上述代码中， `prop`  是要解构的属性， `defaultValue`  是备选值。如果  `object`  中的  `prop`  属性的值为  `undefined`  ，则  `prop`  变量将被赋值为  `defaultValue` 。   以下是一个示例：
   >
   > ```js
   > const person = {
   >   name: 'Alice',
   >   age: 25,
   > };
   > 
   > const { name, gender = 'unknown' } = person;
   > console.log(name);   // 输出：Alice
   > console.log(gender); // 输出：unknown
   > ```
   >
   > 在上述示例中， `person`  对象中没有  `gender`  属性，因此在解构赋值过程中， `gender`  变量的默认值被设置为  `'unknown'` 。这样，即使  `person`  对象中没有  `gender`  属性，也能保证  `gender`  变量有一个默认值。   需要注意的是，当源值不是  `undefined`  或  `null`  时，解构默认值不会生效。只有当源值为  `undefined`  或  `null`  时(另一种说法，null不严格等于undefined，值源为null解构默认值不会生效)，才会使用解构默认值。
   >
   > <img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231027203759116.png" alt="image-20231027203759116" style="zoom:80%;" />
   >
   > <img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231027220944178.png" alt="image-20231027220944178" style="zoom:80%;" />

3. 下面代码执行会报错吗？为什么？

   ```javascript
   let foo;
   let {foo} = {foo: 1};
   ```

   > 是的，这段代码会报错。因为同时使用 `let` 关键字和对象解构语法声明变量 `foo` ，这样会造成冲突，因为在同一个作用域中不能重新声明了变量 `foo` 。 
   >
   > <img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231027203914350.png" alt="image-20231027203914350" style="zoom:80%;" />

4. 下面代码执行结果是什么？会报错吗？

   ```javascript
   const {"0": a,"1": b} = ["foo", "bar"];
   ```

   > 这段代码将成功执行，不会报错。   
   >
   > 这段代码使用数组解构将数组 `["foo", "bar"]` 的值分配给常量 `a` 和 `b` 。在这种情况下， `"foo"` 将分配给 `a` ， `"bar"` 将分配给 `b` 。   
   >
   > 因此，代码执行后，变量 `a` 的值为 `"foo"` ，变量 `b` 的值为 `"bar"` 。
   >
   > <img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231028184903033.png" alt="image-20231028184903033" style="zoom:80%;" />

5. 下面代码声明了几个变量？值是多少？

   ```javascript
   let { a: { b: { c }}} = { a: { b: { c: "1",d: "2"}}}
   ```

   >这段代码声明了1个变量： `c` 。变量 `c` 的值是字符串  `"1"` 。
   >
   ><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231028185027117.png" alt="image-20231028185027117" style="zoom:80%;" />
   
6. 数组解构的核心是什么？请自学 Generator 函数 回答下面代码返回什么

   ```javascript
   function* count() {
      let i = 1
      while (true) {
         yield i++;
      }
   }
   
   let [first, second, third, fourth, fifth, sixth] = count();
   ```

   >数组解构的核心是通过模式匹配将数组中的元素赋值给变量。解构赋值的模式与数组的结构相对应，可以将数组中的元素按照指定的顺序分配给变量。   
   >
   >对于给定的代码，使用了生成器函数 `count()` 来创建一个无限递增的计数器。通过 `yield` 关键字，每次调用生成器的 `next()` 方法时，都会返回一个递增的值。   
   >
   >在解构赋值的语句中，将生成器函数 `count()` 的返回值按照顺序分配给变量 `first` 、 `second` 、 `third` 、 `fourth` 、 `fifth` 和 `sixth` 。   
   >
   >根据生成器函数的递增逻辑，解构赋值将依次分配生成器函数返回的值给变量。因此，变量 `first` 将被赋值为1， `second` 将被赋值为2， `third` 将被赋值为3，以此类推。   所以，代码的执行结果将是：  `first` 的值为1，  `second` 的值为2，  `third` 的值为3，  `fourth` 的值为4，  `fifth` 的值为5，  `sixth` 的值为6。
   >
   ><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231028185117617.png" alt="image-20231028185117617" style="zoom:80%;" />

7. 字符串可以解构吗？结合下面代码说说为什么？

   ```javascript
   const [a, b, c, d, e] = 'hello';
   ```

   > 字符串可以进行解构，但与数组的解构方式略有不同。   
   >
   > 在给定的代码中，使用数组解构的方式将字符串 `'hello'` 解构为变量 `a` 、 `b` 、 `c` 、 `d` 和 `e` 。这里的解构过程实际上是将字符串看作一个类似数组的可迭代对象。   解构过程会将字符串的每个字符作为一个元素，按照顺序分配给相应的变量。
   >
   > 因此，变量 `a` 将被赋值为字符 `'h'` ，变量 `b` 将被赋值为字符 `'e'` ，变量 `c` 将被赋值为字符 `'l'` ，变量 `d` 将被赋值为字符 `'l'` ，变量 `e` 将被赋值为字符 `'o'` 。   
   >
   > 所以，代码的执行结果将是：  `a` 的值为字符 `'h'` ，  `b` 的值为字符 `'e'` ，  `c` 的值为字符 `'l'` ，  `d` 的值为字符 `'l'` ，  `e` 的值为字符 `'o'` 。   
   >
   > 因此，字符串可以通过解构的方式进行分解，并将每个字符分配给相应的变量。

## 代码题

1. 请使用解构语法实现交换两个数

   ```js
   let a = 10;
   let b = 20;
   
   [a, b] = [b, a];
   
   console.log(a); // Output: 20
   console.log(b); // Output: 10
   ```

2. 请使用解构语法实现获取斐波那契数列前10个数

   ```js
   function fibonacci() {
    let f = [];
    f[0]=1;
    f[1]=1;
    for (let i = 2; i < 10; i++) {
         f[i] = f[i - 1] + f[i - 2];
    }
    return f;
   }
   let [a,b,c,d,e,f,g,h,i,j] = fibonacci();//解构赋值
   console.log(a, b, c, d, e, f, g, h, i, j);
   ```
   
   将斐波那契数列的前10个数字存储在一个数组 `f` 中。然后，通过解构赋值的方式，将数组中的每个元素分配给对应的变量 。 这样，我们可以通过分别访问这些变量来获取斐波那契数列的前10个数字。

3. 对于单参数函数，如果通过解构语法设置默认值，修改代码实现默认值

   ```
   b = 10
   ```

   ```javascript
   function test({a,b}){
      console.log(a,b)
   }
   ```

   要为单参数函数设置默认值，可以使用解构语法和默认参数值的组合来实现。根据提供的代码，我们可以将默认值 `b` 设置为 `10` 。   修改后的代码如下所示：

   ```js
   function test({ a, b = 10 } = {}) {
     console.log(a, b);
   }
   
   test({a:1,b:2});//1 2
   test({a:1}); //1 10
   test({});//undefined 10
   tset();//undefined 10
   ```

   <img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231027205603273.png" alt="image-20231027205603273" style="zoom:80%;" />

   在这段代码中，我们使用解构语法将函数的参数解构为对象，并为参数对象的属性 `b` 设置默认值为 `10` 。   这样，当调用 `test` 函数时，如果传入的参数对象中没有属性 `b` ，或者 `b` 的值为 `undefined` ，则参数 `b` 将使用默认值 `10` 。   通过这种方式，我们可以在函数内部使用默认值，以防止在调用函数时未提供相应的属性或属性值。



结构可以将多参数转成想要的单参数，可以实现值交换，将函数返回值格式规定为自定义，



> 解构在编程中有着广泛的应用实际意义。下面列举了一些解构的实际应用场景：   
>
> 1. 提取对象或数组的值：使用解构可以轻松地从对象或数组中提取特定的值，并将其分配给变量。这样可以方便地访问对象或数组中的属性或元素。   
>
> 2. 函数参数解构：解构可以用于函数参数中，允许以更直观和简洁的方式传递参数。通过解构函数参数，可以避免在函数体内部进行属性或元素的提取操作。   
>
> 3.  交换变量值：使用解构可以轻松交换两个变量的值，无需使用额外的临时变量。   
>
> 4. 函数返回值解构：解构可以用于从函数返回的对象或数组中提取所需的值。这样可以使函数返回的数据更加结构化和易于使用。   
>
> 5. 减少冗余代码：通过解构，可以将重复的属性或元素提取代码减少到最少，提高代码的可读性和可维护性。   
>
> 6. 多个返回值处理：当函数返回多个值时，可以使用解构将这些值分配给不同的变量，更方便地处理和使用这些返回值。   
>
> 7. 参数默认值：解构还可以与默认值结合使用，为解构的变量提供默认值，以处理未定义或空值的情况。   
>
>    总的来说，解构在简化代码、提高可读性、减少冗余和方便数据提取等方面具有实际意义，可以使代码更加简洁和优雅。