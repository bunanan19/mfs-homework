异步编程对JavaScript语言太重要。Javascript语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。

 ES6诞生以前，异步编程的方法，大概有下面四种。 

+ 回调函数 
+ 事件监听 
+ 发布/订阅 
+ Promise 对象 

ES6将JavaScript异步编程带入了一个全新的阶段，ES7的 Async 函数更是提出了异步编程的终极解决方案。

## 基本概念

### 异步

所谓"异步"，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。 比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等 到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。 相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能 干等着。

### 回调函数

> 回调函数（Callback）是一种常见的编程概念，用于处理异步操作和事件处理。在编程中，回调函数是指在某个操作完成或事件发生后，通过将函数作为参数传递给其他函数来执行的函数。   回调函数通常用于以下情况：  1. 异步操作：当需要执行一个耗时的操作时，可以将回调函数传递给该操作，以便在操作完成后执行特定的逻辑。  2. 事件处理：当某个事件发生时，可以将回调函数传递给事件处理程序，以便在事件触发后执行相应的操作。   使用回调函数的一个常见示例是处理异步请求。例如，在网络请求中，可以将回调函数传递给异步函数，以便在请求完成后处理返回的数据。   以下是一个简单的JavaScript示例，展示了回调函数的使用：
>
> ```js
> function fetchData(callback) {
>   // 模拟异步请求
>   setTimeout(function() {
>     const data = "这是从服务器返回的数据";
>     callback(data);
>   }, 2000);
> }
> 
> function processData(data) {
>   console.log("处理数据:", data);
> }
> 
> fetchData(processData); // 将 processData 函数作为回调函数传递给 fetchData 函数
> ```
>
> 在这个示例中， `fetchData` 函数模拟了一个异步请求，通过 `setTimeout` 函数模拟了2秒的延迟。在请求完成后，通过调用回调函数 `callback` 并传递返回的数据来处理数据。 `processData` 函数作为回调函数被传递给 `fetchData` 函数，以便在请求完成后执行特定的数据处理逻辑。   回调函数是一种灵活和常见的编程模式，用于处理异步操作和事件处理。它允许在操作完成后执行特定的逻辑，并且可以让代码更具可读性和可维护性。

JavaScript语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行 这个任务的时候，就直接调用这个函数。它的英语名字callback，直译过来就是"重新调用"。 读取文件进行处理，是这样写的。

```js
fs.readFile('/etc/passwd', function (err, data) {
    if (err) throw err;
    console.log(data);
});
```

上面代码中，readFile函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了 /etc/passwd 这个文件 以后，回调函数才会执行。 一个有趣的问题是，为什么Node.js约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？原 因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。

在Node.js中，回调（callback）是一种常见的编程模式，用于处理异步操作。当你在Node.js中执行一个异步操作时，你通常会提供一个回调函数作为参数。这个回调函数将在异步操作完成时被调用，以处理操作的结果。回调函数通常具有一些参数，以便你可以访问异步操作的结果。这些参数通常包括错误状态（如果有的话）以及与操作相关的数据或结果。下面是一个使用回调的简单示例，展示了如何读取一个文件并打印其内容：

```js
const fs = require('fs');
fs.readFile('example.txt', 'utf8', (err, data) => {  
    if (err) {    
        console.error('Error reading file:', err);  
    } else {    
        console.log('File contents:', data);  
    }
});
```

在这个示例中，`fs.readFile`函数是一个异步操作，它读取一个文件并返回其内容。我们提供了一个回调函数作为参数，该回调函数接收两个参数：`err`和`data`。`err`参数用于传递错误状态（如果有的话），而`data`参数用于传递文件的内容。当文件读取完成时，回调函数会被调用，并使用读取的文件内容更新控制台输出。如果发生错误，它将打印错误消息。否则，它将打印文件的内容。

### Promise

回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。

```js
fs.readFile(fileA, function (err, data) {
	fs.readFile(fileB, function (err, data) {
		// ...
	});
});
```

不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。 这种情况就称为"回调函数噩梦"（callback hell）。 Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加 载。采用Promise，连续读取多个文件，写法如下。

```js
var readFile = require('fs-readfile-promise');
	readFile(fileA)
	.then(function(data){
		console.log(data.toString());
	})
	.then(function(){
		return readFile(fileB);
	})
	.then(function(data){
		console.log(data.toString());
	})
	.catch(function(err) {
		console.log(err);
});
```

上面代码中，我使用了fs-readfile-promise模块，它的作用就是返回一个Promise版本的readFile函数。Promise提供then方法加载回 调函数，catch方法捕捉执行过程中抛出的错误。 可以看到，Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新 意。 Promise 的最大问题是代码冗余，原来的任务被Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得 很不清楚。 那么，有没有更好的写法呢？

### Generator函数

#### 协程

传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做"协程"（coroutine），意思是多个线程互相协作，完成异步任务。

协程有点像函数，又有点像线程。它的运行流程大致如下。

+ 第一步，协程A开始执行。 
+ 第二步，协程A执行到一半，进入暂停，执行权转移到协程B。 
+ 第三步，（一段时间后）协程B交还执行权。 
+ 第四步，协程A恢复执行。

上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。 举例来说，读取文件的协程写法如下。

```js
function *asnycJob() {
	 // ...其他代码
 	var f = yield readFile(fileA);
 	// ...其他代码
}
```

上面代码的函数 asyncJob 是一个协程，它的奥妙就在其中的 yield 命令。它表示执行到此处，执行权将交给其他协程。也 就是说， yield 命令是异步两个阶段的分界线。 协程遇到 yield 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步 操作，如果去除yield命令，简直一模一样。

## Generator函数的概念

Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权（即暂停执行）。 整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。 Generator函数的执行方法如下。

```js
function* gen(x){
	var y = yield x + 2;
	return y;
}
var g = gen(1);
g.next() // { value: 3, done: false }返回第一个yield表达式后面的值
g.next() // { value: undefined, done: true }第二次调用g.next()时不传入参数，那么上一个yield 表达式语句的返回值将为undefined，y便为undefined。value值应该为y的值，此时为undefined。 如果你在第二次调用  g.next() 时传入参数，比如 g.next(1)，那么这个参数会成为上一个yield语句的返回值，并且被赋值给变量 y 。也就是说， y 的值将是1，value值也会为1。 

function *fib(){
    let [prev, curr] = [0, 1]
    yield prev
    while(true){
        [prev, curr] = [curr, prev + curr]
        let t = yield curr
        if(t =="end"){
            break
        }
    }
    return "gen end"//return  语句用于指定生成器函数的最终返回值。 
}
var fi =fib()
fi.next('end')//{value: "gen end", done: true}end参数将传给上一次的yield语句，t为yield语句的值，t为end，当t为end时，循环结束，执行return，返回值为vlue值
```

上面代码中，调用Generator函数，会返回一个内部指针（即遍历器）g 。这是Generator函数不同于普通函数的另一个地方，即 执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个 遇到的yield语句，上例是执行到 x + 2 为止。 换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和 done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示Generator函数是否执行 完毕，即是否还有下一个阶段。

## Generator函数的数据交换和错误处理

Generator函数可以**暂停执行和恢复执行**，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步 编程的完整解决方案：**函数体内外的数据交换**和**错误处理机制**。 next方法返回值的value属性，是Generator函数向外输出数据；next方法还可以接受参数，这是向Generator函数体内输入数据。

```js
function* gen(x){
	var y = yield x + 2;
	return y;
}
var g = gen(1);
g.next() // { value: 3, done: false }
g.next(2) // { value: 2, done: true }
```

上面代码中，第一个next方法的value属性，返回表达式 x + 2 的值（3）。第二个next方法带有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收。因此，这一步的 value 属性，返回的就是2（变 量y的值）。 Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。

```js
function* gen(x){
	try {
		var y = yield x + 2;
	} catch (e){
		console.log(e);
	}
	return y;
}
var g = gen(1);
g.next();
//{value: 3, done: false}
g.throw('出错了');
// 出错了
//{value: undefined, done: true}
```

上面代码的最后一行，Generator函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try ...catch代码块捕获。 这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。

## 异步任务的封装

下面看看如何使用 Generator 函数，执行一个真实的异步任务。

```js
var fetch = require('node-fetch');
function* gen(){
	var url = 'https://api.github.com/users/github';
	var result = yield fetch(url);
	console.log(result.bio);
}
```

上面代码中，Generator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。就像前面说 过的，这段代码非常像同步操作，除了加上了yield命令。 执行这段代码的方法如下

```js
var g = gen();
var result = g.next();
result.value.then(function(data){
	return data.json();
}).then(function(data){
	g.next(data);
});
```

上面代码中，首先执行Generator函数，获取遍历器对象，然后使用next 方法（第二行），执行异步任务的第一阶段。由于Fetch 模块返回的是一个Promise对象，因此要用then方法调用下一个next 方法。 可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶 段）。

## Thunk函数

## 参数的求值策略

Thunk函数早在上个世纪60年代就诞生了。 那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是"求值策略"，即函数的参数到底应该何时求值。

```js
var x = 1;
function f(m){
	return m * 2;
}
f(x + 5)
```

上面代码先定义函数f，然后向它传入表达式 x + 5 。请问，这个表达式应该何时求值？ 一种意见是"传值调用"（call by value），即在进入函数体之前，就计算 x + 5 的值（等于6），再将这个值传入函数f 。C语言 就采用这种策略。

```js
f(x + 5)
// 传值调用时，等同于
f(6)
```

另一种意见是"传名调用"（call by name），即直接将表达式 x + 5 传入函数体，只在用到它的时候求值。Haskell语言采用这种 策略。

```js
f(x + 5)
// 传名调用时，等同于
(x + 5) * 2
```

传值调用和传名调用，哪一种比较好？回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参 数，有可能造成性能损失。

```js
function f(a, b){
	return b;
}
f(3 * x * x - 2 * x - 1, x);
```

上面代码中，函数f的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因 此，有一些计算机学家倾向于"传名调用"，即只在执行时求值。 

## Thunk函数的含义 

编译器的"传名调用"实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做Thunk函 数。

```js
function f(m){
	return m * 2;
}
f(x + 5);
// 等同于
var thunk = function () {
	return x + 5;
};
function f(thunk){
	return thunk() * 2;
}
```

上面代码中，函数f的参数 x + 5 被一个函数替换了。凡是用到原参数的地方，对 Thunk 函数求值即可。 这就是Thunk函数 的定义，它是"传名调用"的一种实现策略，用来替换某个表达式。 

## JavaScript语言的Thunk函数

 JavaScript语言是传值调用，它的Thunk函数含义有所不同。在JavaScript语言中，Thunk函数替换的不是表达式，而是多参数函 数，将其替换成单参数的版本，且只接受回调函数作为参数。

```js
// 正常版本的readFile（多参数版本）
fs.readFile(fileName, callback);
// Thunk版本的readFile（单参数版本）
var readFileThunk = Thunk(fileName);
readFileThunk(callback);
var Thunk = function (fileName){
	return function (callback){
		return fs.readFile(fileName, callback);
	};
};
```

上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单 参数函数，只接受回调函数作为参数。这个单参数版本，就叫做Thunk函数。 任何函数，只要参数有回调函数，就能写成Thunk函数的形式。下面是一个简单的Thunk函数转换器。

```js
var Thunk = function(fn){
	return function (){
		var args = Array.prototype.slice.call(arguments);
		return function (callback){
			args.push(callback);
			return fn.apply(this, args);
		}
	};
};
```

使用上面的转换器，生成 fs.readFile 的Thunk函数。

```js
var readFileThunk = Thunk(fs.readFile);
readFileThunk(fileA)(callback);
```

## Thunkify模块 

生产环境的转换器，建议使用Thunkify模块。 首先是安装。

```js
$ npm install thunkify
```

```js
var thunkify = require('thunkify');
var fs = require('fs');
var read = thunkify(fs.readFile);
read('package.json')(function(err, str){
// ...
});
```

Thunkify的源码与上一节那个简单的转换器非常像

```js
function thunkify(fn){
	return function(){
		var args = new Array(arguments.length);
		var ctx = this;
		for(var i = 0; i < args.length; ++i) {
			args[i] = arguments[i];
		}
		return function(done){
			var called;
			args.push(function(){
				if (called) return;
				called = true;
				done.apply(null, arguments);
			});
            try {
                fn.apply(ctx, args);
            } catch (err) {
                done(err);
            }
        }
    }
};
```

它的源码主要多了一个检查机制，变量 called 确保回调函数只运行一次。这样的设计与下文的Generator函数相关。请看下面 的例子。

```js
function f(a, b, callback){
	var sum = a + b;
	callback(sum);
	callback(sum);
}
var ft = thunkify(f);
var print = console.log.bind(console);
ft(1, 2)(print);
// 3
```

上面代码中，由于 thunkify 只允许回调函数执行一次，所以只输出一行结果。 

## Generator 函数的流程管理 

你可能会问， Thunk函数有什么用？回答是以前确实没什么用，但是ES6有了Generator函数，Thunk函数现在可以用于Generator 函数的自动流程管理。 以读取文件为例。下面的Generator函数封装了两个异步操作。

```js
var fs = require('fs');
var thunkify = require('thunkify');
var readFile = thunkify(fs.readFile);
var gen = function* (){
	var r1 = yield readFile('/etc/fstab');
	console.log(r1.toString());
	var r2 = yield readFile('/etc/shells');
	console.log(r2.toString());
};
```

上面代码中，yield命令用于将程序的执行权移出Generator函数，那么就需要一种方法，将执行权再交还给Generator函数。 这种方法就是Thunk函数，因为它可以在回调函数里，将执行权交还给Generator函数。为了便于理解，我们先看如何手动执行 上面这个Generator函数。

```js
var g = gen();
var r1 = g.next();
r1.value(function(err, data){
	if (err) throw err;
	var r2 = g.next(data);
	r2.value(function(err, data){
		if (err) throw err;
		g.next(data);
	});
});
```

上面代码中，变量g是Generator函数的内部指针，表示目前执行到哪一步。next方法负责将指针移动到下一步，并返回该步的信 息（value属性和done属性）。 仔细查看上面的代码，可以发现Generator函数的执行过程，其实是将同一个回调函数，反复传入next方法的value属性。这使得 我们可以用递归来自动完成这个过程。

## Thunk函数的自动流程管理 

Thunk函数真正的威力，在于可以自动执行Generator函数。下面就是一个基于Thunk函数的Generator执行器。

```js
function run(fn) {
	var gen = fn();
	function next(err, data) {
		var result = gen.next(data);
		if (result.done) return;
		result.value(next);
	}
	next();
}
run(gen);
```

上面代码的run函数，就是一个Generator函数的自动执行器。内部的next函数就是Thunk的回调函数。next函数先将指针移到 Generator函数的下一步（gen.next方法），然后判断Generator函数是否结束（result.done 属性），如果没结束，就将next函数再 传入Thunk函数（result.value属性），否则就直接退出。 有了这个执行器，执行Generator函数方便多了。不管有多少个异步操作，直接传入 run 函数即可。当然，前提是每一个异步 操作，都要是Thunk函数，也就是说，跟在 yield 命令后面的必须是Thunk函数。

```js
var gen = function* (){
	var f1 = yield readFile('fileA');
	var f2 = yield readFile('fileB');
    // ...
	var fn = yield readFile('fileN');
};
run(gen);
```

上面代码中，函数 gen 封装了 n 个异步的读取文件操作，只要执行 run 函数，这些操作就会自动完成。这样一来，异步操 作不仅可以写得像同步操作，而且一行代码就可以执行。 Thunk函数并不是Generator函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制Generator函数的流 程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。

## co模块

## 基本用法

co模块是著名程序员TJ Holowaychuk于2013年6月发布的一个小工具，用于Generator函数的自动执行。 比如，有一个Generator函数，用于依次读取两个文件。

```js
var gen = function* (){
var f1 = yield readFile('/etc/fstab');
var f2 = yield readFile('/etc/shells');
console.log(f1.toString());
console.log(f2.toString());
};
```

co模块可以让你不用编写Generator函数的执行器。

```js
var co = require('co');
co(gen);
```

上面代码中，Generator函数只要传入co函数，就会自动执行。 co函数返回一个Promise对象，因此可以用then方法添加回调函数。

```js
co(gen).then(function (){
console.log('Generator 函数执行完成');
})
```

上面代码中，等到Generator函数执行结束，就会输出一行提示。

## co模块的原理 

为什么co可以自动执行Generator函数？ 

前面说过，Generator就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。 两种方法可以做到这一点。 

（1）回调函数。将异步操作包装成Thunk函数，在回调函数里面交回执行权。 

（2）Promise 对象。将异步操作包装成Promise对象，用then方法交回执行权。 co模块其实就是将两种自动执行器（Thunk函数和Promise对象），包装成一个模块。使用co的前提条件是，Generator函数的 yield命令后面，只能是Thunk函数或Promise对象。 上一节已经介绍了基于Thunk函数的自动执行器。下面来看，基于Promise对象的自动执行器。这是理解co模块必须的。 

## 基于Promise对象的自动执行 

还是沿用上面的例子。首先，把fs模块的readFile方法包装成一个Promise对象。

```js
var fs = require('fs');
var readFile = function (fileName){
	return new Promise(function (resolve, reject){
		fs.readFile(fileName, function(error, data){
		if (error) reject(error);
			resolve(data);
		});
	});
};
var gen = function* (){
	var f1 = yield readFile('/etc/fstab');
	var f2 = yield readFile('/etc/shells');
	console.log(f1.toString());
	console.log(f2.toString());
};
```

然后，手动执行上面的Generator函数。

```js
var g = gen();
g.next().value.then(function(data){
    g.next(data).value.then(function(data){
        g.next(data);
    });
})
```

手动执行其实就是用then方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。

```js
function run(gen){
	var g = gen();
	function next(data){
		var result = g.next(data);
		if (result.done) return result.value;
		result.value.then(function(data){
			next(data);
		});
	}
	next();
}
run(gen);
```

上面代码中，只要Generator函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。 

## co模块的源码 

co就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。 首先，co函数接受Generator函数作为参数，返回一个 Promise 对象。

```js
function co(gen) {
	var ctx = this;
	return new Promise(function(resolve, reject) {
	});
}
```

在返回的Promise对象里面，co先检查参数gen是否为Generator函数。如果是，就执行该函数，得到一个内部指针对象；如果不是 就返回，并将Promise对象的状态改为resolved。

```js
function co(gen) {
	var ctx = this;
	return new Promise(function(resolve, reject) {
		if (typeof gen === 'function') gen = gen.call(ctx);
		if (!gen || typeof gen.next !== 'function') return resolve(gen);
	});
}
```

接着，co将Generator函数的内部指针对象的next方法，包装成onFulfilled函数。这主要是为了能够捕捉抛出的错误。

```js
function co(gen) {
	var ctx = this;
	return new Promise(function(resolve, reject) {
		if (typeof gen === 'function') gen = gen.call(ctx);
		if (!gen || typeof gen.next !== 'function') return resolve(gen);
		onFulfilled();
		function onFulfilled(res) {
			var ret;
			try {
				ret = gen.next(res);
			} catch (e) {
				return reject(e);
			}
			next(ret);
		}
	});
}
```

最后，就是关键的next函数，它会反复调用自身。

```js
function next(ret) {
	if (ret.done) return resolve(ret.value);
	var value = toPromise.call(ctx, ret.value);
	if (value && isPromise(value)) return value.then(onFulfilled, onRejected);
	return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '
+ 'but the following object was passed: "' + String(ret.value) + '"'));
}
```

上面代码中，next 函数的内部代码，一共只有四行命令。 第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。 第二行，确保每一步的返回值，是 Promise 对象。 第三行，使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数。 第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 rejected，从而终止执 行。 

## 处理并发的异步操作 

co支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。 这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面。

```js
// 数组的写法
co(function* () {
	var res = yield [
		Promise.resolve(1),
		Promise.resolve(2)
	];
	console.log(res);
}).catch(onerror);
// 对象的写法
co(function* () {
	var res = yield {
		1: Promise.resolve(1),
		2: Promise.resolve(2),
	};
	console.log(res);
}).catch(onerror);
```

下面是另一个例子。

```js
co(function* () {
	var values = [n1, n2, n3];
	yield values.map(somethingAsync);
});
function* somethingAsync(x) {
	// do something async
	return y
}
```

上面的代码允许并发三个 somethingAsync 异步操作，等到它们全部完成，才会进行下一步。

## async函数

ES7提供了 async 函数，使得异步操作变得更加方便。 async 函数是什么？一句话， async 函数就是Generator函数的语法 糖。 前文有一个Generator函数，依次读取两个文件。

```js
var fs = require('fs');
var readFile = function (fileName){
	return new Promise(function (resolve, reject){
		fs.readFile(fileName, function(error, data){
			if (error) reject(error);
			resolve(data);
		});
	});
};
var gen = function* (){
var f1 = yield readFile('/etc/fstab');
var f2 = yield readFile('/etc/shells');
console.log(f1.toString());
console.log(f2.toString());
};
```

写成 async 函数，就是下面这样。

```js
var asyncReadFile = async function (){
    var f1 = await readFile('/etc/fstab');
	var f2 = await readFile('/etc/shells');
	console.log(f1.toString());
	console.log(f2.toString());
};
```

一比较就会发现， async 函数就是将Generator函数的星号（ * ）替换成 async ，将 yield 替换成 await ，仅此而已。 async 函数对 Generator 函数的改进，体现在以下四点。 

（1）内置执行器。Generator函数的执行必须靠执行器，所以才有了 co 模块，而 async 函数自带执行器。也就是 说， async 函数的执行，与普通函数一模一样，只要一行。

```js
var result = asyncReadFile();
```

上面的代码调用了 asyncReadFile 函数，然后它就会自动执行，输出最后结果。这完全不像Generator函数，需要调 用 next 方法，或者用 co 模块，才能得到真正执行，得到最后结果。 

（2）更好的语义。 async 和 await ，比起星号和 yield ，语义更清楚了。 async 表示函数里有异步操作， await 表 示紧跟在后面的表达式需要等待结果。 

（3）更广的适用性。 co 模块约定， yield 命令后面只能是Thunk函数或Promise对象，而 async 函数的 await 命令后 面，可以是Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 

（4）返回值是Promise。 async 函数的返回值是Promise对象，这比Generator函数的返回值是Iterator对象方便多了。你可以 用 then 方法指定下一步的操作。 进一步说， async 函数完全可以看作多个异步操作，包装成的一个Promise对象，而 await 命令就是内部 then 命令的语法 糖。

 正常情况下， await 命令后面是一个Promise对象，否则会被转成Promise。 下面是一个完整的例子。

```js
async function getTitle(url) {
	let response = await fetch(url);
	let html = await response.text();
	return html.match(/<title>([\s\S]+)<\/title>/i)[1];
}
getTitle('https://tc39.github.io/ecma262/').then(console.log)
// "ECMAScript 2017 Language Specification"
```

## async函数的实现

async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里

```js
async function fn(args){
	// ...
}
// 等同于
function fn(args){
	return spawn(function*() {
	// ...
	});
}
```

所有的 async 函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。 下面给出 spawn 函数的实现，基本就是前文自动执行器的翻版。

```js
function spawn(genF) {
	return new Promise(function(resolve, reject) {
	var gen = genF();
	function step(nextF) {
		try {
			var next = nextF();
		} catch(e) {
			return reject(e);
		}
    	if(next.done) {
        	return resolve(next.value);
    	}
        Promise.resolve(next.value).then(function(v) {
            step(function() { return gen.next(v); });
        }, function(e) {
            step(function() { return gen.throw(e); });
        });
    }
    step(function() { return gen.next(undefined); });
    });
}
```

async 函数是非常新的语法功能，新到都不属于 ES6，而是属于 ES7。目前，它仍处于提案阶段，但是转码 器 Babel 和 regenerator 都已经支持，转码后就能使用。

## async 函数的用法

同Generator函数一样， async 函数返回一个Promise对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇 到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。 下面是一个例子。

```js
async function getStockPriceByName(name) {
	var symbol = await getStockSymbol(name);
	var stockPrice = await getStockPrice(symbol);
	return stockPrice;
}
getStockPriceByName('goog').then(function (result) {
	console.log(result);
});
```

上面代码是一个获取股票报价的函数，函数前面的 async 关键字，表明该函数内部有异步操作。调用该函数时，会立即返回 一个 Promise 对象。 下面的例子，指定多少毫秒后输出一个值。

```js
function timeout(ms) {
	return new Promise((resolve) => {
		setTimeout(resolve, ms);
	});
}
async function asyncPrint(value, ms) {
	await timeout(ms);
	console.log(value)
}
asyncPrint('hello world', 50);
```

上面代码指定50毫秒以后，输出"hello world"。 Async函数有多种使用形式。

```js
// 函数声明
async function foo() {}
// 函数表达式
const foo = async function () {};
// 对象的方法
let obj = { async foo() {} }
// 箭头函数
const foo = async () => {};
```

## 注意点

 第一点， await 命令后面的Promise对象，运行结果可能是rejected，所以最好把 await 命令放在 try...catch 代码块中。

```js
async function myFunction() {
	try {
		await somethingThatReturnsAPromise();
	} catch (err) {
		console.log(err);
	}
}
// 另一种写法
async function myFunction() {
	await somethingThatReturnsAPromise().catch(function (err){
		console.log(err);
	};
}
```

第二点，多个 await 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。

```js
let foo = await getFoo();
let bar = await getBar();
```

上面代码中， getFoo 和 getBar 是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只 有 getFoo 完成以后，才会执行 getBar ，完全可以让它们同时触发。

```js
// 写法一
let [foo, bar] = await Promise.all([getFoo(), getBar()]);
// 写法二
let fooPromise = getFoo();
let barPromise = getBar();
let foo = await fooPromise;
let bar = await barPromise;
```

上面两种写法， getFoo 和 getBar 都是同时触发，这样就会缩短程序的执行时间。 第三点， await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。

```js
async function dbFuc(db) {
	let docs = [{}, {}, {}];
	// 报错
	docs.forEach(function (doc) {
		await db.post(doc);
	});
}
```

上面代码会报错，因为await用在普通函数之中了。但是，如果将 forEach 方法的参数改成 async 函数，也有问题。

```js
async function dbFuc(db) {
	let docs = [{}, {}, {}];
	// 可能得到错误结果
	docs.forEach(async function (doc) {
		await db.post(doc);
	});
}
```

上面代码可能不会正常工作，原因是这时三个 db.post 操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法 是采用 for 循环。

```js
async function dbFuc(db) {
	let docs = [{}, {}, {}];
	for (let doc of docs) {
		await db.post(doc);
	}
}
```

如果确实希望多个请求并发执行，可以使用 Promise.all 方法

```js
async function dbFuc(db) {
	let docs = [{}, {}, {}];
	let promises = docs.map((doc) => db.post(doc));
	let results = await Promise.all(promises);
	console.log(results);
}
// 或者使用下面的写法
async function dbFuc(db) {
	let docs = [{}, {}, {}];
	let promises = docs.map((doc) => db.post(doc));
	let results = [];
	for (let promise of promises) {
		results.push(await promise);
	}
	console.log(results);
}
```

ES6将 await 增加为保留字。使用这个词作为标识符，在ES5是合法的，在ES6将抛出SyntaxError。

## 与Promise、Generator的比较

我们通过一个例子，来看Async函数与Promise、Generator函数的区别。 假定某个DOM元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执 行，返回上一个成功执行的动画的返回值。 首先是Promise的写法。

```js
function chainAnimationsPromise(elem, animations) {
	// 变量ret用来保存上一个动画的返回值
	var ret = null;
	// 新建一个空的Promise
	var p = Promise.resolve();
	// 使用then方法，添加所有动画
	for(var anim in animations) {
		p = p.then(function(val) {
			ret = val;
			return anim(elem);
		})
	}
	// 返回一个部署了错误捕捉机制的Promise
	return p.catch(function(e) {
	/* 忽略错误，继续执行 */
	}).then(function() {
		return ret;
	});
}
```

虽然Promise的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是Promise的API（then、catch等等），操作本身 的语义反而不容易看出来。 接着是Generator函数的写法。

```js
function chainAnimationsGenerator(elem, animations) {
	return spawn(function*() {
		var ret = null;
		try {
			for(var anim of animations) {
				ret = yield anim(elem);
			}
		} catch(e) {
			/* 忽略错误，继续执行 */
		}
		return ret;
	});
}
```

上面代码使用Generator函数遍历了每个动画，语义比Promise写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这 个写法的问题在于，必须有一个任务运行器，自动执行Generator函数，上面代码的spawn函数就是自动执行器，它返回一个 Promise对象，而且必须保证yield语句后面的表达式，必须返回一个Promise。 最后是Async函数的写法。

```js
async function chainAnimationsAsync(elem, animations) {
	var ret = null;
	try {
		for(var anim of animations) {
			ret = await anim(elem);
		}
	} catch(e) {
		/* 忽略错误，继续执行 */
	}
	return ret;
}
```

可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层 面提供，不暴露给用户，因此代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。



## 问答题

1. 为什么要使用 generator 函数 或者 async/await 进行异步控制流，对比 callback 和 Promise 方案，主要解决了什么问题？

   > 使用 generator 函数 或者 async/await 进行异步控制流可以避免执行多个异步操作时代码重复，以及回调地狱，太多了缩进会让代码不易读，难以管理，（并且因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和回调函数可能也会进行修改。这样就形成了“回调地狱”的问题。）
   >  虽然使用promise解决了回调函数的“回到地狱”问题，使用then方法进行链式调用，使异步任务的两个阶段看得更清楚了，但是使用promise存在代码冗余的问题，并且会有一大堆then方法，使得语义并不是很清楚。
   >  generator函数或async/await，这两个方法因为语法和普通函数语法差不多，并且使用yield,await关键字，会使得语义更加清楚。

2. generator 函数为什么能实现异步控制流？其原理是什么？

   > Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。generator 函数其中的 yield 命令表示执行到此处，执行权将交给其他协程。也 就是说， yield 命令是异步两个阶段的分界线。 协程遇到 yield 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。除此之外，它还有两个特性，使它可以作为异步 编程的完整解决方案：函数体内外的数据交换和错误处理机制。
   >
   > 生成器函数能够实现异步控制流，原因在于它们允许在特定的点暂停和恢复执行。当生成器函数遇到  `yield`  关键字时，它会暂停执行并将一个值返回给调用者。调用者可以通过调用生成器对象上的  `next()`  方法来恢复执行生成器函数。这样，在执行的暂停期间可以执行异步操作，比如等待网络请求完成。   
   >
   > - 原因： generator函数，在执行中遇到yield命令，就会暂停执行，将执行权交由另一个协程，去完成异步操作，而当之后异步操作取得结果之后，就应该交回执行权，而交回执行权这件事就需要Thunk函数来实现。因为Thunk函数参数是回调函数，那么这时我们就可以在回调函数中，当获得异步操作的结果之后，调用generator函数返回的遍历器对象的next()方法，去将执行权重新交由generator函数，继续向下执行，这样就可以实现异步控制。

3. 什么是 Thunk 函数？为什么使用 Thunk 函数可以通过和 generator 函数配合实现异步控制流？

   > 在JavaScript语言中，Thunk函数将多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。
   >
   > Thunk 函数是一种用于延迟计算或延迟执行的函数包装器。它将一个表达式封装成一个无参函数，以便在需要时延迟执行该表达式。
   >
   > Thunk 函数可以与生成器函数配合使用，以实现异步控制流。当生成器函数遇到需要执行的异步操作时，可以使用 Thunk 函数来封装该异步操作，并将其作为生成器函数的返回值。这样，在生成器函数中就可以通过调用 Thunk 函数来触发异步操作的执行。当异步操作完成时，可以通过回调函数或 Promise 的方式将结果传递给 Thunk 函数，从而恢复生成器函数的执行。
   >
   > 这种配合使用的方式，使得生成器函数可以在异步操作的执行过程中暂停和恢复，从而实现了异步控制流。Thunk 函数的作用是在生成器函数中创建一个中间层，用于处理异步操作的执行和结果传递。

4. 使用 Promise 可以配合 generator 函数实现异步控制流吗？具体原理是什么？

   > 可以，通过封装的next函数，实现自动调用generator函数的next方法，并对其value值调用，使用返回值promise对象的then方法
   >
   > 是的，Promise 可以与生成器函数配合使用来实现异步控制流。这种结合使用的技术被称为 "Generator + Promise"，它是在 ES6 中引入的。
   >
   > 具体原理如下：
   > 1. 生成器函数内部通过  `yield`  关键字暂停执行，并返回一个 Promise 对象。
   > 2. 在生成器函数外部，通过调用生成器函数的  `next()`  方法来恢复执行。这将使生成器函数继续执行到下一个  `yield`  表达式处。
   > 3. 在生成器函数内部，可以通过  `yield`  关键字等待 Promise 对象的解决（resolved）状态。
   > 4. 当 Promise 对象被解决时，可以通过调用生成器函数的  `next()`  方法，并传递解决的值，来恢复生成器函数的执行。
   > 5. 如果 Promise 对象被拒绝（rejected），可以在生成器函数内部使用  `throw()`  方法来抛出错误，然后在生成器函数外部使用  `try...catch`  来捕获错误。
   >
   > 通过这种方式，Promise 对象可以在生成器函数内部进行异步操作，并在适当的时机将结果传递给生成器函数，从而实现了异步控制流。这种结合使用的模式使得异步代码更加简洁、可读性更高，并且能够有效地处理异步操作的顺序和并发。

5. 真正发出异步操作指令是在 generator 函数外还是在 generator 函数内？（hint: 基于 Thunk 函数和基于 Promise 两种 generator 函数异步控制流，情况不一样）

   > 在基于 Thunk 函数的 Generator 函数异步控制流中，真正发出异步操作指令是在 Generator 函数外部。当 Generator 函数遇到 Thunk 函数时，它会将 Thunk 函数作为返回值返回给外部调用者，然后在外部调用者中调用该函数，从而发出异步操作指令。
   >
   > 例如，以下是一个使用 Thunk 函数的 Generator 函数示例：
   > ```js
   > function* myGenerator() {
   >   const result = yield myThunkFunction();
   >   console.log(result);
   > }
   > 
   > function myThunkFunction() {
   >   return function(callback) {
   >     setTimeout(() => {
   >       callback(null, 'Async operation completed');
   >     }, 1000);
   >   };
   > }
   > 
   > const generator = myGenerator();
   > const thunk = generator.next().value;
   > thunk((err, result) => {
   >   generator.next(result);
   > });
   > ```
   >
   > 在上面的示例中，当 Generator 函数遇到  `yield myThunkFunction()`  语句时，它会将  `myThunkFunction()`  作为返回值返回给外部调用者。然后，外部调用者调用该函数，并传递一个回调函数，从而发出异步操作指令。当异步操作完成时，回调函数被调用，将结果传递给 Generator 函数，从而恢复其执行。
   >
   > 在基于 Promise 的 Generator 函数异步控制流中，真正发出异步操作指令是在 Generator 函数内部。当 Generator 函数遇到 Promise 对象时，它会将 Promise 对象作为返回值返回给外部调用者，然后在内部等待 Promise 对象的解决状态。当 Promise 对象被解决时，Generator 函数内部会恢复执行，并将解决的值传递给下一个  `yield`  表达式。
   >
   > 例如，以下是一个使用 Promise 的 Generator 函数示例：
   > ```js
   > function* myGenerator() {
   >   const result = yield myPromiseFunction();
   >   console.log(result);
   > }
   > 
   > function myPromiseFunction() {
   >   return new Promise((resolve, reject) => {
   >     setTimeout(() => {
   >       resolve('Async operation completed');
   >     }, 1000);
   >   });
   > }
   > 
   > const generator = myGenerator();
   > const promise = generator.next().value;
   > promise.then(result => {
   >   generator.next(result);
   > });
   > ```
   >
   > 在上面的示例中，当 Generator 函数遇到  `yield myPromiseFunction()`  语句时，它会将  `myPromiseFunction()`  返回的 Promise 对象作为返回值返回给外部调用者。然后，外部调用者调用该 Promise 对象的  `then()`  方法，并在回调函数中恢复 Generator 函数的执行，从而发出异步操作指令。当 Promise 对象被解决时，回调函数被调用，将结果传递给 Generator 函数，从而恢复其执行。
   >
   > 理由是基于 Tunk 函数，在函数外才真正把异步操作需要的参数输入完全，开始执行。
   > 而 Promise 则是在 generator 函数内声明，按照特性，promise 执行器里的异步操作在 new 之后马上执行，generator函数内创建了promise对象就发出了异步操作指令。其异步操作指令是由Generator函数内的Promise的then方法发出的，因此是在Generator函数内

6. async 函数是什么？它和 generator 函数有什么关系？

   > async 函数就是Generator函数的语法糖。
   >
   >  async 函数就是将Generator函数的星号（ * ）替换成 async ，将 yield 替换成 await 。 
   >
   > async 函数对 Generator 函数的改进，体现在以下四点。 
   >
   > （1）内置执行器。Generator函数的执行必须靠执行器，所以才有了 co 模块，而 async 函数自带执行器。也就是 说， async 函数的执行，与普通函数一模一样调用; 这完全不像Generator函数，需要调 用 next 方法，或者用 co 模块，才能得到真正执行，得到最后结果。
   >
   >  （2）更好的语义。 async 和 await ，比起星号和 yield ，语义更清楚了。 async 表示函数里有异步操作， await 表 示紧跟在后面的表达式需要等待结果。 
   >
   > （3）更广的适用性。 co 模块约定， yield 命令后面只能是Thunk函数或Promise对象，而 async 函数的 await 命令后 面，可以是Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 
   >
   > （4）返回值是Promise。 async 函数的返回值是Promise对象，这比Generator函数的返回值是Iterator对象方便多了。你可以 用 then 方法指定下一步的操作。 进一步说， async 函数完全可以看作多个异步操作，包装成的一个Promise对象，而 await 命令就是内部 then 命令的语法 糖。
   >
   > 
   >
   >  `async`  函数是一种用于定义异步操作的特殊函数。它是在 ES2017 中引入的新特性。通过在函数声明或函数表达式前加上  `async`  关键字，可以将一个普通函数转换为一个异步函数。
   >
   >  `async`  函数和  `generator`  函数有一些相似之处，但也有一些关键的区别：
   > 1.  `async`  函数内部使用  `await`  关键字来暂停执行，等待一个异步操作的结果。而  `generator`  函数使用  `yield`  关键字来暂停执行，并返回一个值给调用者。
   > 2.  `async`  函数会自动将返回值包装在一个已解决（resolved）的 Promise 对象中，而  `generator`  函数需要手动使用  `Promise`  或其他方式来包装返回值。
   > 3.  `async`  函数可以使用  `try...catch`  语句来捕获和处理异步操作中的错误，而  `generator`  函数需要使用特定的错误处理机制，如回调函数或自定义的错误传递方式。
   >
   > 总的来说， `async`  函数是一种更简洁、更直观的方式来处理异步操作，而不需要像  `generator`  函数那样手动管理生成器对象和调用  `next()`  方法。它提供了一种更类似于同步代码的写法，使得异步控制流更加清晰和易于理解。

7. 在全局域或者普通函数中能使用 await 或 yield 关键字吗？为什么？

   > 不能
   >
   > 在全局域或者普通函数中不能使用  `await`  或  `yield`  关键字。这是因为这两个关键字只能在异步函数（包括  `async`  函数和带有  `*`  的生成器函数）中使用。
   >
   >  `await`  关键字用于暂停异步函数的执行，等待一个 Promise 对象的解决。它只能在异步函数内部使用，以确保正确的执行顺序和处理异步操作的结果。
   >
   >  `yield`  关键字用于生成器函数中，用于暂停函数的执行，并返回一个值给调用者。它也只能在生成器函数内部使用，以便实现生成器的迭代和控制流。
   >
   > 在全局域或普通函数中，没有定义异步执行的上下文和生成器的状态管理机制，因此无法使用  `await`  或  `yield`  关键字。如果需要在这些上下文中处理异步操作，可以使用其他方式，如回调函数、Promise 链式调用或  `async`  函数的返回值处理。

8. 直接调用 `async` 函数的返回值类型是什么？为什么？

   > promise对象
   >
   > 直接调用  `async`  函数的返回值类型是一个 Promise 对象。这是因为  `async`  函数内部使用  `await`  关键字来暂停执行，并等待一个异步操作的结果。当  `async`  函数被调用时，它会立即返回一个已解决的（resolved）Promise 对象，该对象的解决值是  `async`  函数执行的最终结果。
   >
   > 使用 Promise 对象作为返回值有几个原因：
   > 1. 异步操作需要一定的时间来完成，而  `async`  函数的执行是非阻塞的。通过返回一个 Promise 对象，可以在异步操作完成后，通过 Promise 的解决值来获取最终结果。
   > 2. Promise 对象提供了一种标准的、可靠的方式来处理异步操作的结果。它可以通过链式调用的方式进行错误处理、结果传递和其他异步操作的串联。
   > 3. 返回 Promise 对象使得  `async`  函数可以与其他  `async`  函数或基于 Promise 的异步操作进行组合和协作，形成更复杂的异步控制流。
   >
   > 因此，直接调用  `async`  函数的返回值类型是 Promise 对象，以便提供一种统一的、可处理异步操作的机制。
   >
   > await关键字后面经常跟上一个promise，当这个promise状态没有改变（一直是pending的时候），下面的代码都不会执行。等到promise状态改变的时候，会将promise的值取出作为await关键字的返回值，然后可以继续执行后面的代码。正常情况下，await命令是个Promise对象，如果不是 会被转成一个 立即resolved的对象，async函数完全可以看作多个异步操作，包装成的一个Promise对象（因为await函数返回的是Promise对象），而await命令就是内部then命令的语法糖。
   >
   > 因为 async 本质上就是用 generator 函数和 Promise 一起实现，而这样的 generator 函数 yield 返回的是 Promise 类型的对象。

9. 下面代码能正常捕获异步异常吗？为什么？如果不能需要怎样修改才可以正常捕获异常？

   ```javascript
   async function f() {
      throw new Error('出错了');
   }
   try{
      f()
   }catch(e){
      console.log(e)
   }
   ```

   > 这段代码不能正常捕获异步异常。原因是  `async`  函数返回的是一个 Promise 对象，而在  `try...catch`  块中，只能捕获同步代码的异常，无法捕获异步操作的异常。
   >
   > 要捕获  `async`  函数中的异常，可以使用.catch()方法
   >
   > ```js
   > f().catch(err=>console.log(err))
   > ```
   >
   > 要捕获  `async`  函数中的异常，可以使用  `await`  关键字来等待异步操作的结果，并使用  `try...catch`  来捕获异常。修改代码如下：
   > ```js
   > async function f() {
   >    throw new Error('出错了');
   > }
   > try {
   >    await f();
   > } catch (e) {
   >    console.log(e);
   > }
   > ```
   >
   > 通过在  `f()`  函数前添加  `await`  关键字，可以等待  `f()`  函数执行完成并获取其结果。然后，在  `try...catch`  块中捕获异常并处理。这样就能正常捕获异步异常并输出错误信息。

## 代码题

1. 请实现 `thunkify(fn)` 函数，它将一个 callback 类型的异步调用函数转换为 Thunk 函数

   > ```js
   > function thunkify(fn) {
   >   	return function (args) {
   >    		return function (callback) {
   >       			fn(args, callback);
   >     		};
   >   	};
   > }
   > ```

2. 请将 `fs.readFile(path[, options], callback)` 函数 Thunk 化，了解函数点击[这里](https://nodejs.org/dist/latest-v8.x/docs/api/fs.html#fs_fs_readfile_path_options_callback)

   > ```js
   > const fs = require('fs');
   > 
   > function readFileThunk(path, options) {
   >   	return function (callback) {
   >     		fs.readFile(path, options, callback);
   >   	};
   > }
   > ```
   >
   > 在上面的代码中， `readFileThunk`  函数接收  `path`  和  `options`  作为参数，返回一个 Thunk 函数。这个 Thunk 函数接收一个回调函数作为参数，并在内部调用  `fs.readFile`  函数，并将  `path` 、 `options`  和回调函数传递给它。
   >
   > 这样，通过调用返回的 Thunk 函数，可以触发异步读取文件操作，并在回调函数中处理结果。

3. 请实现基于 Thunk 函数的 generator 函数自动运行器

   > ```js
   > let run = fn=>{
   >     let it = fn()
   >     function next(err,data){
   >         let result = it.next(data)
   >         if(result.done) return
   >         result.value(next)
   >     }
   >     next()
   > }
   > 
   > run(genTen)
   > ```

4. 请实现基于 Promise 的 generator 函数自动运行器

   > ```js
   > function runa(fn){
   >     let it = fn()
   >     function next(data){
   >         let res = it.next(data)
   >         if(res.done) return
   >         res.value.then(data=>{
   >             next(data)
   >         })
   >     }
   >     next()
   > }
   > runa(geTen)
   > ```

5. 请使用之前作业：*Promise* 实现的 `ajaxGet(url)` 使用 generator 函数实现以下异步控制流
   1. 实现**串行**（一个接一个的）发送10个请求，来获取前10页数据
   
      ```js
      function ajaxGet(url) {
      	return new Promise(function(resolve, reject) {
      		 var xhr = new XMLHttpRequest();
      		 xhr.open('GET', url);
      		 xhr.onreadystatechange = function () {
               if (xhr.readyState === 4 && xhr.status === 200) {
                   resolve(xhr.responseText);
               }
           } else {
        		reject(new Error('Request failed ');
      			};
      		xhr.send();
      	});
      }//ajaxGet函数
      
      function* genTen() {
        for (let i = 1; i <= 10; i++) {
          try {
              let p = ajaxGet(`http://learning-api.mafengshe.com/news?page=${i}&pageSize=30`)
              console.log(p)
            	yield p;
          } catch (error) {
            console.error(error);
          }
        }
      }
      //自动执行
      function run(fn){
          let it = fn()
          function next(data){
              let res = it.next(data)
              if(res.done) return
              res.value.then(data=>{
                  next(data)
              })
          }
          next()
      }
      run(geTen)
      ```
   
   2. 实现**并行**（同时）发送10个请求，来获取前10页数据
   
      ```js
      function* genTen() {
        const promises = [];
        for (let i = 1; i <= 10; i++) {
          promises.push(ajaxGet(`http://learning-api.mafengshe.com/news?page=${i}&pageSize=30`));
        }
        try {
            console.log(promises)
            yield Promise.all(promises);
        } catch (error) {
          console.error(error);
        }
      }
      //执行一次
      function run(fn){
          let it = fn()
          it.next()
      }
      run(geTen)
      ```
   
6. 请使用之前作业：*Promise* 实现的 `ajaxGet(url)` 使用 async/await 实现以下异步控制流
   1. 实现**串行**（一个接一个的）发送10个请求，来获取前10页数据
   
      ```js
      async function serialRequests() {
        for (let i = 1; i <= 10; i++) {
          let p = ajaxGet(`http://learning-api.mafengshe.com/news?page=${i}&pageSize=30`)
          try {
            console.log(p);
            console.log(await p);
          } catch (err) {
            console.error(err);
          }
        }
      }
      
      serialRequests();
      ```
   
      
   
   2. 实现**并行**（同时）发送10个请求，来获取前10页数据
   
      ```js
      async function parallelRequests() {
        const promises = [];
        for (let i = 1; i <= 10; i++) {
          let p = ajaxGet(`http://learning-api.mafengshe.com/news?page=${i}&pageSize=30`)
          promises.push(p);
        }
        try {
          await Promise.all(promises);
        } catch (err) {
          console.error(err);
        }
      }
      
      parallelRequests();
      ```
   
      

## 源码阅读题

此题为选做题，请阅读 `co` 源码，必要的地方加上注释。请将你标注的代码提交，并写一个文档介绍这个包的原理

此包的源码可以在 https://github.com/tj/co 获得