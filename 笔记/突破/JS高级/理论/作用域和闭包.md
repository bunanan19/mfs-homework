# 作用域和闭包

## 作用域

### 执行环境

执行上下文（execution context），也称执行环境，定义了变量和函数有权访问的数据。环境中的所有变量和函数都保存在一个变量对象中。当某个执行环境中的代码执行完毕后，该执行环境被销毁，保存在其中的所有变量和函数定义也随之销毁。

全局执行环境是指最外围的执行环境，在Web浏览器中，就是指window对象，所有的全局对象和函数都是作为window对象的属性和方法创建的。

每个函数都有自己的执行环境，当函数执行完毕时，函数内的变量会被销毁。

例如

```javascript
function printColor(){
    var color = "blue";
    console.log(color);//blue
}
console.log(color);//报错 "ReferenceError: color is not defined
```

变量`color`在函数`printColor`中建立，当函数执行完毕时，该函数的执行环境被销毁，`color`这个变量也被销毁，因此在全局访问是访问不到的。

### 没有块作用域

**作用域**:顾名思义，就是指变量和函数的作用范围；

**块作用域**, 块作用域是指用**大括号`{}`括起来的代码**会形成一个作用域，但在JavaScript中是不存在块作用域的。

例如，在C语言中：

```c
for(int i = 1; i<5; i++){
    printf("%d",i);
}
printf("%d",i);//会报错i没有定义
```

但在JavaScript中：

```javascript
for(var i = 1; i<5; i++){
    console.log(i);
}
console.log(i);//不会报错，且会打印出来 5;
```

这是因为在C语言中，大括号`{}`括住的部分形成了自己的作用域，在其中声明的变量`i`是无法在外部访问到的。而在javascript当中，没有块作用域的概念，在大括号内声明的变量，在大括号外也是可以访问的。

```js
var i;//变量提升
for(i = 0; i < 5; i++){
    console.log(i);
}
console.log(i)//该代码等效于上面js代码
```

> 思考：这里的 `i` 在什么域里？这里会不会发生**变量提升**？

> 这段代码中的变量i在全局域（Global Scope）中。在全局域中声明的变量可以在代码的任何位置访问。   
>
> 在这段代码中，变量i会发生变量提升。对于变量i，会将i的声明提升。变量提升是JavaScript中的一种行为，它使得在声明变量之前就可以访问该变量。只提升变量的声明。因此，即使在for循环之前声明变量i，循环中的console.log语句仍然可以正确地访问并输出变量i的值。在循环结束后，最后一个console.log语句也可以访问变量i，因为它在全局域中声明。

> 变量提升：
>
> ```js
> a()；
> var b = 10;
> function a(){
>     console.log("a")
> }
> 
> 等价于：
> function a(){
>     console.log("a")
> }
> var b;
> a();
> b = 10;
> 实际上js解析执行时，会将声明提升，只将声明提升，赋值调用不会。比如var b = 10，是赋值和声明在一起，但是js会将声明和赋值拆分，将声明提升。
> ```
>
> 

### 作用域链

在JavaScript中有作用域链的概念，作用域链其实就是执行环境的栈，在标识符解析的过程中，会沿着作用域链一层一层向上找。

程序在执行过程中，没进入一个新的执行环境就会将该执行环境压入执行环境栈中，每执行完毕跳出该执行环境，就会将执行环境弹出栈。

例如，以下这段程序,程序摘自《Javascript高级程序设计》：

```javascript
var color = "blue";

function changeColor(){
    var anotherColor = "red";
    function swapColors(){
        var tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;
        // 这里可以访问 color、 anotherColor 和 tempColor
    }   
    // 这里可以访问 color 和 anotherColor，但不能访问 tempColor
    swapColors();
}
// 这里只能访问 color
changeColor();
```

执行环境的压栈顺序如下：

全局作用域（`var color;function changeColor`）---->

`changeColor()`(`var anotherColor; function swapColor`)---->

`swapColor()`(`var tempColor`);

作用域链顺序如下, 摘自《Javascript高级程序设计》：

![img](http://web-senior.books.mafengshe.com/JS%E9%AB%98%E7%BA%A7/images/scope_chain_demo0.png)

作用域链从右下角向左上角能访问的范围越来越小. swapColor中可以访问changeColor函数中的变量，反之则不可以。

> 注：自己动手试一试 color、 anotherColor 和 tempColor这三个变量在哪里可以访问，哪里不可以访问吧~

## 闭包

### 什么是闭包

首先你要知道，闭包没什么神奇的，也没什么可怕的！

> **闭包**是指有权访问另一个函数作用域中的变量的函数, 创建闭包的常见形式是在一个函数内部创建并返回另一个函数。

例如:

```javascript
function get(){
    var a = 10;
    return function(){
        return a;
    }
}
var getA = get();
```

在这个例子中，返回的匿名函数就是一个闭包。

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231023142838435.png" alt="image-20231023142838435" style="zoom:80%;" />

根据前面说的执行环境和作用域链，我们知道一个函数创建了一个执行上下文，函数内部的变量在函数外是访问不到的，`get`函数的`a`变量在外部是访问不到的，而**闭包的作用就是使我们能够在函数外边访问到函数内部的变量**，返回的匿名函数能够访问到`get`函数的内部变量`a`。

而根据作用域链知道，一个外层函数的内部函数是可以向上搜索从而访问到外层函数的变量的，就如同`get`函数中的匿名函数是可以访问到`get`函数中的变量的，因此前者就成为了后者的闭包。而这种函数嵌套是我们最常见的闭包形式。

### 闭包的作用域链

仍以`getA()`这段代码为例，当函数`get()`执行完毕时，其活动对象不会被销毁，因为匿名函数的作用域链仍在引用这个活动对象（引用为0时才可以被销毁，后面内存管理会说）。只要getA()还存在，get()的变量就不会销毁。不然getA()就会报错。

当`get()`函数执行完毕之后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中，直到匿名函数被销毁后，`get()`函数的活动对象才会被销毁。因此需要**手动销毁来避免内存泄漏**。

> 内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

```javascript
var getA = get();
var res = getA();
getA = null;
```

> 由于闭包会携带父函数的作用域，因此会比其他函数占用更多的内存，从而影响性能，因此要慎重使用闭包。

### 闭包的副作用

作用域链的这种机制导致了闭包保存的是父函数变量的**最终值**。这在出现循环的时候就会产生意想不到的结果。

```javascript
function createFunctions(){
    var result = new Array();
    for (var i=0; i < 10; i++){
        result[i] = function(){
            return i;
        };
    }
    return result;
}
```

我们希望这段代码返回一个函数数组，其中每个函数都能返回对应的索引值，但实际上由于闭包最终保存的是父函数最终的变量对象，此时的`i`值为10，因此最终返回值都为10。

解决方案如下：

```javascript
function createFunctions(){
    var result = new Array();
    for (var i=0; i < 10; i++){
        result[i] = (function(num){
            return function(){
                return num; 
            };//闭包，所以父函数传入的num不会立即销毁，一直保持
        })(i);
    }
    return result;
}
```

在这种解决方案中，调用每个匿名函数的时候，传入变量`i`，由于函数参数是按值传递的，所以会将变量i的当前值复制给参数`num`。而在这个匿名函数内部，又创建并返回了一个访问`num`的闭包，这样一来，result数组中的每个函数都有自己的`num`变量的一个副本，因此就可以返回不同的数值了。



## 问答题

1. 如下代码会报错吗？如果报错请说明原因，如果不报错请说明运行结果和原因

   ```javascript
   for(var i = 1; i<5; i++){
      console.log(i);
   }
   console.log(i);
   //不会报错，输出为1，2，3，4，5
   //因为在javascript当中，没有块作用域的概念，在大括号内声明的变量，在大括号外也是可以访问的。
   //这里发生了变量提升，等效代码为：
   var i;
   for(i = 0; i < 5; i++){
       console.log(i)
   }
   console.log(i)
   ```

2. 如下代码输出是什么？为什么？请写出js解释器实际执行的等效代码

   ```javascript
   var v='Hello World'; 
   (function(){ 
      console.log(v); 
      var v='I love you'; 
   })()
   //输出undefined
   
   //立即执行函数表达式（Immediately Invoked Function Expression，IIFE）的结构。括号将函数括起来的作用是创建一个函数表达式，并立即执行该函数。 
   //在立即执行函数表达式中，变量 v 被声明为局部变量，并且在函数内部的第一行就被尝试输出。由于变量提升的原因，尽管变量 v 在函数内部被重新赋值为"I love you"，但在它被赋值之前尝试输出它的值会返回 undefined 。
   
   等效代码：
   var v='Hello World'; 
   (function(){ 
      var v;
      console.log(v); 
      v='I love you'; 
   })()
   ```

3. 如下代码输出是什么？为什么？请写出js解释器实际执行的等效代码

   ```javascript
   function main(){ 
      console.log(foo);     // ?
      var foo = 10;
      console.log(foo);     // ?
      function foo(){ 
         console.log("我来自 foo"); 
      } 
      console.log(foo);     // ?
   } 
   main();
   //ƒ foo(){ 
   //      console.log("我来自 foo"); 
   //   }
   // 10
   // 10
   ```

   ```js
   function main(){
       var foo;
       function foo(){
           console.log("我来自foo")；
       }
       console.log(foo);
       foo = 10;
       console.log(foo);
       console.log(foo);
   }
   main();
   ```

   **在 JavaScript 中，var变量和函数声明会被提升到它们所在作用域的顶部。**

4. 如下代码输出是什么？为什么？

   ```javascript
   var a = 10;
   var foo = {
      a: 20,
      bar: function () {
         var a = 30;
         return this.a;
      }
   };
   
   console.log(
      foo.bar(),             // 20
      (foo.bar)(),           // 20
      (foo.bar = foo.bar)(), // 10
      (foo.bar, foo.bar)()   // 10
      );
   //解释如下： 
   1.  foo.bar() ：这里调用了 foo 对象的 bar 方法，该方法内部声明了一个局部变量 a 并赋值为30，但是返回的是 this.a ，即 foo 对象的属性 a 的值，因此输出结果为20。
   
   2.  (foo.bar)() ：这里将 foo.bar 用括号括起来，表示对 foo.bar 函数的引用，然后调用该函数。由于 foo.bar 是一个函数，所以调用它会返回 this.a ，即 foo 对象的属性 a 的值，输出结果为20。 
   
   3.  (foo.bar = foo.bar) ：首先，这个表达式将 foo.bar 赋值给 foo.bar ，相当于对 foo.bar 进行了一个自我赋值操作。这个赋值操作会返回被赋予的值，也就是 foo.bar 函数本身。相当于给 foo.bar 定义，一个匿名函数赋值给一个全局变量，所以这个时候 foo.bar 是在 window 作用于下而不是 foo = {} 这一会计作用域，所以这里的 this 指代的是 window ，输出 10。 
   () ：接着，在返回的函数 foo.bar 后面加上括号 () ，表示对该函数的调用。函数调用：由于赋值操作返回的是 foo.bar 函数本身，所以这里实际上是对 foo.bar 函数进行调用。因为此时函数被作为普通函数调用，而不是作为对象的方法调用，所以函数内部的 this 指向全局对象（在浏览器环境中通常是 window 对象）。 返回全局变量a的值10.
   
   4.  (foo.bar, foo.bar) ：这个表达式使用逗号运算符将两个`foo.bar`表达式连接在一起，但只返回最后一个表达式的值。逗号运算符会依次计算两个表达式，但只返回最后一个表达式的值。因此，返回的值是  foo.bar  函数本身，而不是对该函数的引用，所以这里 this 指向的是 window。 
      - 首先，计算第一个  foo.bar ，但并不执行函数调用。此时函数内部的  this  指向  foo  对象。 
      - 然后，计算第二个  foo.bar ，同样不执行函数调用。此时函数内部的  this  仍然指向  foo  对象。 
      - 最后，返回结果为第二个  foo.bar  的值。 
     () ：接着，在返回的值（即第二个  foo.bar ）后面加上括号  () ，表示对该值进行调用。 
      - 因为返回的值是  foo.bar  函数本身，所以实际上是对  foo.bar  函数进行调用。 
      - 由于函数被作为普通函数调用，而不是作为对象的方法调用，所以函数内部的  this  指向全局对象。 
      - 最后，输出结果为全局对象中的  a  属性值，即  10 。
      
    第三问，第四问，一个是等号运算符，一个是逗号运算符，经过赋值，运算符运算后，都是存粹的函数，不是对象方法的引用。所以函数指向的 this 都是 window 的
   ```

5. 如下代码输出是什么？为什么？请写出js解释器实际执行的等效代码

   ```javascript
   var a = 10;
   function main(){
      console.log(a);        // undefined
      var a = 20;
      console.log(a);        // 20
      (function(){
         console.log(a);     // undefined
         var a = 30;
         console.log(a);     // 30
      })()
      console.log(a);        // 20
   }
   main()
   
   //因为发生了变量提升，打印的第一个a，虽声明提升了，再main里面声明了局部变量a，但是赋值没有提升，所以为undefined；打印的第二个a，在此前对a赋值了，a=20，所以打印结果为20；打印的第三个a，在一个立即执行函数内部，且在其内部，也声明了局部变量a，变量a的声明被提升，但是赋值没有，所以打印结果为undefined；第三个打印a的结果为30，是因为赋值了；最后一个a的打印的执行环境里，a的值为20.
   //等效代码：
   var a;
   a = 10;
   function main(){
       var a;
       console.log(a);
       a = 20;
       console.log(a);
       (function(){
         var a;
         console.log(a);    
         a = 30;
         console.log(a);     
      })()
      console.log(a); 
   }
   ```

6. 为什么点击所有的button打印出来的都是`5`而非`0,1,2,3,4`？要怎么修改？

   ```html
   <!DOCTYPE html>
   <html>
   <head>
   <meta charset="utf-8">
   <meta name="viewport" content="width=device-width">
   
   <title>JS Bin</title>
   <script src="https://code.jquery.com/jquery-3.1.0.js"></script>
   </head>
   <body>
   <ul>
   <li><button>0</button></li>
   <li><button>1</button></li>
   <li><button>2</button></li>
   <li><button>3</button></li>
   <li><button>4</button></li>
   </ul>
   </body>
   </html>
   ```

   ```javascript
   var buttons = $("button")
   
   for(var i=0;i<buttons.length;i++){
      buttons[i].onclick = function(){
         console.log(i)
      }
   }
   ```

   > 闭包保存的是父函数变量的**最终值**,变量i的最终值为5，当循环结束，执行click事件时，i的值全变为了5
   >
   > ```js
   > var buttons = $("button")
   > 
   > for(var i=0;i<buttons.length;i++){
   >    buttons[i].onclick = (function(index){
   >       console.log(index)
   >    })(i)
   > }
   > ```

7. 什么是内存泄漏？怎样判断自己的程序是否有内存泄漏？

   > 内存泄漏（Memory leak）是指在程序中动态分配的内存空间，在不再需要时没有被正确释放或回收，导致该内存无法再被程序使用，从而造成内存的浪费和耗尽。   
   >
   > 判断程序是否存在内存泄漏可以通过以下方法：   1. 内存占用增长：观察程序的内存占用情况，如果随着时间的推移，内存占用持续增长而没有明显的释放或回收，可能存在内存泄漏。   2. 垃圾回收机制：现代编程语言通常具备自动垃圾回收机制，可以自动释放不再使用的内存。如果程序中的对象或资源没有被垃圾回收机制正确处理，可能会导致内存泄漏。   3. 工具和分析：使用内存分析工具来检测内存泄漏。这些工具可以帮助检测未释放的内存块、对象引用的循环依赖等问题。   4. 监控资源：除了内存，还可以监控其他资源的使用情况，如文件句柄、数据库连接等。如果这些资源没有正确释放或关闭，也可能引发类似的泄漏问题。   
   >
   > 总之，判断程序是否存在内存泄漏需要综合考虑内存占用、垃圾回收机制、工具分析和资源监控等因素，以及对程序的运行行为进行仔细观察和分析。

8. 什么是循环引用？循环引用在V8下会造成内存泄漏吗？

   > 循环引用（Circular reference）指的是两个或多个对象之间相互引用，形成了一个循环链，导致无法被垃圾回收器正确地回收。当存在循环引用时，这些对象之间的引用计数永远无法变为零，即使它们已经不再被程序使用，从而导致内存泄漏。  
   >
   >  在V8引擎下，循环引用可能会造成内存泄漏。V8引擎使用的是基于分代的垃圾回收算法，主要依赖于标记清除（Mark and Sweep）算法。当对象之间存在循环引用时，垃圾回收器无法正确地判断哪些对象是可以被回收的，因为它们之间的引用计数永远不会变为零。这可能导致这些对象一直存在于内存中，无法被回收，从而造成内存泄漏。   为了避免循环引用导致的内存泄漏，在编写程序时应注意避免创建循环引用的情况。特别是在使用引用类型的数据结构（如链表、树等）时，需要小心处理对象之间的引用关系，确保在不需要时能够正确地解除引用，以便垃圾回收器能够正常回收这些对象。
   >
   > V8引擎已经能很好的处理循环引用的情况，即循环引用的对象当没有外部引用时，会被正确的GC（Garbage Collection)

## 代码题

1. 根据如下会在V8下内存泄漏的例子，自己写一段代码，让其在V8下会内存泄漏

```javascript
var theThing = null  
var replaceThing = function () {  
   var originalThing = theThing
   var unused = function () {
      if (originalThing)
      console.log("hi")
   }
   theThing = {
      longStr: new Array(1000000).join('*'),
      someMethod: function () {
      console.log(someMessage)
      }
   };
};
setInterval(replaceThing, 100)
//这段代码中，通过 setInterval 函数每100毫秒调用 replaceThing 函数。在 replaceThing 函数内部，首先将 theThing 赋值给 originalThing ，然后创建一个未使用的函数 unused ，该函数在 originalThing 存在时输出"hi"。接着，将 theThing 重新赋值为一个包含 longStr 属性和 someMethod 方法的新对象。 
 
//由于 replaceThing 函数被周期性地调用，每次调用时都会创建一个新的对象并将其赋值给 theThing ，但旧的对象并没有被正确释放。这是因为在 unused 函数中引用了 originalThing ，导致旧的对象无法被垃圾回收器回收，从而造成内存泄漏。
```

```js
var a = function(){
    var c = {
        str = new Array(1000).join('*'),
        method:function(){
            cosole.log(str)
        }
    }
    return function(){
        if(c){
            console.log("Memory leak")
        }
    }
}
setInterval(a,100)
```

```js
var arr = null
        setInterval(function () {
            var newArr = arr
            return function () {
                if (newArr) {
                    console.log(arr);
                }
            }//闭包，引用了父元素中的arr，每次执行时，arr被重新创建，且前面创建的arr没有被释放，一直保存再内存。
            arr = new Array(1000000)
        }, 100)
```



