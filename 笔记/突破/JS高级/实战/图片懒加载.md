# 图片懒加载

## 什么是图片懒加载？

img元素在页面加载时并不加载实际的图片，只有当图片出现在浏览器的可视区域内时，才设置图片正真的路径，让图片显示出来。这就是图片懒加载

## 为什么要使用图片懒加载？

- 减轻服务器的压力
- 加速用户网页加载速度（用户体验好）
- 节省网络流量

经典使用场景：

- 淘宝首页
- 微信文章浏览页

## 思路

1. 没有 src 属性的 img 元素，浏览器不会发出请求下载图片，一旦通过javascript设置了图片路径，浏览器才会送请求。有点按需分配的意思，你不想看，就不给你看，你想看了就给你看~

2. 不设置 src 属性，我们怎么获取真实图片路径？我们可以使用自定义属性 data-src ,当图片进入可视区域时，将 data-src 的值设置给 src

3. 如何判断元素是否进入可视区域？我们要先了解一些基本的知识，比如说如何获取某个元素的尺寸大小、滚动条滚动距离及偏移位置距离:

   ![img](http://web-senior.books.mafengshe.com/JS%E9%AB%98%E7%BA%A7/images/window.png)

   1. 屏幕可视窗口大小：对应于图中1、2位置处 原生方法：

      ```javascript
       // 标准浏览器及IE9+    // 标准浏览器及低版本IE标准模式            // 低版本混杂模式
       window.innerHeight || document.documentElement.clientHeight|| document.body.clientHeight
      ```

      jQuery方法：

      ```javascript
       $(window).height()
      ```

   2. 浏览器窗口顶部与文档顶部之间的距离，也就是滚动条滚动的距离：也就是图中3、4处对应的位置； 原生方法：

      ```javascript
       // IE9+及标准浏览器  // 兼容ie低版本的标准模式              // 兼容混杂模式；
       window.pagYoffset|| document.documentElement.scrollTop|| document.body.scrollTop
      ```

      jQuery方法：

      ```javascript
       $(document).scrollTop();
      ```

   3. 获取元素的尺寸：对应于图中5、6位置处；左边jquery方法，右边原生方法

      ```javascript
       $(o).width()          // = o.style.width;
       $(o).innerWidth()     // = o.style.width+o.style.padding;
       $(o).outerWidth()     // = o.offsetWidth = o.style.width+o.style.padding+o.style.border;
       $(o).outerWidth(true) // = o.style.width+o.style.padding+o.style.border+o.style.margin;
      ```

   4. 获取元素的位置信息：对应与图中7、8位置处

      ```javascript
       $(o).offset().top     // 元素距离文档顶的距离
       $(o).offset().left    // 元素距离文档左边缘的距离
      ```

4. 然后就是判断元素是否进入可视区域 ![img](http://web-senior.books.mafengshe.com/JS%E9%AB%98%E7%BA%A7/images/in.png)

   外面最大的框为实际页面的大小，中间浅蓝色的框代表父元素的大小，对象1~8代表元素位于页面上的实际位置；以水平方向来做如下说明！

   - 对象8左边界相对于页面左边界的偏移距离（offsetLeft）大于父元素右边界相对于页面左边界的距离，此时可判读元素位于父元素之外；

   - 对象7左边界跨过了父元素右边界，此时：对象7左边界相对于页面左边界的偏移距离（offsetLeft）小于 父元素右边界相对于页面左边界的距离，因此对象7就进入了父元素可视区；

   - 在对象6的位置处，对象5的右边界与页面左边界的距离 大于 父元素左边界与页面左边界的距离；

   - 在对象5位置处时，对象5的右边界与页面左边界的距离 小于 父元素左边界与页面左边界的距离；此时，可判断元素处于父元素可视区外；

   - 因此水平方向必须买足两个条件，才能说明元素位于父元素的可视区内；同理垂直方向也必须满足两个条件；具体见下文的源码；

     > 对于绝大数的网页（只可以垂直滚动的），我们可以使用简化的判断方式：只判断垂直偏移

这里给出只判断垂直偏移的简单实现

```javascript
function isShow($node) {
    var windowH = $(window).height();
    var scrollTop = $(window).scrollTop();
    var nodeOT = $node.offset().top;
    var nodeH = $node.height();
    return nodeOT <= scrollTop + windowH && nodeOT + nodeH >= scrollTop
}
```

## 实现

> 注意：因为 chrome 中onscroll时间太过于频繁，我们使用 setTimeout 进行延时处理

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>JS Bin</title>
  <style>
    .a {
      height: 1000px;
    }
    img{
      height: 394px;
      width: 650px;
      background: green;
    }
  </style>


</head>
<body>
  <div class="a"></div>
  <div class="a"></div>
  <img data-src="http://static.mafengshe.com/home/pic/2.jpg?imageMogr2/quality/40" alt="">
  <div class="a"></div>
  <div class="a"></div>

  <script src="https://code.jquery.com/jquery-3.1.0.js"></script>
  <script>
    function isShow($node) {
      var windowH = $(window).height();
      var scrollTop = $(window).scrollTop();
      var nodeOT = $node.offset().top;
      var nodeH = $node.height();
      return nodeOT <= scrollTop + windowH && nodeOT + nodeH >= scrollTop
    }
    window.onscroll = function(){
      console.log(isShow($('img')))
      isShow($('img')) && $('img').src = $('img').data('src');
    }
  </script>
</body>
</html>
```

在线预览效果在[这里](http://jsbin.mafengshe.com/dax)



## 问答题

1. 什么是图片懒加载？

   > img元素在页面加载时并不加载实际的图片，只有当图片出现在浏览器的可视区域内时，才设置图片正真的路径，让图片显示出来。这就是图片懒加载

2. 为什么要使用图片懒加载？

   > - 减轻服务器的压力
   > - 加速用户网页加载速度（用户体验好）
   > - 节省网络流量

3. 实现图片的懒加载的思路是什么？

   > 1. 没有 src 属性的 img 元素，浏览器不会发出请求下载图片，一旦通过javascript设置了图片路径，浏览器才会送请求。
   > 2. 不设置 src 属性，我们可以使用自定义属性 data-src ,当图片进入可视区域时，将 data-src 的值设置给 src
   > 3. 然后就是判断元素是否进入可视区域

4. 图片懒加载可能使得文档重排，造成不好的用户体验，这是为什么？我们应该怎么解决？

   > 这是因为当页面加载时，浏览器会为每个元素分配一定的空间，以便正确显示页面内容。如果图片懒加载，即延迟加载图片直到用户滚动到它们所在的位置时再加载，那么在图片加载之前，浏览器无法确定图片的尺寸，因此无法为其预留空间。这将导致文档重排，即页面元素的位置发生变化，可能会出现闪烁或错位的情况，给用户带来不好的体验。   
   >
   > 为了解决这个问题，可以采取以下几种方法：  
   >
   > 1. 预设图片尺寸：在使用懒加载之前，为图片设置一个固定的宽度和高度，这样浏览器就能为其预留空间，避免文档重排。  
   > 2. 使用占位符：在图片加载之前，可以使用占位符（如一个具有相同尺寸的空白 div）来占据图片的位置，以保持页面布局的稳定性。  
   > 3.  加载指示器：在图片加载过程中，可以显示一个加载指示器，告知用户图片正在加载，以减轻用户的不良体验。   通过以上方法，可以最大程度地减少图片懒加载对文档重排的影响，提升用户的体验。

5. 什么是瀑布流布局？

   > 瀑布流式布局是比较流行的一种网站页面布局，视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。

6. 为了使瀑布流布局的每一列尽可能等高，我们需要使用什么算法

   > 贪心算法
   >
   > 1. 各列高度初始化为 0
   > 2. 寻找各列之中所有元素高度之和的最小者
   > 3. 将新的元素添加到该列上
   > 4. 该列高度加上新元素的高度
   > 5. 如果还有未添加元素，跳转至第 `2.` 步

7. 我们一般绑定 onscroll 事件来实现加载更多，但是 onscroll 调用次数过多，一般我们可以通过使用什么方法来解决这个问题？

   > 定时器和定时器清除
   >
   > 滚动事件发生后的50毫秒内检查窗口的滚动位置，并根据条件向  $node  元素添加或删除  show  类。如果在这50毫秒内再次触发滚动事件，之前的定时器会被取消，重新设置一个新的定时器。这样可以避免在连续滚动时频繁执行代码，以提高性能。

## 代码题

1. 实现图片懒加载，要求封装成类，通过如下代码就可以使当前页面所有图片实现懒加载

   ```
   new LazyImg($("img"))
   ```

   ```js
   function LazyImg($node){
       function isShow($node){
           var windowH = window.innerHeight;//屏幕可视窗口高度
           var scrollTop = $(window).scrollTop();//浏览器窗口顶部与文档顶部之间的距离，也就是滚动条滚动的距离
           var imgH = $node.height();//获取元素的尺寸
           var imgOT = $node.offset().top;// 元素距离文档顶的距离
           return imgOT <= windowH+scrollTop && imgH + imgOT >= scrollTop
       }
       
       window.onscroll = function(){
           var timeId = null;
           clearTimeout(timeId);
           timeId = setTimeout(function(){
               if(isShow($node)){
               $node.attr("src",$node.data("src"))
           	}
           },100)
       }
   }
   ```

   

2. 实现[新闻瀑布流](https://mafengshe.github.io/fe-demo/pubu-news.html)
   可以通过 GET learning-api.mafengshe.com/news 获得数据（后端已经添加跨域返回头），该地址支持如下几个参数

|    参数    | 含义                                     |
| :--------: | :--------------------------------------- |
| `pageSize` | 默认值 30（最大200），每一页的新闻条目数 |
|   `page`   | 默认 1，请求的页码                       |

```js
//瀑布流
        function findMinIndex(arr) {
            var minIndex = 0;
            for (var i = 0; i < arr.length; i++) {
                if (arr[i] < arr[minIndex])
                    minIndex = i;
            }
            return minIndex;
        }//寻找各列之中所有元素高度之和的最小者

        function waterFall() {

            var itemWidth = $(".item").outerWidth(true)//true是作为.outerWidth()方法的一个参数传递进去的。它表示是否包括元素的外边距（margin）在内
            var containerWidth = $(".water-fall").width()
            var colNum = Math.floor(containerWidth / itemWidth);
            var heights = [];//各列的高度的数组

            for (var i = 0; i < colNum; i++) {
                heights.push(0)//各列高度初始化为 0
            }

            $(".item").each(function () {
                var col = findMinIndex(heights);
                var ele = $(this)

                ele.css({
                    top: heights[col] + "px",
                    left: col * itemWidth + "px"
                });//将新的元素添加到该列上

                heights[col] += ele.outerHeight(true);//该列高度加上新元素的高度
            })
        }

        waterFall();

        $(window).on("resize",function () {
            waterFall()
        })//事件绑定
```

