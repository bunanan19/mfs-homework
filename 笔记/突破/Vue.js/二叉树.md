## 问答题

1. 什么是二叉树？定义是什么？

   > 二叉树（Binary Tree）是每个节点最多有两个子节点的树形数据结构。每个节点都有一个值，以及两个指向子节点的指针。二叉树可以用来表示各种数据结构，如二叉搜索树、堆、哈希表等。 
   >
   > 二叉树的定义如下：   1. 二叉树是一棵树，其中每个节点最多有两个子节点。  2. 二叉树的根节点没有父节点。  3. 二叉树的每个非叶子节点都有一个左子节点和一个右子节点。  4. 二叉树的每个叶子节点没有子节点。 

2. 什么是孩子，父亲，兄弟，祖先，后继，叶子节点？

   > 孩子节点：指一个节点的直接子节点
   >
   > 父亲节点：指一个节点的直接父节点
   >
   > 兄弟节点：指一个节点的所有同层、具有相同父节点的节点
   >
   > 祖先节点：节点所在树的根节点到该节点路径上的所有节点称为祖先节点
   >
   > 后继节点：以该结点为根的树中的任一结点都是该结点的后继（子孙）
   >
   > 叶子节点：没有左右子节点的节点

3. 什么是完全二叉树？什么是满二叉树？

   > 完全二叉树指除了最后一层外，其他层的节点都被填满，且最后一层的节点都靠左排列。换句话说，完全二叉树是从左到右依次填充节点的二叉树。 
   >
   > 满二叉树是一种特殊的二叉树，其中每个节点要么没有子节点（叶子节点），要么有两个子节点。换句话说，满二叉树中除了叶子节点外的每个节点都有两个子节点。 

4. 前序遍历，中序遍历，后续遍历中，知道哪几个可以推出整个树结构？

   > vlr（先序遍历）     lrv（中序遍历）     lrv （后序遍历）
   >
   > 前序遍历、中序遍历和后续遍历都可以推出整个树结构。   
   >
   > 前序遍历的顺序是：根节点、左子树、右子树。中序遍历的顺序是：左子树、根节点、右子树。后续遍历的顺序是：左子树、右子树、根节点。   
   >
   > 通过前序遍历，可以得到树的根节点。通过中序遍历，可以得到树的所有节点，并按照从左到右、从上到下的顺序排列。通过后续遍历，可以得到树的所有节点，并按照从右到左、从上到下的顺序排列。 
   >
   > 前序遍历和中序遍历，或后序遍历和中序遍历

5. 【选做题】请自学堆，回答下面问题
   - 堆是一种什么样的数据结构？
   
     > 堆是一种完全二叉树的数据结构，其中每个节点的值都大于等于（或小于等于）其子节点的值。在大根堆中，父节点的值大于等于其子节点的值；在小根堆中，父节点的值小于等于其子节点的值。堆常用于实现优先队列和堆排序等算法。
   
   - 如何建堆？
   
     >  要建立一个堆，可以使用自底向上的方法，也称为"heapify"。具体步骤如下：   1. 从最后一个非叶子节点开始，依次向上处理每个节点。   2. 对于当前节点，比较其值与其子节点的值，如果不满足堆的性质，则进行交换。   3. 继续向上处理，直到根节点。
   
   - Sift-up和Sift-down 算法各是如何工作的？
   
     >  Sift-up（上浮）算法用于在插入新节点后维护堆的性质。具体步骤如下：   1. 将新节点插入堆的末尾。   2. 将新节点与其父节点进行比较，如果不满足堆的性质，则进行交换。   3. 重复上述步骤，直到新节点达到合适的位置或成为根节点。   
     >
     > Sift-down（下沉）算法用于在删除根节点后维护堆的性质。具体步骤如下：   1. 将堆的最后一个节点放到根节点的位置。   2. 将根节点与其子节点进行比较，选择较大（或较小）的子节点。   3. 如果根节点与选定的子节点不满足堆的性质，则进行交换。   4. 重复上述步骤，直到根节点达到合适的位置或没有子节点。   Sift-up和Sift-down算法都是用于维护堆的性质，确保堆中的节点满足堆的定义。

## 代码题

1. 请实现树的四种遍历（前序遍历，中序遍历，后续遍历，层序遍历）

   > ```js
   > //先序遍历
   > function preVisit(root){
   >     if(!root){//递归终止条件：如果root为空，终止
   >         return
   >     }
   >     console.log(root.val)
   > 
   >     preVisit(root.left)
   >     preVisit(root.right)
   > 
   >     // if(root.left){//递归终止条件
   >     //     preVisit(root.left)//递归
   >     // }
   >     // if(root.right){
   >     //     preVisit(root.right)
   >     // }
   > }
   > 
   > preVisit(root)
   > 
   > console.log('---------------------------')
   > 
   > //中序遍历
   > function midVisit(root){
   >     if(!root){//递归终止条件：如果root为空，终止
   >         return
   >     }
   >     midVisit(root.left)
   >     console.log(root.val)
   >     midVisit(root.right)
   > }
   > 
   > midVisit(root)
   > 
   > console.log('---------------------------')
   > 
   > //后序遍历
   > function postVisit(root){
   >     if(!root){//递归终止条件：如果root为空，终止
   >         return
   >     }
   >     postVisit(root.left)
   >     postVisit(root.right)
   >     console.log(root.val)
   > }
   > 
   > postVisit(root)
   > 
   > console.log('---------------------------')
   > 
   > //层序遍历
   > function levelVisit(root){
   >     if(!root){//递归终止条件：如果root为空，终止
   >         return
   >     }
   >     let queue = [] //创建一个队列,进行暂存
   >     queue.push(root)//将根节点入队
   >     while(queue.length != 0){//当队列非空时
   >         let node = queue.shift()//将队头元素出队
   >         console.log(node.val)//输出当前节点的值
   >         
   >         if(node.left){//如果当前节点有左子节点
   >             queue.push(node.left)//将左子节点入队
   >         }
   >         if(node.right){//如果当前节点有右子节点
   >             queue.push(node.right)//将右子节点入队
   >         }
   >     }
   > }
   > 
   > levelVisit(root)
   > ```
   >
   > 

2. 请写一个递归函数实现求解树的高度

   > ```js
   > function getHeight(root) {
   >   if (root === null) {
   >     return 0;
   >   } else {
   >     const leftHeight = getHeight(root.left);
   >     const rightHeight = getHeight(root.right);
   >     return Math.max(leftHeight, rightHeight) + 1;
   >   }
   > }
   > ```
   >
   > 这个函数首先检查根节点是否为空。如果为空，表示树为空树，高度为 0。否则，它会递归地调用自身来计算左子树和右子树的高度，并返回较大的那个高度加上 1，作为根节点的高度。 

3. 请实现一个函数，判断一个树是否是平衡二叉树

   > 平衡二叉树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
   >
   > ```js
   > function isBalanced(root) {
   >   if (root === null) {
   >     return true;
   >   }
   > 
   >   // 获取左子树和右子树的高度差
   >   const leftHeight = getHeight(root.left);
   >   const rightHeight = getHeight(root.right);
   > 
   >   // 判断当前节点是否满足平衡二叉树的条件
   >   if (Math.abs(leftHeight - rightHeight) <= 1 && isBalanced(root.left) && isBalanced(root.right)) {
   >     return true;
   >   }
   > 
   >   return false;
   > }
   > 
   > function getHeight(node) {
   >   if (node === null) {
   >     return 0;
   >   }
   > 
   >   // 递归计算左子树和右子树的高度
   >   const leftHeight = getHeight(node.left);
   >   const rightHeight = getHeight(node.right);
   > 
   >   // 返回当前节点的高度（左子树和右子树中较大的高度加1）
   >   return Math.max(leftHeight, rightHeight) + 1;
   > }
   > 
   > // 创建一个平衡二叉树
   > const root = {
   >   value: 1,
   >   left: {
   >     value: 2,
   >     left: {
   >       value: 4,
   >       left: null,
   >       right: null
   >     },
   >     right: {
   >       value: 5,
   >       left: null,
   >       right: null
   >     }
   >   },
   >   right: {
   >     value: 3,
   >     left: null,
   >     right: null
   >   }
   > };
   > 
   > // 判断树是否是平衡二叉树
   > console.log(isBalanced(root)); // true
   > ```
   >
   > 该函数首先判断根节点是否为空，如果为空则返回 true。然后，通过递归计算左子树和右子树的高度，并判断当前节点是否满足平衡二叉树的条件：左右子树的高度差不超过 1，并且左右子树都是平衡二叉树。如果满足条件，则返回 true，否则返回 false。 

4. 【选做题】请实现堆排序

   > ```js
   > function heapSort(arr) {
   >   // 构建最大堆
   >   buildMaxHeap(arr);
   > 
   >   // 从最后一个节点开始，依次将最大值交换到数组末尾，并调整堆结构
   >   for (let i = arr.length - 1; i > 0; i--) {
   >     swap(arr, 0, i); // 将当前最大值交换到末尾
   >     heapify(arr, 0, i); // 调整堆结构，排除已排序的部分
   >   }
   > 
   >   return arr;
   > }
   > 
   > function buildMaxHeap(arr) {
   >   const len = arr.length;
   >   // 从最后一个非叶子节点开始，依次进行下沉操作，构建最大堆
   >   for (let i = Math.floor(len / 2) - 1; i >= 0; i--) {
   >     heapify(arr, i, len);
   >   }
   > }
   > 
   > function heapify(arr, i, len) {
   >   const left = 2 * i + 1;
   >   const right = 2 * i + 2;
   >   let largest = i;
   > 
   >   // 比较当前节点与左子节点，找出最大值的索引
   >   if (left < len && arr[left] > arr[largest]) {
   >     largest = left;
   >   }
   > 
   >   // 比较当前节点与右子节点，找出最大值的索引
   >   if (right < len && arr[right] > arr[largest]) {
   >     largest = right;
   >   }
   > 
   >   // 如果最大值不是当前节点，交换节点，并递归调整被交换的子节点
   >   if (largest !== i) {
   >     swap(arr, i, largest);
   >     heapify(arr, largest, len);
   >   }
   > }
   > 
   > function swap(arr, i, j) {
   >   const temp = arr[i];
   >   arr[i] = arr[j];
   >   arr[j] = temp;
   > }
   > 
   > const arr = [4, 10, 3, 5, 1];
   > const sortedArr = heapSort(arr);
   > console.log(sortedArr); // [1, 3, 4, 5, 10]
   > ```
   >
   > 