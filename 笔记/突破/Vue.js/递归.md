<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231126171745767.png" alt="image-20231126171745767" style="zoom:80%;" />

## 回溯算法思路

<img src="https://bkimg.cdn.bcebos.com/pic/377adab44aed2e738bd4ef4c1c49b68b87d6277f4c30?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5/format,f_auto" alt="img" style="zoom:80%;" />

<img src="https://bkimg.cdn.bcebos.com/pic/d50735fae6cd7b899e513fe1946c55a7d933c895a033?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5/format,f_auto" alt="img" style="zoom:80%;" />

<img src="https://bkimg.cdn.bcebos.com/pic/86d6277f9e2f070828387b62726caf99a9014c085432?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5/format,f_auto" alt="img" style="zoom:80%;" />

八皇后问题(3张)

八皇后问题如果用[穷举法](https://baike.baidu.com/item/穷举法/1431412?fromModule=lemma_inlink)需要尝试88=16,777,216种情况。每一列放一个皇后，可以放在第 1 行，第 2 行，……，直到第8行。穷举的时候从所有皇后都放在第1行的方案开始，检验皇后之间是否会相互攻击。如果会，把列H的皇后挪一格，验证下一个方案。移到底了就“进位”到列G的皇后挪一格，列H的皇后重新试过全部的8行。这种方法是非常低效率的，因为它并不是哪里有冲突就调整哪里，而是盲目地按既定顺序枚举所有的可能方案。

[回溯算法](https://baike.baidu.com/item/回溯算法/9258495?fromModule=lemma_inlink)优于穷举法。将列A的皇后放在第一行以后，列B的皇后放在第一行已经发生冲突。这时候不必继续放列C的皇后，而是调整列B的皇后到第二行，继续冲突放第三行，不冲突了才开始进入列C。如此可依次放下列A至E的皇后，如图2所示。将每个皇后往右边横向、斜向攻击的点位用叉标记，发现列F的皇后无处安身。这时回溯到列E的皇后，将其位置由第4行调整为第8行，进入列F，发现皇后依然无处安身，再次回溯列E。此时列E已经枚举完所有情况，回溯至列D，将其由第2行移至第7行，再进入列E继续。按此算法流程最终找到如图3所示的解，成功在棋盘里放下了8个“和平共处”的皇后。继续找完全部的解共92个。

回溯算法求解八皇后问题的原则是：有冲突解决冲突，没有冲突往前走，无路可走往回退，走到最后是答案。为了加快有无冲突的判断速度，可以给每行和两个方向的每条[对角线](https://baike.baidu.com/item/对角线/9706033?fromModule=lemma_inlink)是否有皇后占据建立标志数组。放下一个新皇后做标志，回溯时挪动一个旧皇后清除标志。

```js
function queen(a, cur) {
    if (cur==a.length) { console.log(a); return; }
    for (var i = 0; i < a.length; i++) {
        a[cur] = i;
        var flag = true;
        for (var j = 0; j < cur; j++) {
            var ab = i - a[j];
            if (a[j]==i||(ab>0?ab:-ab)==cur-j) { flag=false; break };
        };
        if (flag) { queen(a,cur+1); }
    };
};
queen([1,1,1,1,1,1,1,1],0);

//方法二
let queen = []
let methods = 0 //检验八皇后问题有多少个解
//冲突检查函数：
 function conflict(num){//新加的皇后的编码
    for(let i= 0; i<num; i++){//检查新加的皇后是否与之前的皇后冲突
        if(queen[i] == queen[num] || //是否在同一行
            num - i == queen[num] - queen[i]||//检查是否在对角线上，i-num的差值=横坐标差值，queen[num] - queen[i]=纵坐标差值
            i - num == queen[num] - queen[i]){
                return true//返回true表示新加的皇后在冲突的位置上
            }
    }
    return false//返回false表示新加的皇后不在冲突的位置上
 }

 function find(row, all){
    methods ++;//每一个正确解都会加一次
    if(row == all){
        return print(all)//八个皇后找完打印出来
    }
    for(let i=0; i<all; ++i){//在纵向的八个位置找满足要求的位置
        queen[row] = i;//row的值为0-7，当row=8时就打印结果了
        if(!conflict(row))//如果当前行数ruw的皇后不满足条件，就得继续i++
            find(row+1, all)//成功就找下一个皇后row+1
    }
 }
 function print(all){
    for(let i=0; i<all; ++i){//横坐标
        let str = ''
        for(let j = 0; j<all; ++j){//纵坐标
            if(j==queen[i]) str += ' #'//当第i列的i皇后在j行的位置上时
            else str += ' o'
        }
        console.log(str)
    }
    console.log()
 }

 find(0,8)
```



## 代码题

1. 请使用递归求解 **斐波那契数列** 的第 n 项，调用方式为`fib(n)`；并说明算法的时间复杂度与 `n` 的关系

   > ```js
   > function fib(n){
   >     if (n<=1)
   >         return n;
   >     else return fib(n-1)+fib(n-2)
   > }
   > ```
   >
   > 该算法的时间复杂度为 O(2^n^)

2. 请实现汉诺塔求解程序

   > ```js
   > function hanoi(n, from, to, aux) {
   >     if (n === 1) {
   >       console.log(`Move disk ${n} from ${from} to ${to}`);
   >     } else {
   >       hanoi(n - 1, from, aux, to);
   >       console.log(`Move disk ${n} from ${from} to ${to}`);
   >       hanoi(n - 1, aux, to, from);
   >     }
   >   }
   >   hanoi(3, "A", "C", "B");
   > ```
   >
   > 

3. 请完成递归求解全排列问题：n 个不同元素的集合，输出所有不同的排列顺序

   如：`S = {a, b, c}`，应该输出

   ```
   a b c
   a c b
   b a c
   b c a
   c a b
   c b a
   ```

   > ```js
   > function permute(str){
   >     if( str.length == 0) return [[]]//该代码首先判断str长度是否为0，为0直接返回。
   > 
   >     let results = [];
   >     for(let i = 0; i< str.length; i++){//遍历字符串中的每个字符，并将其从str中移除，得到新的字符串newStr 
   >         let newStr = str.slice(0, i).concat(str.slice(i + 1));
   >         for(let j = 0; j < permute(newStr).length; j++ ){
   >             results.push([str[i]] + permute(newStr)[j]);
   >         }
   >     }
   >     return results;
   > }
   > console.log(permute(["a", "b", "c"]));
   > ```
   >
   > ```js
   > let arr = [];// 用于存储排列结果的数组
   > function conflict(num,thisLetter){//检查当前字母是否与之前的字母有重合
   >     for(let i = 0;i<num;i++){
   >         if(thisLetter == arr[i]){//检查已经已经写入数组的元素中是否已经有了该字母
   >             return true;
   >         }
   >     }
   >     return false;
   > }
   > function find(num,str){
   >     if (num == str.length){
   >         return console.log(arr); //当字母排完，输出当前的排列结果
   >     }
   >     for(let i = 0; i < str.length; i++){//遍历数组每个元素，在num这个位置上找到数组中符合的字母
   >         if (!conflict(num,str[i])){
   >             arr[num] = str[i];//将当前字符str[i]放入当前位置num
   >             find(num+1,str);// 递归调用，查找下一个位置的字母
   >         }
   >     }
   > }
   > 
   > let S = ['a','b','c'];
   > find(0,S);//从idx=0 的位置头部开始找合适的字母
   > ```
   >
   > 

4. 请实现二分搜索：在有序数组上，每次选择中间的元素，检查是否等于目标元素。等于则直接返回，小于则寻找左半边的数组，大于则寻找右半边的数组

   > ```js
   > function find(arr,k){
   >     if (arr.length == 0) return -1
   >     let idx = Math.floor(arr.length/2)
   >     var v = arr[idx]
   >     if (v == k) {
   >         return idx;
   >     } else if (v < k){
   >         newArr = arr.slice(idx+1)
   >         return idx + 1+ find(newArr,k)
   >     } else {
   >         newArr = arr.slice(0,idx)
   >         return find(newArr,k)
   >     }
   > }
   > find([1,2,3,4,5,6],5)
   > ```
   >
   > ```js
   > function find(arr,k,left,right){
   >     if (left > right) return -1
   > 
   >     let idx = Math.floor((left+right)/2)
   >     var mid = arr[idx]
   >     if (mid == k) {
   >         return idx;
   >     } else if (mid < k){
   >         return find(arr,k ,idx+1,right)
   >     } else {
   >         return find(arr,k,left,idx-1)
   >     }
   > }
   > find([1,2,3,4,5,6],5,0,5)
   > ```
   >
   > 