# 插入排序：

插入算法作为几大经典的排序算法之一，它的性能在其中算是比较不错的了（主要是稳定）；

        插入算法的基本原理就是在一串乱序的数字中，首先认为第一个数是有序的，然后从第二个数开始比较，每次比较都与前面排好序的部分由后往前进行比较；比如第二个数和第一个数比较，然后第三个数和先和第二个数比较然后在和第一个数比较，第四个数先和第三个数比较然后再分别和第二、第一个数比较。
    
        如果在比较的过程中遇到的后一个数比自己大而前一个数比自己小那么就把自己插入到这两个数之间，然后结束这一轮排序进入下一轮；比如说当我是第五个数的时候，我和第三个数比较，它比我大，而我和第二个数比较，它却比我小，那么我就插入到第二个、第三个数中间，然后进入下一轮排序。
    
        如果当前的数比第一次比较的数都大，那么直接插入到该数后面（也就是相当于原地不动），然后进入下一轮排序；比方说我是第三个数，那么现在我首先要和第二个数进行比较，如果我比它大，而它又是我第一次比较的数，那么我就直接插入到它后面（也就相当于原地不动），然后进入下一轮排序。
    
        如果当前的数比最后一次比较的数（也就是这个序列当前的第一个数）都小的话，那么就直接将自己插入到这个数的前面（也就是将自己插入到当前这个序列的第一个数前面成为序列的第一个数）；比如说我是第四个数，在排序比较的时候，我比前三个数（第三、第二、第一）都小的话，那么我就插入到第一个数前面成为当前序列的第一个数。

二、算法例子
        假如有这样一串数字：2,4,7,5,1,14,11,14,13；我们要将他用插入排序进行升序排列；那么我们将按以下步骤进行（每轮排序确定好一个数字的位置）：

        （1）第一轮排序首先确定2是已排好序的，我们将4拿来进行插入排序，4进行第一轮排序的第一次排序和2比较，显然4比2大，而这又是第一次也是本轮的最后一次比较，所以将4插入到2后面（即原地不动），此时的序列仍然是2,4,7,5,1,14,11,14,13，然后进入第二轮排序；
    
        （2）第二轮排序开始，首先在第一轮排序中2,4这前两位是排好序的，我们现在将7拿出来和前面排好序的部分进行对比调位，首先在本轮的第一次排序和4比较，显然7比4大，所以直接将7插入到4后面（即原地不动），此时的序列也仍然是2,4,7,5,1,14,11,14,13，然后结束本轮排序进入第三轮排序；
    
        （3）第三轮排序，将5和前面排好序的三个数进行对比调位，本轮的第一次比较5比7小，进行第二次比较，5比4大，所以将5插入到4和7之间，此时的序列变成了2,4,5,7,1,14,11,14,13，然后结束本轮排序进入第四轮排序；
    
        （4）第四轮排序，将1和前面排好序的4个数进行对比调位，因为1比前面的四个数都小，所以在经过4次比较后，将1插入到此时序列的第一个数（即2）的前面，然后此时的序列变成了这样：1,2,4,5,7,14,11,14,13，然后我们结束本轮排序进入第五轮排序；
    
        （5）第五轮排序，将14和前面的5个排好序的部分进行对比调位，本轮的第一次排序14和7比较，显然14比7大，所以将14插入到7后面（即位置不变），此时的序列是1,2,4,5,7,14,11,14,13，然后结束本轮排序进入第六轮排序；
    
        （6）第六轮排序，将11和前面排好序的6个数进行对比调位，本轮的第一次排序11和14比较，显然11比14小，第二次比较11和7比，显然11比7大，所以将11插入到7和14中间，此时的序列变成了：1,2,4,5,7,11,14,14,13，然后结束本轮排序进入第七轮排序；
    
        （7）第七轮排序，将14和前面排好序的7个数进行对比调位，本轮的第一次排序14和14进行对比，显然两数相等，所以保持位置不变，即序列此时仍是：1,2,4,5,7,11,14,14,13，然后结束本轮的排序进入第八轮也即是最后一轮排序；
    
        （8）第八轮排序，将13和前面排好序的8个数进行对比调位，本轮的第一次排序13和14进行对比，显然13小于14，第二次排序13和另一个14对比，仍然小于14，第三次排序13和11对比，显然13大于11，所以将13插入到11和第二次比较的14之间，此时的序列即为最终排序完成的序列：1,2,4,5,7,11,13,14,14；

**时间复杂度**

在插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较N- 1次，时间复杂度为O(N)。

最坏的情况是待排序数组是逆序的，此时需要比较次数最多，总次数记为：1+2+3+…+N-1，所以，插入排序最坏情况下的时间复杂度为O( N^2^)。

平均来说，A[1..j-1]中的一半元素小于A[j]，一半元素大于A[j]。插入排序在平均情况运行时间与最坏情况运行时间一样，是输入规模的二次函数。

**空间复杂度**

插入排序的空间复杂度为常数阶O(1)



```js
function insertSort(arr){
    for(let i = 1; i < arr.length; i++){
        let key = arr[i]
        let j = i-1;//若放在循环条件里面，let块级作用域，在循环外访问不到j的值，所有放在外面
        while(j >= 0 && key < arr[j]){
            arr[j+1] = arr[j]
            console.log(arr)//观察数据处理的过程
            j--
        }
        arr[j+1] = key
    }
    return arr
}
let arr = [3,5,1,8,5,9,0,7]

insertSort(arr)

console.log(arr)
```

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231122213819649.png" alt="image-20231122213819649" style="zoom:80%;" />

# 冒泡排序：

泡排序是一种简单的排序算法，它也是一种稳定排序算法。其实现原理是重复扫描待排序序列，并**比较每一对相邻的元素，当该对元素顺序不正确时进行交换。**一直重复这个过程，直到没有任何两个相邻元素可以交换，就表明完成了排序。

> 一般情况下，称某个排序算法稳定，指的是当待排序序列中有相同的元素时，它们的相对位置在排序前后不会发生改变。

假设待排序序列为 (5,1,4,2,8)，如果采用冒泡排序对其进行升序（由小到大）排序，则整个排序过程如下所示：

1) 第一轮排序，此时整个序列中的元素都位于待排序序列，依次扫描每对相邻的元素，并对顺序不正确的元素对交换位置，整个过程如图 1 所示。
   <img src="https://m.biancheng.net/uploads/allimg/191114/2-19111411414M58.gif" alt="img" style="zoom:80%;" />

从图 1 可以看到，经过第一轮冒泡排序，从待排序序列中找出了最大数 8，并将其放到了待排序序列的尾部，并入已排序序列中。

2) 第二轮排序，此时待排序序列只包含前 4 个元素，依次扫描每对相邻元素，对顺序不正确的元素对交换位置，整个过程如图 2 所示。<img src="https://m.biancheng.net/uploads/allimg/191114/2-191114114213154.gif" alt="img" style="zoom:80%;" />

可以看到，经过第二轮冒泡排序，从待排序序列中找出了最大数 5，并将其放到了待排序序列的尾部，并入已排序序列中。

3) 第三轮排序，此时待排序序列包含前 3 个元素，依次扫描每对相邻元素，对顺序不正确的元素对交换位置，整个过程如图 3 所示。<img src="https://m.biancheng.net/uploads/allimg/191114/2-191114114231129.gif" alt="img" style="zoom:80%;" />

经过本轮冒泡排序，从待排序序列中找出了最大数 4，并将其放到了待排序序列的尾部，并入已排序序列中。

4) 第四轮排序，此时待排序序列包含前 2 个元素，对其进行冒泡排序的整个过程如图 4 所示。<img src="https://m.biancheng.net/uploads/allimg/191114/2-19111411424RU.gif" alt="img" style="zoom:80%;" />

经过本轮冒泡排序，从待排序序列中找出了最大数 2，并将其放到了待排序序列的尾部，并入已排序序列中。

5) 当进行第五轮冒泡排序时，由于待排序序列中仅剩 1 个元素，无论再进行相邻元素的比较，因此直接将其并入已排序序列中，此时的序列就认定为已排序好的序列（如图 5 所示）。<img src="https://m.biancheng.net/uploads/allimg/191114/2-191114114311M1.gif" alt="img" style="zoom:80%;" />

> 通过分析冒泡排序的实现代码可以得知，该算法的最差时间复杂度为o(n^2^)，最优时间复杂度为`O(n)`，平均时间复杂度为o(n^2^)。
>
> ### 时间复杂度
>
> 若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数![img](https://bkimg.cdn.bcebos.com/formula/0aaf4f8c3ac9f82d6a7882cd121e566b.svg)和记录移动次数![img](https://bkimg.cdn.bcebos.com/formula/2a7f4d616d4c16dbf634e349d641b055.svg)均达到最小值：![img](https://bkimg.cdn.bcebos.com/formula/03e35724822180365d0d937fbc68b9b2.svg)，![img](https://bkimg.cdn.bcebos.com/formula/9a569e56b84494c24acb31885c070f6f.svg),所以，冒泡排序最好的[时间复杂度](https://baike.baidu.com/item/时间复杂度?fromModule=lemma_inlink)为![img](https://bkimg.cdn.bcebos.com/formula/f5a1886cf2ff13d73aee4d32d363f66e.svg) 。若初始文件是反序的，需要进行![img](https://bkimg.cdn.bcebos.com/formula/dd01d53f50293f756063f87e52c76000.svg)趟排序。每趟排序要进行![img](https://bkimg.cdn.bcebos.com/formula/73cdbd7376481a2b19bc38c92d4dd9ff.svg)次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到[最大值](https://baike.baidu.com/item/最大值/774514?fromModule=lemma_inlink)： ![img](https://bkimg.cdn.bcebos.com/formula/51947f4116d1beb324f5a061dac8edbd.svg)
>
> ![img](https://bkimg.cdn.bcebos.com/formula/2cfa295e83cce099e1ff5afd4f0ba50d.svg)
>
> 冒泡排序的最坏时间复杂度为<img src="https://bkimg.cdn.bcebos.com/formula/93e1a5d467b4fce05210acb873107e09.svg" alt="img" style="zoom: 80%;" />
>
> 综上，因此冒泡排序总的平均时间复杂度为<img src="https://bkimg.cdn.bcebos.com/formula/93e1a5d467b4fce05210acb873107e09.svg" alt="img" style="zoom:80%;" />
>
> ### 算法稳定性
>
> 冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。

```js
//原始版：
function bubbleSort(arr){
    for(let i = arr.length-1; i >=0; i--){//arr.length-1是因为arr[length]超过了数组长度，数组中索引值为0-(length-1)
        for(let j = 0; j < i; j++){//j<i是因为，每一轮i的遍历，i后面的数据段都是冒泡完成且有序的，不需要浪费时间去遍历已经排好了的
            if(arr[j] > arr[j+1]){
                let v = arr[j+1]
                arr[j+1] = arr[j]
                arr[j] = v//若前者比后者大，arr[j+1]和arr[j]换值，大的值冒泡，每轮找出无序段的最大值
            }
        }
        console.log(arr)//观察冒泡过程
    }
}
let arr = [8,0,5,1,5,8,9,0,7,3]

bubbleSort(arr)

console.log(arr)

//精细版：
function bubbleSort(arr){
    for(let i = arr.length-2; i >=0; i--){//arr.length-2是因为可以只遍历n-1轮(n-2到0有n-1位)就可以得到n-1个大的值，剩下一个肯定是最小的值，不需要再遍历一次了
        for(let j = 0; j < i; j++){//j<i是因为，每一轮i的遍历，i+1后面的数据段都是冒泡完成有序的，不需要浪费时间去遍历已经排好了的，且j<i等价于j<(i=arr.length-2),当计算arr[j+1]时刚好只能遍历到最后一个数据i+1(arr.length-1)进行比较，而不超过前面无序段数组长度
            if(arr[j] > arr[j+1]){
                let v = arr[j+1]
                arr[j+1] = arr[j]
                arr[j] = v//若前者比后者大，arr[j+1]和arr[j]换值，大的值冒泡，每轮找出无序段的最大值
            }
        }
        console.log(arr)//观察冒泡过程
    }
}
let arr = [8,0,5,1,5,8,9,0,7,3]

bubbleSort(arr)

console.log(arr)
```

i < arr.length-1次遍历：

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231122221534516.png" alt="image-20231122221534516" style="zoom:80%;" />

i < arr.length-2次遍历：

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231122221544986.png" alt="image-20231122221544986" style="zoom:80%;" />

# 希尔排序：

Shell排序又称作缩小增量排序。Shell排序的执行时间依赖于增量序列。是直接插入[排序算法](https://baike.baidu.com/item/排序算法/5399605?fromModule=lemma_inlink)的一种更高效的改进版本。

## 基本思想

先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2<d1重复上述的分组和排序，直至所取的增量dt=1(dt<dt-l<；…<d2<d1），即所有记录放在同一组中进行直接插入排序为止。

该方法实质上是一种分组插入方法。

## 算法分析

### 增量序列

Shell排序的执行时间依赖于增量序列。

好的增量序列的共同特征：

① 最后一个增量必须为1；

② 应该尽量避免序列中的值(尤其是相邻的值）互为倍数的情况。

有人通过大量的实验，给出了目前较好的结果：当n较大时，比较和移动的次数约在n到1.6n之间。

### 时间性能

希尔排序是基于[插入排序](https://baike.baidu.com/item/插入排序?fromModule=lemma_inlink)的一种算法， 在此算法基础之上增加了一个新的特性，提高了效率。希尔排序的时间的时间复杂度为O(![img](https://bkimg.cdn.bcebos.com/formula/eb39d4c67a9cabbd3a2690a2151ee6cc.svg))，希尔排序时间复杂度的下界是n*log2n。希尔排序没有[快速排序算法](https://baike.baidu.com/item/快速排序算法/369842?fromModule=lemma_inlink)快 O(n(logn))，因此中等大小规模表现良好，对规模非常大的[数据排序](https://baike.baidu.com/item/数据排序/7456909?fromModule=lemma_inlink)不是最优选择。但是比O(![img](https://bkimg.cdn.bcebos.com/formula/c937d30f3cd06da1cd53133d8a3b4887.svg))复杂度的算法快得多。并且希尔排序非常容易实现，算法代码短而简单。 

[希尔排序](https://baike.baidu.com/item/希尔排序?fromModule=lemma_inlink)的时间性能优于直接插入排序的原因：

①当文件初态基本有序时[直接插入排序](https://baike.baidu.com/item/直接插入排序?fromModule=lemma_inlink)所需的比较和移动次数均较少。

②当n值较小时，n和n^2^的差别也较小，即直接插入排序的最好时间复杂度O(n）和最坏时间复杂度0(n^2^）差别不大。

③在希尔排序开始时增量较大，分组较多，每组的记录数目少，故各组内直接插入较快，后来增量di逐渐缩小，分组数逐渐减少，而各组的记录数目逐渐增多，但由于已经按di-1作为距离排过序，使文件较接近于有序状态，所以新的一趟排序过程也较快。

因此，希尔排序在效率上较直接插入排序有较大的改进。

### 稳定性

[希尔排序](https://baike.baidu.com/item/希尔排序?fromModule=lemma_inlink)是不稳定的。参见上述实例，该例中两个相同关键字49在排序前后的相对次序发生了变化。

### 算法讨论

Shell[排序算法](https://baike.baidu.com/item/排序算法?fromModule=lemma_inlink)的[时间复杂度](https://baike.baidu.com/item/时间复杂度?fromModule=lemma_inlink)分析比较复杂，实际所需的时间取决于各次排序时增量的个数和增量的取值。研究证明，若增量的取值比较合理，Shell排序算法的时间复杂度约为O（n（ldn）2）。由于Shell排序算法是按增量分组进行的排序，所以Shell排序算法是一种不稳定的排序算法。

## 算法步骤

Step1 将n个元素个数列分为5个小组，在每个小组内按直接插入法排序；

step2 在第i步，分组个数取 di+1 =（di +1）/2 {9，5，3，2，1}；相临两组之间的对应元素进行比较，如果ai>aj，则交换它们的位置；

Step3 当dK = 1的循环过程完成后，排序过程结束。

[希尔排序](https://baike.baidu.com/item/希尔排序?fromModule=lemma_inlink)举例：设有字符数列"f d a c b e"，执行Shell排序：

```js
const shellSort = function (arr) {
    var gap = 1
    var len = arr.length
    //动态规划步长
    while (gap > len/3) {
        gap = gap*3 + 1
    }
    //步长组循环
    for(gap; gap > 0; gap = Math.floor(gap/3)) {
        //同步长循环
        for(i = gap; i < len; i++) {
            var temp = arr[i]
            var j
            //比较、并将数据后移
            for(j = i - gap; j >= 0 && arr[j] > temp; j-=gap) {
                arr[j + gap] = arr[j]
            }
            arr[j + gap] = temp
        }
    }
    return arr
}
let arr = [8,0,5,1,5,8,9,0,7,3]
shellSort(arr)
console.log(arr)


var arr1 = [5, 4, 8, 1, 3, 7, 0, 9, 2, 6];
function shellSort(arr) {
    var len = arr.length;
    var tmp = undefined;
    var gap = Math.floor(len / 2);
    while (gap >= 1) {
        console.log(`此时的gap为：${gap}`)
        for (var i = 0; i < len; i++) {
            for (var j = i; j >= gap; j = j - gap) {
                // console.log(`此时的j为：${j},此时的j-gap为：${j-gap}`)
                if (arr[j] < arr[j - gap]) {
                    tmp = arr[j];
                    arr[j] = arr[j - gap];
                    arr[j - gap] = tmp;
                    console.log(`这个时候开始交换，${j}与${j-gap}交换后的数组`, arr)
                }
            }
        }
        gap = Math.floor(gap / 2);
    }
    return arr;
}
shellSort(arr1);

//在上面的希尔排序中，首先要选取步长gap的值。选取了gap之后，就将数列分成了gap个组，对于每一个组都执行直接插入排序。在排序完所有的组之后，将gap的值减半；继续对数列进行分组，然后进行排序。重复这样的操作，直到gap>=1为止。此时，数列也就是有序的了。
```

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231124154250171.png" alt="image-20231124154250171" style="zoom:67%;" />

# 快速排序算法：

快速排序（Quicksort），是对[冒泡排序](https://baike.baidu.com/item/冒泡排序/4602306?fromModule=lemma_inlink)算法的一种改进。

## 基本思想

快速排序采用的是分治思想，即在一个无序的序列中选取一个任意的基准元素pivot，利用pivot将待排序的序列分成两部分，前面部分元素均小于或等于基准元素，后面部分均大于或等于基准元素，然后采用递归的方法分别对前后两部分重复上述操作，直到将无序序列排列成有序序列。 [5]

## 排序流程

快速排序算法通过多次比较和交换来实现排序，其排序流程如下：

1、首先设定一个分界值，通过该分界值将数组分成左右两部分。

2、将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于分界值，而右边部分中各元素都大于或等于分界值。

3、然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。

4、重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。

## 排序步骤

### 原理

设要排序的[数组](https://baike.baidu.com/item/数组/0?fromModule=lemma_inlink)是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的[排序算法](https://baike.baidu.com/item/排序算法/0?fromModule=lemma_inlink)，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。 

一趟快速排序的算法是： [1]

（1）设置两个变量i、j，[排序](https://baike.baidu.com/item/排序/0?fromModule=lemma_inlink)开始的时候：i=0，j=N-1； 

（2）以第一个数组元素作为关键数据，赋值给**key**，即**key**=A[0]；

（3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于**key**的值A[j]，将A[j]和A[i]的值交换；

（4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于**key**的A[i]，将A[i]和A[j]的值交换；

（5）重复第3、4步，直到`i==j`；（3,4步中，没找到符合条件的值，即3中A[j]不小于**key**,4中A[i]不大于**key**的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。

### 排序演示

假设一开始序列{xi}是：5，3，7，6，4，1，0，2，9，10，8。

此时，ref=5，i=1，j=11，从后往前找，第一个比5小的数是x8=2，因此序列为：2，3，7，6，4，1，0，5，9，10，8。

此时i=1，j=8，从前往后找，第一个比5大的数是x3=7，因此序列为：2，3，5，6，4，1，0，7，9，10，8。

此时，i=3，j=8，从第8位往前找，第一个比5小的数是x7=0，因此：2，3，0，6，4，1，5，7，9，10，8。

此时，i=3，j=7，从第3位往后找，第一个比5大的数是x4=6，因此：2，3，0，5，4，1，6，7，9，10，8。

此时，i=4，j=7，从第7位往前找，第一个比5小的数是x6=1，因此：2，3，0，1，4，5，6，7，9，10，8。

此时，i=4，j=6，从第4位往后找，直到第6位才有比5大的数，这时，i=j=6，ref成为一条分界线，它之前的数都比它小，之后的数都比它大，对于前后两部分数，可以采用同样的方法来排序。 

## 程序调用举例

用法: 

```
void qsort(void *base, int nelem, int width, int (*fcmp)(const void *,const void *));
```

参数：

1、待[排序](https://baike.baidu.com/item/排序/0?fromModule=lemma_inlink)数组首地址； 

2、数组中待排序元素数量； 

3、各元素的占用空间大小； 

4、指向函数的[指针](https://baike.baidu.com/item/指针/0?fromModule=lemma_inlink)，用于确定排序的顺序。 

## 示例代码

```js
const quickSort = (array) => {
 const sort = (arr, left = 0, right = arr.length - 1) => {
  if (left >= right) {//如果左边的索引大于等于右边的索引说明整理完毕
   return
  }
 let i = left
 let j = right
 const baseVal = arr[j] // 取无序数组最后一个数为基准值
 while (i < j) {//把所有比基准值小的数放在左边，大的数放在右边
  while (i < j && arr[i] <= baseVal) { //找到一个比基准值大的数交换
   i++
  }
  arr[j] = arr[i] // 将较大的值放在右边如果没有比基准值大的数就是将自己赋值给自己（i 等于 j）
  while (j > i && arr[j] >= baseVal) { //找到一个比基准值小的数交换
   j--
 }
  arr[i] = arr[j] // 将较小的值放在左边如果没有找到比基准值小的数就是将自己赋值给自己（i 等于 j）
 }
 arr[j] = baseVal // 将基准值放至中央位置完成一次循环（这时候 j 等于 i ）
 sort(arr, left, j-1) // 将左边的无序数组重复上面的操作
 sort(arr, j+1, right) // 将右边的无序数组重复上面的操作
 }
 const newArr = array.concat() // 为了保证这个函数是纯函数拷贝一次数组
 sort(newArr)
 return newArr
}

// 方法二：
let _quickSort = (left, right, nums) => {
  let swap = (left, right, nums) => {
    let temp = nums[left]
    nums[left] = nums[right]
    nums[right] = temp
  }
  if (left <= right) {
    let val = nums[left]
    let [i, j] = [left, right]

    while (i < j) {
      while (i < j && nums[j] > val) {
        j--
      }
      while (i < j && nums[i] < val) {
        i++
      }
      if (i < j) {
        swap(i, j , nums)
      }
    }
    nums[i] = val
    _quickSort(left, i - 1, nums)
    _quickSort(i + 1, right, nums)
  }
}

let quickSort = (...numbers) => {
  _quickSort(0, numbers.length - 1, numbers)
  return numbers
}

console.log(quickSort(1, 20, 9, 13, 59, 19, 98))

//js版本
function quickSort(arr,left,right){
    if(left>=right) return
    let pivot = arr[right]//随机或者最后一个都行
    let i = left
    let j = right
    while(i<j){
        while(i<j && arr[i]<=pivot) {i++}
        arr[j] = arr[i]
        while(i<j && arr[j]>=pivot) {j--}
        arr[i] = arr[j]
    }
    arr[j] = pivot
    quickSort(arr,left,j-1)
    quickSort(arr,j+1,right)
}
let arr = [3,4,1,9,5,0,4,5,7,8]
quickSort(arr,0,arr.length-1)
console.log(arr)


function quickSort2(arr){
    if(arr.length<=1) return arr

    let pivot = arr[arr.length-1]
    let leftArr = arr.filter(i=>i<pivot)
    let rightArr = arr.filter(i=>i>pivot)
    return [...quickSort2(leftArr), pivot, ...quickSort2(rightArr)]
}
let arr1 = [3,4,1,9,5,0,4,5,7,8]

console.log(quickSort2(arr1))
```

## 性能分析

快速排序的一次划分算法从两头交替搜索，直到low和hight重合，因此其时间复杂度是O(n)；而整个快速排序算法的时间复杂度与划分的趟数有关。 

理想的情况是，每次划分所选择的中间数恰好将当前序列几乎等分，经过logn趟划分，便可得到长度为1的子表。这样，整个算法的时间复杂度为O(nlogn)。 

最坏的情况是，每次所选的中间数是当前序列中的最大或最小元素，这使得每次划分所得的子表中一个为空表，另一子表的长度为原表的长度-1。这样，长度为n的数据表的快速排序需要经过n趟划分，使得整个排序算法的时间复杂度为O(n^2^)。 

为改善最坏情况下的时间性能，可采用其他方法选取中间数。通常采用“三者值取中”方法，即比较H->r[low].key、H->r[high].key与H->r[(low+high)/2].key，取三者中关键字为中值的元素为中间数。 

可以证明，快速排序的平均时间复杂度也是**O(nlogn)**。因此，该排序方法被认为是目前最好的一种内部排序方法。 

从空间性能上看，尽管快速排序只需要一个元素的辅助空间，但快速排序需要一个栈空间来实现递归。最好的情况下，即快速排序的每一趟排序都将元素序列均匀地分割成长度相近的两个子表，所需栈的最大深度为log2(n+1)；但最坏的情况下，栈的最大深度为O(n)。这样，快速排序的空间复杂度为平均情况下位**O(logn)**。



# 选择排序算法：

选择排序介绍
选择排序(Selection sort)是一种简单直观的排序算法。
它的基本思想是：首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

```c
/*
 * 选择排序
 * 参数说明：
 *     a -- 待排序的数组
 *     n -- 数组的长度
 */
void select_sort(int a[], int n)
{
    int i;        // 有序区的末尾位置
    int j;        // 无序区的起始位置
    int min;    // 无序区中最小元素位置
 
    for(i=0; i<n; i++)
    {
        min=i;
        // 找出"a[i+1] ... a[n]"之间的最小元素，并赋值给min。
        for(j=i+1; j<n; j++){
            if(a[j] < a[min])
                min=j;
        }
        // 若min!=i，则交换 a[i] 和 a[min]。
        // 交换之后，保证了a[0] ... a[i] 之间的元素是有序的。
        if(min != i)
            swap(a[i], a[min]);
    }
}

function selectionSort(arr) {
    function swap(a, b) {
        let temp = arr[b];
        arr[b] = arr[a];
        arr[a] = temp;
    }
    for (let i = 0; i < arr.length; i++) {
        let minIndex = i;
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[minIndex] > arr[j]) {
                minIndex = j;
            }
        }
        swap(i, minIndex);
    }
}

//js版本
function selectionSort(arr){
    for(let i = 0; i<arr.length; i++){
        let minIdx = i// 无序区中最小元素位置
        for(let j = i+1; j <arr.length; j++){// 找出"a[i+1] ... a[n]"之间的最小元素，并赋值给minIdx。
            if(arr[j]<arr[minIdx]){
                minIdx = j
            }
        }
        // 若minIdx!=i，则交换 a[i] 和 a[min]。
        // 交换之后，保证了a[0] ... a[i] 之间的元素是有序的。
        if(minIdx != i){           
            let val = arr[i]
            arr[i] = arr[minIdx]
            arr[minIdx] = val
        }
        console.log(arr)//观察选择排序过程
    }
}
let arr = [8,0,5,1,5,8,9,0,7,3]

selectionSort(arr)

console.log(arr)
```

<img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20231123160556292.png" alt="image-20231123160556292" style="zoom:80%;" />

下面以数列{20,40,30,10,60,50}为例，演示它的选择排序过程(如下图)。

<img src="https://img-blog.csdnimg.cn/img_convert/aaeb122608a96632a2650d59020fc052.png" alt="img" style="zoom:80%;" />

排序流程

第1趟：i=0。找出a[1...5]中的最小值a[3]=10，然后将a[0]和a[3]互换。 数列变化：20,40,30,10,60,50 -- > 10,40,30,20,60,50
第2趟：i=1。找出a[2...5]中的最小值a[3]=20，然后将a[1]和a[3]互换。 数列变化：10,40,30,20,60,50 -- > 10,20,30,40,60,50
第3趟：i=2。找出a[3...5]中的最小值，由于该最小值大于a[2]，该趟不做任何处理。
第4趟：i=3。找出a[4...5]中的最小值，由于该最小值大于a[3]，该趟不做任何处理。
第5趟：i=4。交换a[4]和a[5]的数据。 数列变化：10,20,30,40,60,50 -- > 10,20,30,40,50,60

### 选择排序的时间复杂度和稳定性
#### 选择排序时间复杂度
选择排序的时间复杂度是O(N^2^)。
假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？N-1！因此，选择排序的时间复杂度是O(N^2^)。

选择排序的交换操作介于 0 和 (n - 1)次之间。选择排序的比较操作为 n (n - 1） / 2 次之间。选择排序的赋值操作介于 0 和 3 (n - 1） 次之间。比较次数O(n^2^），比较次数与关键字的初始状态无关，总的比较次数N=(n-1）+(n-2）+...+1=n*(n-1）/2。交换次数O(n），最好情况是，已经有序，交换0次；最坏情况交换n-1次，逆序交换n/2次。交换次数比[冒泡排序](https://baike.baidu.com/item/冒泡排序?fromModule=lemma_inlink)少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。

#### 选择排序稳定性
选择排序是稳定的算法，它满足稳定算法的定义。
算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！

选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法。

# 归并排序

**归并排序**是建立在归并操作上的一种有效，稳定的[排序算法](https://baike.baidu.com/item/排序算法/5399605?fromModule=lemma_inlink)，该算法是采用[分治法](https://baike.baidu.com/item/分治法/2407337?fromModule=lemma_inlink)（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为[二路归并](https://baike.baidu.com/item/二路归并/53201558?fromModule=lemma_inlink)。

## 归并操作

归并操作，也叫归并算法，指的是将两个顺序序列合并成一个顺序序列的方法。

如设有数列{6，202，100，301，38，8，1}

初始状态：6,202,100,301,38,8,1

第一次归并后：{6,202},{100,301},{8,38},{1}，比较次数：3；

第二次归并后：{6,100,202,301}，{1,8,38}，比较次数：4；

第三次归并后：{1,6,8,38,100,202,301},比较次数：4；

总的比较次数为：3+4+4=11；

[逆序数](https://baike.baidu.com/item/逆序数/3334502?fromModule=lemma_inlink)为14；

## 算法描述

归并操作的工作原理如下：

第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列

第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置

第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置

重复步骤3直到某一指针超出序列尾

将另一序列剩下的所有元素直接复制到合并序列尾

## 比较

归并排序是稳定的排序.即相等的元素的顺序不会改变.如输入记录 1(1) 3(2) 2(3) 2(4) 5(5) (括号中是记录的关键字)时输出的 1(1) 2(3) 2(4) 3(2) 5(5) 中的2 和 2 是按输入的顺序.这对要排序数据包含多个信息而要按其中的某一个信息排序,要求其它信息尽量按输入的[顺序排列](https://baike.baidu.com/item/顺序排列/56273984?fromModule=lemma_inlink)时很重要。归并排序的比较次数小于[快速排序](https://baike.baidu.com/item/快速排序/2084344?fromModule=lemma_inlink)的比较次数，移动次数一般多于快速排序的移动次数。

## 用途

### 排序

速度仅次于[快速排序](https://baike.baidu.com/item/快速排序/0?fromModule=lemma_inlink)，为[稳定排序算法](https://baike.baidu.com/item/稳定排序算法/56321315?fromModule=lemma_inlink)，一般用于对总体无序，但是各子项相对有序的数列，应用见2011年普及[复赛](https://baike.baidu.com/item/复赛/9305140?fromModule=lemma_inlink)第3题“[瑞士](https://baike.baidu.com/item/瑞士/131482?fromModule=lemma_inlink)轮”的标程。

### 求逆序对数

具体思路是，在归并的过程中计算每个小区间的[逆序](https://baike.baidu.com/item/逆序/515770?fromModule=lemma_inlink)[对数](https://baike.baidu.com/item/对数/91326?fromModule=lemma_inlink)，进而计算出大区间的逆序对数（也可以用[树状数组](https://baike.baidu.com/item/树状数组/313739?fromModule=lemma_inlink)来求解）

## 示例代码

**归并排序原理**

归并排序具体工作原理如下（假设序列共有n个元素）：

将序列每相邻两个数字进行归并操作（[merge](https://baike.baidu.com/item/merge/13680638?fromModule=lemma_inlink))，形成[floor](https://baike.baidu.com/item/floor/10942235?fromModule=lemma_inlink)(n/2+n%2)个序列，排序后每个序列包含两个元素

将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素

重复步骤2，直到所有元素排序完毕

使用[递归](https://baike.baidu.com/item/递归/1740695?fromModule=lemma_inlink)的代码如下。优点是描述算法过程思路清晰，缺点是使用递归，mergeSort()函数频繁地自我调用。长度为n的数组最终会调用mergeSort()函数 2n-1次，这意味着一个长度超过1500的数组会在[Firefox](https://baike.baidu.com/item/Firefox/139791?fromModule=lemma_inlink)上发生[栈溢出](https://baike.baidu.com/item/栈溢出/8538051?fromModule=lemma_inlink)错误。可以考虑使用迭代来实现同样的功能。

```js
function merge(left, right){
    var result=[];
    while(left.length>0 && right.length>0){
        if(left[0]<right[0]){
        /*shift()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。*/
            result.push(left.shift());
        }else{
            result.push(right.shift());
        }
    }
    return result.concat(left).concat(right);
}
function mergeSort(items){
    if(items.length == 1){
        return items;
}
var middle = Math.floor(items.length/2),
    left = items.slice(0, middle),
    right = items.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}
```

非递归算法 （javaScript）

```js
function mergePass(arr = [], temp = new Array(arr.length), N = arr.length, length = 1){ // 将每个元素看作是相邻的数组长度为1。
  let t; // 迭代深度。
  for (t = 0; Math.pow(2,t) < N; t++, length *= 2) { // 每次跳过的长度翻倍。
    const even = t%2 === 0; // 复用 arr 和 temp 来回赋值。
    for (let left = 0;  left < N; left += 2 * length) { // 左边数组起始位置 left 从0开始。
      const middle = left + length < N ? left + length : left; // 右边数组起始位置 middle 就是left + 一个数组长度length 但是不要超过 N 。
      const right = left + (2 * length) < N ? left + (2 * length) : N; // 右边界 right 就是 left + 两个数组长度。
      merge(even ? arr : temp, even ? temp : arr, left, middle, right); // 合并每两个相邻的数组。
    }
  }
  if(t % 2 === 0){
        return arr;//返回arr
    }
  return temp; // 返回 temp 。
}
function merge(arr, temp, left, middle, right){
  const leftEnd = middle - 1; // 通过右边数组的起始位置得到左边数组的结束位置。
  while (left <= leftEnd && middle < right) { // 如果‘指针’没有越界。
    if (arr[left] > arr[middle]) { // 如果左边数组第一个元素比右边数组第一个元素大。
      temp[left + middle - leftEnd -1] = arr[middle++]; // 将右边数组最小的放入有序数组 temp（初始值为空)。
    } else {
      temp[left + middle - leftEnd -1] = arr[left++]; // 将左边数组最小的放入有序数组 temp（初始值为空)。
    }
  }
  while(left > leftEnd && middle < right){ // 如果左边数组放完了，右边数组还有元素。
    temp[left + middle - leftEnd -1] = arr[middle++]; // 那么依次将右边数组剩余的元素放入 temp 。
  }
  while(left <= leftEnd && middle >= right){ // 如果右边数组放完了，左边数组还有元素
    temp[left + middle - leftEnd -1] = arr[left++]; // 那么依次将左边数组剩余的元素放入 temp 。
  }
}
```

## 复杂度

归并排序比较占用内存，但却是一种效率高且稳定的算法。

改进归并排序在归并时先判断前段序列的[最大值](https://baike.baidu.com/item/最大值/774514?fromModule=lemma_inlink)与后段序列[最小值](https://baike.baidu.com/item/最小值/774537?fromModule=lemma_inlink)的关系再确定是否进行复制比较。如果前段序列的最大值[小于等于](https://baike.baidu.com/item/小于等于/3708346?fromModule=lemma_inlink)后段序列最小值，则说明序列可以直接形成一段有序序列不需要再归并，反之则需要。所以在序列本身有序的情况下[时间复杂度](https://baike.baidu.com/item/时间复杂度/1894057?fromModule=lemma_inlink)可以降至O(*n*)

[TimSort](https://baike.baidu.com/item/TimSort/10279720?fromModule=lemma_inlink)可以说是归并排序的终极优化版本，主要思想就是检测序列中的天然有序子段（若检测到严格降序子段则翻转序列为升序子段）。在最好情况下无论升序还是降序都可以使时间复杂度降至为O(*n*)，具有很强的[自适应性](https://baike.baidu.com/item/自适应性/56627350?fromModule=lemma_inlink)。

|              | 最好时间复杂度 | 最坏时间复杂度 | 平均时间复杂度 | 空间复杂度 | 稳定性 |
| ------------ | -------------- | -------------- | -------------- | ---------- | ------ |
| 传统归并排序 | O(*n*log*n*)   | O(*n*log*n*)   | O(*n*log*n*)   | T(n)       | 稳定   |
| 改进归并排序 | O(*n*)         | O(*n*log*n*)   | O(*n*log*n*)   | T(n)       | 稳定   |
| TimSort      | O(*n*)         | O(*n*log*n*)   | O(*n*log*n*)   | T(n)       | 稳定   |

注：文献 [1]是一种改进的原地归并算法，[空间复杂度](https://baike.baidu.com/item/空间复杂度/9664257?fromModule=lemma_inlink)为O(1)。在表格里的改进归并排序只是引入其预先判断的这一步，这样便可使传统归并排序时间复杂度降至O(*n*)。

# 堆排序

**堆排序**

　　堆排序是利用**堆**这种数据结构而设计的一种排序算法，堆排序是一种**选择排序，**它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。

**堆**

　　**堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：**

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217182750011-675658660.png)

同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217182857323-2092264199.png)

该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：

**大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]**  

**小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]**  

ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：

## 堆排序基本思想及步骤

> 　　**堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了**

**步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。**

　　a.假设给定无序序列结构如下

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192038651-934327647.png)

2.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192209433-270379236.png)

4.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192854636-1823585260.png)

这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217193347886-1142194411.png)

此时，我们就将一个无需序列构造成了一个大顶堆。

**步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。**

a.将堆顶元素9和末尾元素4进行交换

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217194207620-1455153342.png)

b.重新调整结构，使其继续满足堆定义

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218153110495-1280388728.png)

c.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218152929339-1114983222.png)

后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218152348229-935654830.png)

再简单总结下堆排序的基本思路：

　　**a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;**

　　**b.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;**

　　**c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。**

## 代码实现

```js
// 堆排序
function heapSort(arr) {
  // 构建最大堆
  buildMaxHeap(arr);

  // 从最后一个非叶节点开始进行下沉操作，依次取出堆顶元素放到数组末尾，再重新调整堆结构
  for (let i = arr.length - 1; i > 0; i--) {
    // 将堆顶元素与当前未排序部分的最后一个元素交换
    swap(arr, 0, i);
    // 对交换后的堆顶元素进行下沉操作，调整堆结构
    heapify(arr, 0, i);
  }

  return arr;
}

// 构建最大堆
function buildMaxHeap(arr) {
  const len = arr.length;
  // 从最后一个非叶节点开始，依次进行下沉操作，构建最大堆
  for (let i = Math.floor(len / 2) - 1; i >= 0; i--) {
    heapify(arr, i, len);
  }
}

// 下沉操作，调整堆结构
function heapify(arr, i, len) {
  const left = 2 * i + 1; // 左子节点索引
  const right = 2 * i + 2; // 右子节点索引
  let largest = i; // 当前节点索引

  // 与左子节点比较，找出最大的节点索引
  if (left < len && arr[left] > arr[largest]) {
    largest = left;
  }

  // 与右子节点比较，找出最大的节点索引
  if (right < len && arr[right] > arr[largest]) {
    largest = right;
  }

  // 如果最大节点不是当前节点，则交换它们，并继续进行下沉操作
  if (largest !== i) {
    swap(arr, i, largest);
    heapify(arr, largest, len);
  }
}

// 交换数组中两个元素的位置
function swap(arr, i, j) {
  const temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}

// 示例用法
const arr = [6, 2, 8, 4, 1, 9, 5, 7, 3];
const sortedArr = heapSort(arr);
console.log(sortedArr);
```

## 性能

　　堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)...1]逐步递减，近似为nlogn。所以堆排序时间复杂度一般认为就是O(nlogn)级。

## 问答题

1. 常见的排序算法有哪7种？平均，最小，最大时间复杂度各是什么？

   > 1. **冒泡排序**
   >
   >    平均时间复杂度：O(n^2^)
   >    最坏时间复杂度：O(n^2^)
   >    最好时间复杂度：O(n)
   >
   > 2. **选择排序**
   >
   >    平均时间复杂度：O(n^2^)
   >    最坏时间复杂度：O(n^2^)
   >    最好时间复杂度：O(n^2^)
   >
   > 3. **插入排序**
   >
   >    平均时间复杂度：O(n^2^)
   >    最坏时间复杂度：O(n^2^)
   >    最好时间复杂度：O(n)
   >
   > 4. **希尔排序**
   >
   >    平均时间复杂度：O(n log n)
   >    最坏时间复杂度：O(n^2^)
   >    最好时间复杂度：O(n)
   >
   > 5. **归并排序**
   >
   >    平均时间复杂度：O(n log n)
   >    最坏时间复杂度：O(n log n)
   >    最好时间复杂度：O(n log n)
   >
   > 6. **快速排序**
   >
   >    平均时间复杂度：O(n log n)
   >    最坏时间复杂度：O(n^2^)
   >    最好时间复杂度：O(n log n)
   >
   > 7. **堆排序**
   >
   >    平均时间复杂度：O(n log n)
   >    最坏时间复杂度：O(n log n)
   >    最好时间复杂度：O(n log n)
   >

2. 希尔排序为什么要使用插入排序作为每一轮的排序算法？它和插入排序有什么区别？

   > 希尔排序基于插入排序的，是插入排序的一种改进。但在插入之前，它会先对数据进行分组，然后对每组数据进行插入排序。
   >
   > 希尔排序之所以要使用插入排序作为每一轮的排序算法，是因为插入排序是一种稳定的排序算法，它可以保证数据在排序过程中的相对顺序不变。而希尔排序的目的之一就是减少数据在排序过程中的移动次数，因此使用插入排序作为每一轮的排序算法可以保证数据在排序过程中的相对顺序不变，从而减少数据的移动次数。
   >
   > 希尔排序和插入排序的区别在于，希尔排序在插入之前会先对数据进行分组，而插入排序则不会。希尔排序的平均时间复杂度为 O(n^1.5^)，而插入排序的平均时间复杂度为 O(n^2^)。因此，希尔排序比插入排序更快。

3. 快速排序算法流程是什么？什么时候会达成最差时间复杂度？

   > 快速排序是首先会选择一个基准元素，然后将数组中的元素分为两个子数组，其中一个子数组包含所有小于基准元素的元素，另一个子数组包含所有大于基准元素的元素。然后，快速排序会递归地对这两个子数组进行排序。
   >
   > 快速排序的最坏时间复杂度为 O(n^2^)。最坏时间复杂度发生在数组中元素已经有序或者逆序以及输入数组中的所有元素都相同这两种情况 。
   >

## 代码题

1. 请实现冒泡排序

   ```js
   function bubbleSort(arr){
       for(let i = arr.length-1; i >=0; i--){
           for(let j = 0; j < i; j++){//j<i是因为，每一次i的遍历，i后面的数据段都是冒泡完成有序的，不需要浪费时间去遍历已经排好了的
               if(arr[j] > arr[j+1]){
                   let v = arr[j+1]
                   arr[j+1] = arr[j]
                   arr[j] = v//若前者比后者大，arr[j+1]和arr[j]换值，大的值冒泡，每轮找出无序段的最大值
               }
           }
       }
   }
   let arr = [8,0,5,1,5,8,9,0,7,3]
   bubbleSort(arr)
   console.log(arr)
   ```

   

2. 请实现插入排序

   ```js
   function insertSort(arr){
       for(let i = 1; i < arr.length; i++){
           let key = arr[i]
           let j = i-1;//若放在循环条件里面，let块级作用域，在循环外访问不到j的值，所有放在外面
           while(j >= 0 && key < arr[j]){
               arr[j+1] = arr[j]
               console.log(arr)//观察数据处理的过程
               j--
           }
           arr[j+1] = key
       }
       return arr
   }
   let arr = [3,5,1,8,5,9,0,7]
   insertSort(arr)
   console.log(arr)
   ```

   

3. 请实现选择排序

   ```js
   function selectionSort(arr){
       for(let i = 0; i<arr.length; i++){
           let minIdx = i// 无序区中最小元素位置
           for(let j = i+1; j <arr.length; j++){// 找出"a[i+1] ... a[n]"之间的最小元素，并赋值给minIdx。
               if(arr[j]<arr[minIdx]){
                   minIdx = j
               }
           }
           // 若minIdx!=i，则交换 a[i] 和 a[min]。
           // 交换之后，保证了a[0] ... a[i] 之间的元素是有序的。
           if(minIdx != i){           
               let val = arr[i]
               arr[i] = arr[minIdx]
               arr[minIdx] = val
           }
           console.log(arr)//观察选择排序过程
       }
   }
   let arr = [8,0,5,1,5,8,9,0,7,3]
   selectionSort(arr)
   console.log(arr)
   ```

   

4. 请自学并实现希尔排序

   ```js
   var arr1 = [5, 4, 8, 1, 3, 7, 0, 9, 2, 6];
   function shellSort(arr) {
       var len = arr.length;
       var tmp = undefined;
       var gap = Math.floor(len / 2);
       while (gap >= 1) {
           for (var i = 0; i < len; i++) {
               for (var j = i; j >= gap; j = j - gap) {
                   if (arr[j] < arr[j - gap]) {
                       tmp = arr[j];
                       arr[j] = arr[j - gap];
                       arr[j - gap] = tmp;
                   }
               }
           }
           gap = Math.floor(gap / 2);
       }
       return arr;
   }
   shellSort(arr1);
   ```

   

5. 请实现快速排序

   ```js
   function quickSort(arr,left,right){
       if(left>=right) return arr
       let i = left
       let j = right
       let pivot = arr[j]//随机或者最后一个都行
       while(i<j){
           while(i<j && arr[i]<=pivot) {i++}
           arr[j] = arr[i]
           while(i<j && arr[j]>=pivot) {j--}
           arr[i] = arr[j]
       }
       arr[j] = pivot
       quickSort(arr,left,j-1)
       quickSort(arr,j+1,right)
   }
   let arr = [3,4,1,9,5,0,4,5,7,8]
   quickSort(arr,0,arr.length-1)
   console.log(arr)
   ```

   